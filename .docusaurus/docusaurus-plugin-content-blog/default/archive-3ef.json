{
  "blogPosts": [
    {
      "id": "/macbook-experience",
      "metadata": {
        "permalink": "/macbook-experience",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/lifestyle/MacBook 体验有感.md",
        "source": "@site/blog/lifestyle/MacBook 体验有感.md",
        "title": "MacBook 体验有感",
        "description": "首先我不是 iphone 用户，甚至是果黑（苹果的小黑子，合理来说是苹果手机的小黑子），所以我一向从内心就很摈弃苹果的产品。因此我从来没体验过 MacOS 系统，用了近 4 年 window，不过由于我的那台 window 本 （21 年小新 pro14） 给我的体验非常差，虽然说续航勉勉强强足够支撑我一个下午的开发，但 intel 的 i5 cpu 我就没打算将其作为主力机开发（根本做不了），更多是使用向日葵远程桌面软件来远程连接到我的台式电脑，远程操控来进行开发。然而由于屏幕分辨率不同以及网络延迟，这样的体验长期下去必然会崩溃。因此更换自己的移动办公设备已经成了我当下的刚需。",
        "date": "2023-05-05T00:00:00.000Z",
        "formattedDate": "2023年5月5日",
        "tags": [
          {
            "label": "macOS",
            "permalink": "/tags/mac-os"
          },
          {
            "label": "MacBook",
            "permalink": "/tags/mac-book"
          },
          {
            "label": "使用体验",
            "permalink": "/tags/使用体验"
          }
        ],
        "readingTime": 10.26,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "/macbook-experience",
          "title": "MacBook 体验有感",
          "date": "2023-05-05T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "macOS",
            "MacBook",
            "使用体验"
          ],
          "keywords": [
            "macOS",
            "MacBook",
            "使用体验"
          ]
        },
        "nextItem": {
          "title": "距离我上篇笔记还是在?",
          "permalink": "/why-i-dont-write-notes"
        }
      },
      "content": "![](https://img.kuizuo.cn/My%20Mac.png)\n\n首先我不是 iphone 用户，甚至是果黑（苹果的小黑子，合理来说是苹果手机的小黑子），所以我一向从内心就很摈弃苹果的产品。因此我从来没体验过 MacOS 系统，用了近 4 年 window，不过由于我的那台 window 本 （21 年小新 pro14） 给我的体验非常差，虽然说续航勉勉强强足够支撑我一个下午的开发，但 intel 的 i5 cpu 我就没打算将其作为主力机开发（根本做不了），更多是使用向日葵远程桌面软件来远程连接到我的台式电脑，远程操控来进行开发。然而由于屏幕分辨率不同以及网络延迟，这样的体验长期下去必然会崩溃。因此**更换自己的移动办公设备已经成了我当下的刚需。**\n\n见识到诸多程序员大神都将 mac 作为主力开发机器，同时又被安利过很多次 MacBook，但我一直对 macOS 保持观察的态度，自己从未亲自体验过，最多也就看别人用用，在 window 上这些同样也能实现，何必要多此一举再去了解一个新的系统，新的操作逻辑。但直到我真正接触并体验过 macOS 后，我便爱不释手。\n\n在写这篇文章时，我已经用了近一周的 macbook，因此想分享个人的购买流程、选购建议、使用感悟，或许对于某些想要尝试 MacOS 但又保有迟疑态度的用户有所帮助，也算是给曾经的我对苹果的偏见的转变。\n\n> 拖更了近两个月的博文了，摆了一整子，说来也确实有些许惭愧。不过目前生产力工具已就绪，也要开始步入正轨。\n\n<!-- truncate -->\n\n## 购买流程\n\n我是在线下 apple 授权店买的，五一假期的前一天晚上逛商场的时候正好经过，于是进去与店员交谈了一整子，又思考了一晚上，最终决定第二天直接现货 购买了丐版（标准版）的 macbook m2 pro 14 寸 16g + 512g。\n\n至于选择 14 寸还是 16 寸，就因人（钱）而异，去线下给我最大的感受就是 16 寸是真的大，且厚重（14 寸也挺重的有 2kg），通常我在室内我就会拓展外接显示器加上偶尔有床上办公的需求所以在看到第一眼后便毫不犹豫的选择 14 寸作为我的目标尺寸。\n\n至于说选择 m2 pro 还是 m2 max，这条[链接](https://www.apple.com.cn/macbook-pro-14-and-16/)与下图能告诉你答案。\n\n![Untitled](https://img.kuizuo.cn/202305050428893.png)\n\n其次就是选配方面，在之前我是打算购买 32g + 1t 的。但在如今一堆 electron 应用（一个就要吃至少 100m 的内存），加上我本身的会有多开几个 vscode 以及多个浏览器标签， 16g 内存在 window 下对于开发从事者而言已经不够使用了，在 mac 上 从我的事实也证明 16g 内存 在两个正在运行中的 node 与 的 10 来个浏览器标签，加上一些常用软件（微信、QQ、飞书、）是有些不够用了，以下对应的活动监视图（window 中的任务管理器）\n\n![Untitled](https://img.kuizuo.cn/202305050429190.png)\n\n虽说有 swap，表面上的 16g 物理内存实际上运行内存可能会更多，但最主要还是看内存压力。不过即使是这样，系统也没有出现过任何的卡顿，这要是换 windows，恐怕已经蓝屏了。等哪天内存压力变红时或者出现卡顿现象，再来汇报相关进程。（新买的机子，不舍得压力测试折腾她）\n\n而 m2 pro 的 512g 相比 1t 读写速度减少一半（看下图你便懂了，单通道的速度和两个 512g 组双通道相比），事实上在之前的丐版都存在这种问题，可以说苹果是巴不得你加购硬盘容量，不然硬盘速度缩半。\n\n![Untitled](https://img.kuizuo.cn/202305050428895.png)\n\n而 1t 及以上容量自然是无该问题，何况不加配的 mac 能叫 mac 吗。我其实是很想加配的，但无奈无现货，并且官网定制这个配置（m2 pro 32g + 1t）的还需要等待 2 个星期，据店员说“这只是预计，实际可能会更久“，不过这里不排除店员这么说诱导我在购买丐版现货。\n\n![Untitled](https://img.kuizuo.cn/202305050428896.jpeg)\n\n不过最终能让我购买的很大原因是在五一期间我实在不想用那破 window 本，因此第二天再次联系店员决定直接付款拿丐版现货。因为考虑两年后大概率也会更换电子设备（距离我上次更换电子设备也过去两年），所以综合考虑当前的配置在这两年应该是足以使用（这句话也许说的有点早）。\n\n实体店与线上购买没有本质的区别，**价格上都是一致的**，也是有教育优惠的。只是人家会帮你激活设备，在你的眼皮子底下看看有无问题，确认无误后，交钱走人便可。此外可能还会赠送一些额外的一些配件，如键盘膜，屏幕膜，清洁套装，拓展坞（没有手提包），不过这些对我来说都非刚需，只要 MacBook Pro 没问题即可。\n\n不过这里想要提一下，人家是挺极力推荐我购买 apple care 的（顺带有个配件券），据我了解，貌似是有一个 apple care 的指标，需要达到多少这样。不过我个人不喜欢买保险，因此便没有购买。\n\n## 刚到手的 Mac 该如何处理\n\n### 不要贴膜\n\n**不要贴膜，不要贴膜，不要贴膜!**\n\n我本是不想贴膜，喜欢裸机的感觉，但由于附送一个屏幕膜，我便勉为其难的贴一下，然而当我贴完后我随即将辛辛苦苦贴好的膜又给撕了下来了，并不是因为我贴的不好，而是**贴膜简直就是负提升**，前后对比是肉眼可见明显，这里我用相机拍不出肉眼那种效果，如果说喝枸杞是养生，那看 macbook 屏幕说是养眼可一点不为过。毕竟维修一个 Macbook 屏幕就需要 5000 左右，让我萌生一丝购买 apple care 的想法。\n\n其次就是网上都有流传 macbook 的 B 面(屏幕)与 C 面(键盘)之间的间隔特别薄，贴屏幕膜或键盘膜可能都会让这层素质极高的屏幕受到一些损害。还有贴屏幕膜后，在下一次更换屏幕膜的时候，可能会导致屏幕涂层脱落，而贴键盘膜的话，时间久了会导致合盖的时候键盘膜印在屏幕上。总之，基本都是建议裸机。\n\n### 熟悉 mac 操作以及相关软件\n\n这里我推荐自己我自己看过的几个 mac 相关指南，能够帮助小白速度上手 mac。\n\n[Mac 云课堂的个人空间\\_哔哩哔哩\\_bilibili](https://space.bilibili.com/41062266)\n\n[【看完秒懂】Mac 苹果电脑超详细上手入门指南！建议做笔记！up 良心制作，用一集视频包你熟练上手 Mac\\_哔哩哔哩\\_bilibili](https://www.bilibili.com/video/BV1PF411E7LG/)\n\n下面这个会比较针对与程序开发\n\n[2022 我用 MacBook Pro 整一年 【感想 与 踩坑指南】 - 掘金 (juejin.cn)](https://juejin.cn/post/7181274704659873850)\n\n由于我使用时间较短，因此软件方面我不好做出评价与推荐，这里我只附上一张我已安装应用截图\n\n![Untitled](https://img.kuizuo.cn/202305050428897.png)\n\n### 熟悉触控板与应用全屏，提升效率\n\n如果要说使用的这段期间对笔记本电脑的体验变化无意有两点，一是颠覆我对笔记本触控板难用的想法，二是应用全屏（配合台前调度）却能够有如此高效的体验。\n\n这一部分我认为不必过多吹捧，亲自到线下实体店感受才最为真实，相信我，你会爱上触摸板了。\n\n## 选 windows 还是 macOS ？\n\n现在可以毫不犹豫的说，我会选择 macOS，下一台笔电也会选择 macOS 系统。但并不是说什么场景，macOS 都是最优选，就比如说游戏需求，我想没人会买台 mac 来作为自己的游戏机。mac 上几乎玩不到什么 3A 大作，甚至在 m2 芯片上，你可能都无法下载 wegame 来玩上一把英雄联盟。\n\n![Untitled](https://img.kuizuo.cn/202305050428898.png)\n\n如果你有桌面游戏的需求，建议拉黑 mac。此外还有一些 window 的专业软件，你在 mac 上可能找不到与之对应或平替的软件，尤其是在大学课程中，老师几乎不可能给学生发个 dmg 文件，如果你在大学期间买 mac，又要兼顾学校的课程软件需求，又不得不安装 window 虚拟机，与其如此折腾不如一开始就选用相对便宜的 win 本，还能减少一些经济压力。不过我觉得大学老师上课所说的一些软件都没必要安装，反而占用一些不必要的空间，（vc++、eclipse 等等），如果你们老师提到了 Vscode 那当我没说。\n\n但出色的系统、高素质的屏幕，注定能让 MacBook 能够成为某部分群体的生产力工具，挣钱的机器。选用 macbook 的用户想必都希望在它任职期间产生数十倍的价值，当然排除我这个买来尝鲜的。\n\n## 开发上的体验提升\n\n目前手头的三台电脑设备对应的 CPU（性能从高到低）M2 Pro > AMD 5900x > i5-11300H\n\n![Untitled](https://img.kuizuo.cn/202305050428899.png)\n\n![Untitled](https://img.kuizuo.cn/202305050428900.png)\n\n这里我没找到比较好的前端 benchmark 项目，但就从我个人直观的体验与在这三台机器启动同一个前端项目启动与打包来看，在冷启动上，m2 pro 耗费 1.7s, 5900x 耗费 2.8s，i5-11300H 我都不想拉项目，去年的暑假靠这台 win 本进行开发，别提体验有多差，每次都需要干巴巴的干等项目完全启动就需要等个 2、3 分钟（不夸张），有时候可能因为某些特殊原因需要重启服务，好的，又浪费个 2、3 分钟。影响你效率的可能不只是环境，还有你的机器。\n\n冷启动都能有近 1s 的优势，就别提热加载和打包速度上，这里直接给出我打包一个 Nuxt 项目的打包时间输出耗时，m2 pro 耗时 27s、5900x 耗时 116s（数据真实有效），快的让我有点感觉我是不是少写了某部分代码，还是说多注释了些代码。\n\n性能优势可能不是最大的优势，最主要是即便断电状态下也不会有丝毫的性能丢失，这让我非常惊叹，因为通常 win 本，如果是游戏本通常就会掉帧，而轻薄本通常性能就随着电量降低而降低。\n\n## 结语\n\n相对遗憾的是购买的还是相对匆忙，就是没有加配 32g，虽说目前来说 16g 勉强能够应付绝大部分场景，但免不了后续爆内存，又无能为力的情况。但想到自己仿佛挖到了一个新世界的宝藏，这种担忧就显得不足为惧。\n\n在写完这篇稿子时，回头用起 win 时，都习惯性的按下 `Alt + C` 键位，殊不知 `Ctrl + C` 才是 mac 的复制。适应也许只需要几天的时间，但回去也许可能大半辈子都不再回去。\n\n从被别人安利到用 mac，再到自己安利别人用 mac，这种对 macOS 系统相见恨晚的感受，也许只有使用过 macOS 的人才能理解。**很多东西只有自己用过才知道，只有尝试过，才知道适不适合自己。不尝试并不会丢失什么，但尝试过后往往能够收获意想不到的东西。**\n\n如果你还没有尝试过 macOS 系统，那么你或许真的错过了很多。"
    },
    {
      "id": "why-i-dont-write-notes",
      "metadata": {
        "permalink": "/why-i-dont-write-notes",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/lifestyle/距离我上篇笔记还是在.md",
        "source": "@site/blog/lifestyle/距离我上篇笔记还是在.md",
        "title": "距离我上篇笔记还是在?",
        "description": "当我起这个标题时，其实我已经很久没更新（翻看）过笔记了，甚至我都不记得我的博客还有笔记这个东西。",
        "date": "2023-03-13T00:00:00.000Z",
        "formattedDate": "2023年3月13日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "杂谈",
            "permalink": "/tags/杂谈"
          }
        ],
        "readingTime": 4.996666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "why-i-dont-write-notes",
          "title": "距离我上篇笔记还是在?",
          "date": "2023-03-13T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "杂谈"
          ],
          "keywords": [
            "随笔",
            "杂谈"
          ]
        },
        "prevItem": {
          "title": "MacBook 体验有感",
          "permalink": "/macbook-experience"
        },
        "nextItem": {
          "title": "Typescript 全栈最值得学习的技术栈 TRPC",
          "permalink": "/typescript-full-stack-technology-trpc"
        }
      },
      "content": "当我起这个标题时，其实我已经很久没更新（翻看）过笔记了，甚至我都不记得我的博客还有笔记这个东西。\n\n当我翻阅 git 记录，寻找上一次在笔记文件夹的 commit 提交记录，还是在去年的 10 月 1 号。\n\n![image_U0EDw0PkAf1](https://img.kuizuo.cn/image_U0EDw0PkAf1.png)\n\n然而并不是我的技术栈没更新，而是我实实在在没去为这些技术栈编写过笔记。仅有的只是博文来记录自己所用的过程。\n\n因此我想思考下我为何不记录笔记。\n\n<!-- truncate -->\n\n## 笔记的意义\n\n首先不妨回答一下我所认为的笔记意义。\n\n### 检索高效\n\n当我需要回忆我曾经学习过的某个知识点时，笔记可以说是最直接有效的办法。与其再次使用搜索引擎搜寻答案，不妨直接从答案中找答案。\n\n> 正如我笔记简介所述：**做到即查即用，能复制粘贴解决的，就绝不百度。**\n\n### 巩固理解\n\n相比绝大多数笔记内容都是初学者去记录自己所学，在这个阶段，你对知识的掌握程度是比较浅显的，而笔记无非能加快你的理解，同时也是是成本最低的，翻看自己的内容远比理解他人的内容来的简单。\n\n## 学习方式\n\n很多初学者除了通过视频教程来学习，当然不乏有些人是通过别人的学习经验（即笔记）来进行学习，包括我一开始也是通过刷别人的笔记来学习某个知识。\n\n不过相对于视频而言，视频通常很啰嗦且时长感人（动辄可能数天的时长）。很多人不喜欢铺垫，不喜欢废话，就想知道某个知识点怎么用，结果如何。同时视频没有搜索功能，如果视频创作者没有对视频进行分集，当你需要回看的时候时，你往往需要从数十分钟的视频中不断的拖动，甚至到最后才发现原来我看的不是这个视频。\n\n而文档则不会，那你可以通过 Ctrl + F 搜索你想要的关键字，相比视频而言，检索的效率将会大大提升。\n\n这也是我为何从视频学习转成文档学习很重要的原因。我也很推荐如今的学习者从文档学习，而不是视频学习。\n\n## 为何不写笔记\n\n### 笔记应该记录哪些知识点？\n\n笔记无疑是耗时的，你可能会花费数个小时的时间，去总结一个可能你职业生涯中都用不到几次的知识。\n\n为什么这么说，因为我发现我有很多笔记就是这种情况，你也可以回想一下你所记录的笔记，有多少是经常使用到的。\n\n尤其是当你使用的足够多的情况下，你甚至都无需翻阅笔记。脑海中自然就会复现出你需要的东西，此时为何还需要看笔记。为了验证脑海中的正确性吗？\n\n想想看你会为怎样的知识点大费周章的记录，是一个自己都不怎么用的知识点，还是用到滚瓜烂熟的知识点？\n\n当我们经常使用某些知识点时，自然而然就会记住它们，这时笔记就没有太大的意义了；而对于使用频率较低的知识点，记录下来的意义也不是很大。\n\n### 搜索大于记录\n\n究其原因，还是因为我翻看笔记的频率变少了许多。如今的搜索引擎很智能，只要你用的不是百度，就能很快速的搜寻到答案，为何还需要记录一下，换成自己熟悉的口吻，到最后就变成上面所说的那样。而在 ChatGPT ，new bing 的诞生下，更加剧了我这一行为。\n\n**当搜索大于记录时，笔记就显得弱不禁风。**\n\n### 官方文档与学习笔记\n\n说实话，当你看到别人的笔记的时候，你会认真的从头到尾看一遍吗？我想不会，更多情况我们只利用搜索功能去获取我们想要的知识点。\n\n但如果此时有两份文档，一份是官方的技术文档，一份是他人的学习笔记文档。你会选择哪一份？是我肯定毫不犹豫的选择前者，他人的学习笔记并不会及时更新，但官方文档只要还在维护，那么必定处于常更新的状态。假设我照着他人的学习笔记学习，此时正好有个函数的使用方法更新了，那么我必定会踩坑，导致不必要的bug。而官方文档则不会，官方一旦有破坏性更新，通常会有显眼的提示，和 changelog 可供我参考，这就能及时有效的帮我排除不必要的坑。\n\n这也是我为什么会宁愿去看官方文档，哪怕是英文的，也绝不愿去看第三方中文翻译后的文档，我有太多的坑就是因为更新不及时，存在信息差导致的。所以无论如何，能获取一手的信息，就别用二手的，甚至你也不知道人家会加工成什么样子。\n\n## 最后\n\n综上，我想我已经把我为何不写笔记的原因讲述的比较清楚了。\n\n当然我并不是说笔记就一无是处，因为每个人，每个阶段的学习方式不同。曾经我也是笔记学习的追崇者，但如今的我能够不借助视频教程，不借助笔记来进行独立学习，所以为何不选择一个对我而言更高效的方式。"
    },
    {
      "id": "typescript-full-stack-technology-trpc",
      "metadata": {
        "permalink": "/typescript-full-stack-technology-trpc",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Typescript 全栈最值得学习的技术栈 TRPC.md",
        "source": "@site/blog/program/Typescript 全栈最值得学习的技术栈 TRPC.md",
        "title": "Typescript 全栈最值得学习的技术栈 TRPC",
        "description": "本文介绍了 tRPC 技术以及它与传统 RESTful API 的区别。同时 tRPC 可以帮助人们更快地开发全栈 TypeScript 应用程序，同时无需传统的 API 层，并保证应用程序在快速迭代时的稳定性。",
        "date": "2023-03-07T00:00:00.000Z",
        "formattedDate": "2023年3月7日",
        "tags": [
          {
            "label": "trpc",
            "permalink": "/tags/trpc"
          },
          {
            "label": "next",
            "permalink": "/tags/next"
          },
          {
            "label": "prisma",
            "permalink": "/tags/prisma"
          },
          {
            "label": "zod",
            "permalink": "/tags/zod"
          },
          {
            "label": "auth.js",
            "permalink": "/tags/auth-js"
          }
        ],
        "readingTime": 14.92,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "typescript-full-stack-technology-trpc",
          "title": "Typescript 全栈最值得学习的技术栈 TRPC",
          "date": "2023-03-07T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "trpc",
            "next",
            "prisma",
            "zod",
            "auth.js"
          ],
          "keywords": [
            "trpc",
            "next",
            "prisma",
            "zod",
            "auth.js"
          ],
          "description": "本文介绍了 tRPC 技术以及它与传统 RESTful API 的区别。同时 tRPC 可以帮助人们更快地开发全栈 TypeScript 应用程序，同时无需传统的 API 层，并保证应用程序在快速迭代时的稳定性。",
          "toc_max_heading_level": 3
        },
        "prevItem": {
          "title": "距离我上篇笔记还是在?",
          "permalink": "/why-i-dont-write-notes"
        },
        "nextItem": {
          "title": "将 Supabase 作为下一个后端服务",
          "permalink": "/use-supabase-as-backend-service"
        }
      },
      "content": "![trpc-banner](https://img.kuizuo.cn/trpc-banner.png)\n\n如果你想成为一个 **Typescript 全栈工程师**，那么你可能需要关注一下 [tRPC](https://trpc.io/) 框架。\n\n本文总共会接触到以下主要技术栈。\n\n- [Next.js](https://nextjs.org/ 'Next.js')\n- [TRPC](https://trpc.io/ 'TRPC')\n- [Prisma](https://www.prisma.io/ 'Prisma')\n- [Zod](https://github.com/vriad/zod 'Zod')\n- [Auth.js](https://authjs.dev/ 'Auth.js')\n\n不是介绍 tRPC 吗，怎么突然出现这么多技术栈。好吧，主要这些技术栈都与 typescript 相关，并且在 trpc 的示例应用中都或多或少使用到，因此也是有必要了解一下。\n\n在线体验地址：[TRPC demo](https://trpc.kuizuo.cn/)\n\n<!-- truncate -->\n\n## End-to-end typesafe APIs(端到端类型安全)\n\n在介绍相关技术前，不妨思考一个问题。\n\n> 当进行网络请求和 API 调用时，你是否知道本次请求的参数类型以及返回的响应数据类型？知道了请求的数据类型与响应的数据类型，会为得到的 json 数据定义 type/interface，使其有更好的类型提示？还是会在 any 类型下获取属性，但由于没有类型提示，导致写错个单词，最终提示 Cannot read properties of undefined (reading 'xxx')？\n\n对于大部分前端应用而言，类型往往常被忽略的，这就导致不知道这个请求的提交参数、响应结果有什么数据字段。举个 axios 发送 post 请求的例子\n\n![image-20230308142331808](https://img.kuizuo.cn/image-20230308142331808.png)\n\n这是一个 post 请求用于实现登录的，但是这个响应数据 data 没有任何具体提示（这里的提示是 vscode 记录用户最近输入的提示），这时候如果一旦对象属性拼写错误，就会导致某个数据没拿到，从而诱发 bug。同理提交的请求体 body 不做约束，万一这个请求还有验证码 code 参数，但是我没写上，那请求就会失败，这是就需要通过调试输出，甚至需要抓包比对原始数据包，其过程可想而知。\n\n最主要的是没有类型约束的情况下，非常容易出现访问某个对象属性不存在，js 开发者肯定经常遇到如下错误提示。\n\n```typescript\nCannot read properties of undefined (reading 'xxx')\n```\n\n有太多时候就是因为没有类型，无形间诱发 bug，这也是很多做 api 接口都常常忽视的一点。\n\n> 因此我个人所认为的未来 Web 框架形态是要满足的前提就是前后端类型统一，即可以将后端的类型无缝的给前端使用，反之同理。而像 Next、Nuxt 这样的全栈框架便是趋势所向。\n\n当然 axios 是可以通过泛型的方式拿到 data 的数据类型提示，就如下图所示。\n\n![image-20230308142452678](https://img.kuizuo.cn/image-20230308142452678.png)\n\n但这样为了更好的类型提示，无形之间又增加了工作量，我需要定义每个接口的 Response 与 Body 类型，就极易造成开发疲惫，不愿维护代码。而本次所要介绍的技术栈 tRPC 就能够帮你省去重复的类型定义的一个 web 全栈框架。\n\n## [tRPC](https://github.com/trpc/trpc)\n\ntRPC 是一个基于 TypeScript 的远程过程调用框架，旨在简化客户端与服务端之间的通信过程，并提供高效的类型安全。它允许您使用类似本地函数调用的方式来调用远程函数，同时自动处理序列化和反序列化、错误处理和通信协议等底层细节。\n\n借官方 Feature\n\n- Automatic type-safety（自动类型安全）\n- Snappy DX（敏捷高效的开发者体验）\n- Is framework agnostic （不依赖于特定框架）\n- Amazing autocompletion（出色的自动补全功能）\n- Light bundle size（轻量级打包大小）\n\n### 什么时候该使用 tRPC\n\n这个问题非常好，因为我在了解到 tRPC，并参阅了一些基本示例与实践一段时间后发现 trpc 和 http 的应用场景可以说非常相似，完全可以使用 trpc 来替代 http，只不过写法上从 **发送 http 请求 ⇒ 调用本地函数**（这在后面会演示到）。\n\n而 trpc 又以类型安全与高效著称，如果你的 Web 应用的程序是基于 typescript，并且需要有高效的性能，那么 tRPC 就是一个很好的选择。\n\ntRPC 可以作为 REST/GraphQL 的替代品，如果前端与后端共享代码的 TypeScript monorepo，trpc 则可以无需任何类型转换，也不太会有心智负担。\n\n**请记住，tRPC 只有当您在诸如 Next、Nuxt、SvelteKit、SolidStart 等全栈项目中使用 TypeScript 时，tRPC 才会发挥其优势。**\n\n## tRPC 如何进行接口调用\n\n<video src=\"https://assets.trpc.io/www/v10/v10-dark-landscape.mp4\" controls=\"controls\" width=\"100%\" height=\"auto\"></video>\n\n一图胜千言，你可以点击 [这里](https://trpc.io/#try-it-out '这里') 在线体验一下 tRPC，并且查看其目录结构，以及调用方式。下面我一步步讲解如何进行接口调用。\n\n### 定义服务端\n\n这里以 Next.js 的目录结构而定。创建 `server/trpc.ts`，如下代码。分别导出 router, middleware, procedure\n\n```typescript title='server/trpc.ts'\nimport { initTRPC } from '@trpc/server'\n\nconst t = initTRPC.create()\n\nexport const router = t.router\nexport const middleware = t.middleware\nexport const publicProcedure = t.procedure\n```\n\n创建项目(根)路由文件 `pages/api/trpc/[trpc].ts`\n\n```typescript title='server/trpc.ts'\nimport * as trpc from '@trpc/server'\nimport { publicProcedure, router } from './trpc'\n\nconst appRouter = router({\n  greeting: publicProcedure.query(() => 'hello tRPC!'),\n})\n\nexport type AppRouter = typeof appRouter\n```\n\n此时已经定义好了一个路由地址 `api/trpc/[trpc].ts`（这里 endpoint(端点)会在客户端中使用到），以及 `greeting` 函数，服务端的工作就暂且完毕。\n\n### 创建客户端\n\n创建 `utils/trpc.ts` 文件，代码如下\n\n```typescript title='utils/trpc.ts'\nimport { httpBatchLink } from '@trpc/client'\nimport { createTRPCNext } from '@trpc/next'\nimport type { AppRouter } from '../pages/api/trpc/[trpc]'\n\nfunction getBaseUrl() {\n  if (typeof window !== 'undefined') {\n    // In the browser, we return a relative URL\n    return ''\n  }\n  // When rendering on the server, we return an absolute URL\n\n  // reference for vercel.com\n  if (process.env.VERCEL_URL) {\n    return `https://${process.env.VERCEL_URL}`\n  }\n\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpBatchLink({\n          url: getBaseUrl() + '/api/trpc',\n        }),\n      ],\n    }\n  },\n})\n```\n\n在 `_app.tsx` 包装一下\n\n```typescript title='_app.tsx'\nimport type { AppType } from 'next/app'\nimport { trpc } from '../utils/trpc'\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />\n}\n\nexport default trpc.withTRPC(MyApp)\n```\n\n有了这个对象后，我们就可以开始尽情调用服务端所定义好了函数了。\n\n当你导入 trpc 并输入 `trpc.` 时，将会提示出服务端定义好的 `greeting` 函数，如下图所示。\n\n![](https://img.kuizuo.cn/image_YDKc7TixQA.png)\n\n此时通过 `const result = trpc.greeting.useQuery()` 便可调用 `greeting` 函数，其中 `result.data` 便可拿到 `'hello tRPC!'` 信息。\n\n### 这个过程发生了什么？\n\n> 文档: [useQuery() | tRPC](https://trpc.io/docs/useQuery 'useQuery() | tRPC')\n\n不妨此时打开控制台面板，看看请求\n\n![](https://img.kuizuo.cn/image_WfW8ehqUKz.png)\n\n![](https://img.kuizuo.cn/image_qicvoGjshx.png)\n\n不难看出，调用 greeting 函数本质是向 `/api/trpc/greeting` 发送了 http 请求，并且携带参数 batch 和 input，虽然我们暂时还没有传。默认 input 为 {}。\n\n要支持传递参数，首先需要在服务端定义传递参数的类型（会有 Zod 对参数效验），这样客户端才有对应的类型提示。然后调用 greeting 函数时，通过通过函数参数的形式来传递请求参数。\n\n举例说明，比如说我们将 appRouter 改写成这样，通过 input 参数指定了 `useQuery` 需要传递一个 `name` 为字符串且不为空的对象。\n\n```typescript\nimport z from 'zod'\n\nconst appRouter = router({\n  greeting: publicProcedure\n    .input(\n      z.object({\n        name: z.string().nullish(),\n      }),\n    )\n    .query(({ input }) => {\n      return {\n        text: `hello ${input?.name ?? 'world'}`,\n      }\n    }),\n})\n```\n\n调用 `trpc.greeting.useQuery({ name: 'kuizuo' })` 发送的请求的 query 参数则变为\n\n![](https://img.kuizuo.cn/20230307214659.png)\n\n不仅于此，你如果同时调用了多次 greeting 函数，如\n\n```typescript title='pages/index.tsx'\nconst result1 = trpc.greeting.useQuery({ name: 'kuizuo1' })\nconst result2 = trpc.greeting.useQuery({ name: 'kuizuo2' })\nconst result3 = trpc.greeting.useQuery({ name: 'kuizuo3' })\n```\n\ntRPC 会将这三次函数调用合并成一次 http 请求，并且得到的响应本文也是以多条数据的形式返回\n\n![](https://img.kuizuo.cn/image_ufrhaugaIj.png)\n\n![](https://img.kuizuo.cn/image_cvlDJjhwPl.png)\n\n分别输出三者 result 也没有任何问题。\n\n![](https://img.kuizuo.cn/image_hbL8So_RzB.png)\n\n这是 tRPC 的一个特性：**请求批处理，将同时发出的请求（调用）可以自动组合成一个请求。**\n\n#### [useMutation() | tRPC](https://trpc.io/docs/useMutation 'useMutation() | tRPC')\n\ntRPC 同样也支持 post 请求，例如\n\n服务端代码\n\n```typescript title='server/trpc.ts'\nconst appRouter = router({\n  createUser: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(req => {\n      const user: User = {\n        name: req.input.name,\n      }\n\n      return user\n    }),\n})\n```\n\n客户端代码\n\n```typescript title='pages/index.tsx'\nexport default function IndexPage() {\n  const mutation = trpc.createUser.useMutation()\n\n  // ERROR!\n  // mutation.mutate({ name: 'kuizuo' });\n\n  const handleCreate = () => {\n    mutation.mutate({ name: 'kuizuo' })\n  }\n\n  return (\n    <div>\n      <button onClick={handleCreate} disabled={mutation.isLoading}>\n        Create\n      </button>\n      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}\n    </div>\n  )\n}\n```\n\n:::danger\n\n这里需要注意 `mutate` 方法无法在外层直接调用，否则将会提示\n\n```typescript\nUnhandled Runtime Error\nError: Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\n```\n\n主要防止这个组件被其他组件调用，此时自动调用 mutate 函数，导致不可控且循环调用的情况，因此需要通过一个事件（比如点击事件）来触发。\n\n:::\n\n此时请求变为 post 请求，并且携带的参数也以 body 形式传递。\n\n![](https://img.kuizuo.cn/image_-qEI8jR1uM.png)\n\n![](https://img.kuizuo.cn/image_RTdWJn_55p.png)\n\n通过 useQuery 和 useMutation 就能够用 tRPC 实现最基本的 CRUD。此外还有 useInfiniteQuery 可以用作类似无限下拉查询，类似 [SWR 无限加载](https://swr.bootcss.com/examples/infinite-loading)。useQueries 批量查询，使用 [Subscriptions](https://trpc.io/docs/subscriptions) 进行订阅 WebSocket 等等。\n\ntRPC 针对 react 项目的查询主要依赖于 [@tanstack/react-query](https://tanstack.com/query/v4/docs/react/adapters/react-query '@tanstack/react-query')，你也可以到 [tRPC React Query documentation](https://trpc.io/docs/react-query 'tRPC React Query documentation') 查看相关 hook。\n\n从上述例子中你就会发现，tRPC 将 http 请求给我们包装成了函数形式调用，即上文所说的，调用服务端接口的形式由 **发送 http 请求 ⇒ 调用本地函数**。\n\n### 不足\n\n不过也并非没有缺点（个人认为）。\n\n首先不如传统的 RESTFUL 来的直观，假设我现在在服务端定义了一个服务，那么我只能通过`@trpc/client` 创建客户端进行调用。虽然也能用 http 的形式，但调用的很不优雅。\n\n在我印象中，RPC 框架通常是可以跨语言进行调用的，比如 gRPC 框架，然而**tRPC 目前只能在 Typescript 项目中进行调用**，我倒是希望能向 gRPC 那个方向发展，不过不同语言间的类型安全又是个大麻烦。\n\n学习成本与项目成本偏高，tRPC 对整个全栈项目的技术要求比较高，并且限定于 typescript，如果你~~想~~将你的项目从传统的 Restful 迁移到 tRPC 上，无疑是个工程量大，且不讨好的事。\n\n## 创建工程\n\n这里选用 [Create T3 App](https://create.t3.gg/ 'Create T3 App') 用于创建应用（也可以选择 [trpc/examples-next-prisma-starter](https://github.com/trpc/examples-next-prisma-starter 'trpc/examples-next-prisma-starter')），Create T3 App 集成了诸多有关 TypeScript full-stack 相关的技术栈，其中就包括了本文所要介绍的几个技术栈。\n\n![](https://img.kuizuo.cn/image_8BUcBPK8In.png)\n\n```shell\npnpm create t3-app@latest\n```\n\n安装过程如下\n\n![](https://img.kuizuo.cn/image_ERGzEt2Tq8.png)\n\n### prisma\n\n此时安装完先别急着 pnpm run dev 启动项目，首先执行\n\n```shell\nnpx prisma db push\n```\n\n运行结果如下\n\n```shell\nEnvironment variables loaded from .env\nPrisma schema loaded from prisma schema.prisma\nDatasource \"db\": SQLite database \"db.sqlite\" at \"file:./db.sqlite\"\n\nSQLite database db.sqlite created at file:./db.sqlite\n\nYour database is now in sync with your Prisma schema. Done in 81ms\n```\n\n这会将数据库与 prisma 的 schema 同步，说人话就是将数据库的表与 `schema.prisma` 文件中的 model 对应。\n\n<details>\n\n<summary>schema.prisma</summary>\n\n```prisma title='prisma/schema.prisma'\ngenerator client {\n    provider = \"prisma-client-js\"\n}\n\ndatasource db {\n    provider = \"sqlite\"\n    url      = env(\"DATABASE_URL\")\n}\n\nmodel Example {\n    id        String   @id @default(cuid())\n    createdAt DateTime @default(now())\n    updatedAt DateTime @updatedAt\n}\n\n// Necessary for Next auth\nmodel Account {\n    id                String  @id @default(cuid())\n    userId            String\n    type              String\n    provider          String\n    providerAccountId String\n    refresh_token     String? // @db.Text\n    access_token      String? // @db.Text\n    expires_at        Int?\n    token_type        String?\n    scope             String?\n    id_token          String? // @db.Text\n    session_state     String?\n    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n    @@unique([provider, providerAccountId])\n}\n\nmodel Session {\n    id           String   @id @default(cuid())\n    sessionToken String   @unique\n    userId       String\n    expires      DateTime\n    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel User {\n    id            String    @id @default(cuid())\n    name          String?\n    email         String?   @unique\n    emailVerified DateTime?\n    image         String?\n    accounts      Account[]\n    sessions      Session[]\n}\n\nmodel VerificationToken {\n    identifier String\n    token      String   @unique\n    expires    DateTime\n\n    @@unique([identifier, token])\n}\n\n```\n\n</details>\n\ncreate-t3-app 默认使用的 sqlite 数据库，优点就是你无需安装任何数据库的环境，将会在 prisma 目录下创建 `db.sqlite` 文件来存放数据。但是缺点很明显，性能与部署方面是远不如主流服务级别的数据库。尤其是部署，这在后面会说。\n\n将会创建 `Account` `Example` `Session` `User` `Verification Token` 表，这里需要教你一个命令\n\n```shell\nnpx prisma studio\n```\n\n此时访问 localhost:5555 将会得到一个 prisma 面板，即项目的所有 model 。\n\n![](https://img.kuizuo.cn/image_QBXnHdoewh.png)\n\n关于 prisma 更多命令请参考 [Prisma CLI Command Reference](https://www.prisma.io/docs/reference/api-reference/command-reference 'Prisma CLI Command Reference')\n\nprisma 在线体验：[Prisma Playground | Learn the Prisma ORM in your browser](https://playground.prisma.io/)\n\n由于 create-t3-app 已经封装好了[数据库的操作](https://create.t3.gg/en/usage/prisma)，并且导出 prisma 对象，所以你只需要配置好环境变量便可。\n\n主要代码如下\n\n```typescript title='server/db.ts'\nimport { PrismaClient } from '@prisma/client'\n\nexport const prisma = new PrismaClient()\n```\n\n#### 类型提示\n\n在上面所定义的 model，都会被 prisma client 创建对应的 typescript 类型（在`node_modules/.prisma/index.d.ts`），你就可以直接通过 prisma.modelName 来操作 model，例如 Example（这里就不做注释了）\n\n```typescript\nimport { prisma } from \"~/server/db\";\n\nprisma.post.findUnique({ where: { id: 1 } });\n\nprisma.post.create({ data: {} });\n\nprisma.post.update(id, { data: {} });\n\nprisma.post.delete(id);\n\nprisma.post.count();\n```\n\n#### 数据迁移\n\n我之前如果做数据库备份的话，我通常会在数据库管理软件（Navicat）将整个数据库转储为 SQL 文件，然后要用的时候在运行该 SQL 文件。而这样做呢虽然方便，但是数据都比较死，而且版本多了 sql 文件也多，导入繁琐。\n\n此时就可以使用 [Migrate](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-typescript-postgres)，通过命令的方式自动为我们生成当前版本下的 sql 文件，而需要用到的也通过命令的形式运行 sql 文件。\n\n#### 数据生成\n\n你可以编写一个 [seed 脚本](https://www.prisma.io/docs/guides/database/seed-database#example-seed-scripts)，用于插种（生成）自定义数据。\n\n------\n\nprisma 不是本文重点，篇幅略少，但是作为 Typeorm 的长期使用者而言，我认为 prisma 会比 typeorm 友善一些，至少从文档上来说 prisma 大胜一筹，而且很多 node 的 web 框架都优先 prisma 作为 orm 框架（除了nest.js），但不过这两个仓库的 issues 数量有点惨不忍睹。。。\n\n### next-auth\n\n我想先简单介绍一下 next-auth（背后由[Auth.js](https://authjs.dev/ 'Auth.js') 提供）。\n\n从名字来看也不难猜出，这是一个 next.js 的 auth 库。该库提供了多种身份验证策略，如基于密码的身份验证，OAuth 等等。并且你只需要简单的几行代码，提供好相关信息便可启用身份验证和授权功能。\n\n你可以到这个网站 [NextAuth.js Example](https://next-auth-example.vercel.app/ 'NextAuth.js Example')体验一番。下面是一些代码演示\n\n由于 create-t3-app 默认是 Discord OAuth，因此我这边替换成使用者更多的 Github。（至于如何创建 Github OAuth Apps，在我之前的文章以及外面诸多文章中都有介绍到，这里不在演示了，附上配置图）\n\n![](https://img.kuizuo.cn/image__B1RYeiFze.png)\n\n首先在\n\nserver/auth.ts 中 导入\n\n```typescript title='server/auth.ts'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport GithubProvider from 'next-auth/providers/github'\n```\n\n并在 options 中设置好 providers，如下\n\n```typescript title='server/auth.ts'\nexport const authOptions: NextAuthOptions = {\n  callbacks: {\n    session({ session, user }) {\n      if (session.user) {\n        session.user.id = user.id\n        // session.user.role = user.role; <-- put other properties on the session here\n      }\n      return session\n    },\n  },\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        username: { label: 'Username', type: 'text', placeholder: 'kuizuo' },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials, req) {\n        // Add logic here to look up the user from the credentials supplied\n        const user = { id: '1', name: 'kuizuo', email: 'hi@kuizuo.cn' }\n\n        if (user) {\n          return user\n        } else {\n          return null\n        }\n      },\n    }),\n    GithubProvider({\n      clientId: env.GITHUB_CLIENT_ID,\n      clientSecret: env.GITHUB_CLIENT_SECRET,\n    }),\n  ],\n}\n```\n\n不过此时会提示 env 对象没有 GITHUB_CLIENT_ID 属性，需要在 env.mjs 定义好 GITHUB_CLIENT_ID 与 GITHUB_CLIENT_SECRET。类型安全嘛，你可不想 GITHUB 不小心输成 ~~GAYHUB~~ 导致找不到这个值把。\n\n当上述在设置完毕后，点击 Sign in 按钮便可跳转到 next-auth 所提供的简单登录表单。\n\n![](https://img.kuizuo.cn/image_9eowvvnwU2.png)\n\n如果你想自定义修改登录页面，可以参考该视频[Create your own next-auth Login Pages - YouTube](https://www.youtube.com/watch?v=kB6YNYZ63fw 'Create your own next-auth Login Pages - YouTube')\n\n## 部署 tRPC\n\n通常来说 tRPC 会配合全栈框架使用，因此可以非常轻松的部署在 Vercel，Netlify 上。如今 Vercel 应该也已经家喻户晓了，因此这里就不演示如何部署，可到 [Vercel • Create T3 App](https://create.t3.gg/en/deployment/vercel 'Vercel • Create T3 App') 中查看相关步骤。\n\n:::caution\n\n不过要注意，Vercel 并不提供文件读写操作，即无法实现数据存储，因此你如果需要提供数据读取的操作，那么普通需要一个远程的数据库服务，将 DATABASE_URL 环境变量替换成线上地址。如\n\n```\nDATABASE_URL=postgresql://myuser:mypassword@localhost:5432/mydb\n```\n\n这里推荐 [railway](https://railway.app/ 'railway') 与 [supabase](https://supabase.com/ 'supabase') 都提供远程数据服务，且有免费额度。（不过我比较好奇为啥好多远程数据服务多数都是postgresql）\n\n如果你执意要使用 vercel 部署，当你触发数据库服务时便会报错，以下是相关截图。\n\n![](https://img.kuizuo.cn/image_7_XKmbuK87.png)\n\n:::\n\n至于说自行部署的话，create t3 app 提供了 docker 相关镜像，你可以直接使用 docker 部署，具体步骤可参考 [Docker • Create T3 App](https://create.t3.gg/en/deployment/docker)。\n\n## 示例\n\n这里我提供了一个简单的示例，你可以 [点我](https://trpc.kuizuo.cn) 访问体验一下（项目部署在 Vercel，而数据库服务在腾讯云，登录服务又依赖 Github，所以项目会稍微有那么慢）。整个项目结构大致如下\n\n![](https://img.kuizuo.cn/image_z_YaR-RnSu.png)\n\n你可以在 [Example Apps | tRPC](https://trpc.io/docs/example-apps 'Example Apps | tRPC') 查看 trpc 的示例应用。\n\n## 结语\n\n如果你是用 Next，Nuxt 等这样的全栈框架，并且你的后端服务使用 Typescript 编写，不妨试试 trpc，你会惊喜地发现，它颠覆了传统的 API 交互，使你的 typescript 全栈应用程序的开发变得更加高效和流畅。\n\n从 JavaScript 到 TypeScript 的演变，全栈应用的端到端类型安全，TypeScript 目前正在逐渐成为前端开发中不可或缺的一部分，也许未来的某一天当人们说起前端三件套时，不再是 HTML，CSS，JavaScript，而是 HTML，CSS，TypeScript。\n\n再说到我为何会去尝试 tRPC，有很大的原因是因为厌倦了传统后端开发，厌倦了 nest.js 开发。然而现实生活中，你所厌倦的，往往是能为你提供收入的。人们总是做着自己不愿做的事，但生活所迫，谁又愿意呢。"
    },
    {
      "id": "use-supabase-as-backend-service",
      "metadata": {
        "permalink": "/use-supabase-as-backend-service",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/将 Supabase 作为下一个后端服务.md",
        "source": "@site/blog/program/将 Supabase 作为下一个后端服务.md",
        "title": "将 Supabase 作为下一个后端服务",
        "description": "本文介绍了如何使用 Supabase 作为后端服务，使开发人员可以更快地构建和部署应用程序，无需配置数据库或编写复杂的身份验证代码。将使用 Nuxt.js 和 Supabase，以实现一个图床网站为例，来演示如何在前端中使用 Supabase API 和 Storage 服务。",
        "date": "2023-02-18T00:00:00.000Z",
        "formattedDate": "2023年2月18日",
        "tags": [
          {
            "label": "supabase",
            "permalink": "/tags/supabase"
          },
          {
            "label": "nuxt",
            "permalink": "/tags/nuxt"
          },
          {
            "label": "project",
            "permalink": "/tags/project"
          }
        ],
        "readingTime": 9.54,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "use-supabase-as-backend-service",
          "title": "将 Supabase 作为下一个后端服务",
          "date": "2023-02-18T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "supabase",
            "nuxt",
            "project"
          ],
          "keywords": [
            "supabase",
            "nuxt",
            "project"
          ],
          "description": "本文介绍了如何使用 Supabase 作为后端服务，使开发人员可以更快地构建和部署应用程序，无需配置数据库或编写复杂的身份验证代码。将使用 Nuxt.js 和 Supabase，以实现一个图床网站为例，来演示如何在前端中使用 Supabase API 和 Storage 服务。",
          "toc_max_heading_level": 3
        },
        "prevItem": {
          "title": "Typescript 全栈最值得学习的技术栈 TRPC",
          "permalink": "/typescript-full-stack-technology-trpc"
        },
        "nextItem": {
          "title": "🍋 使用 Fresh 框架构建Web 应用",
          "permalink": "/use-fresh-build-web-applicatioin"
        }
      },
      "content": "![213727234-cda046d6-28c6-491a-b284-b86c5cede25d](https://img.kuizuo.cn/213727234-cda046d6-28c6-491a-b284-b86c5cede25d.png)\n\n对于想快速实现一个产品而言，如果使用传统开发，又要兼顾前端开发，同时又要花费时间构建后端服务。然而有这么一个平台（Baas Backend as a service）后端即服务，能够让开发人员可以专注于前端开发，而无需花费大量时间和精力来构建和维护后端基础设施。\n\n对于只会前端的人来说，这是一个非常好的选择。后端即服务的平台使得开发人员能够快速构建应用程序，更快地将其推向市场。当然了，你可以将你的后端应用接入 Baas，这样你就无需配置数据库，编写复杂的身份效验。\n\n如果你想了解 Baas，我想这篇文章或许对你有所帮助。\n\n<!-- truncate -->\n\n## 什么是 [Supabase](https://supabase.com/ 'Supabase')?\n\n在摘要部分也介绍到名词 BaaS (Backend as a Service) ，意思为**后端即服务**。这个概念是在我接触 Serverless 的时候了解到的，更准确来说是腾讯云开发。当时在编写小程序的时候，只需要专注与应用业务逻辑，而不用编写数据存储，身份验证，文件存储等后端服务，这些统统由 BaaS 平台所提供。 通常会配合 Serverless 函数使用，通常也叫 FaaS（Function as a Service）。通常来说，FaaS 会依赖于 BaaS 平台。\n\n而 Supabase 便是 BaaS 的平台之一。Supabase 是一个开源的 Firebase 替代品。使用 Postgres 数据库、身份验证、即时 API、边缘函数、实时订阅和存储启动项目。\n\n你也许听过 Firebase，由 Google 提供的私有云服务，但开发者无法修改和扩展其底层代码。而 Supabase 是开源的，提供了类似 Firebase 的功能，且定价灵活，并且官方自称为 [Firebase](https://link.juejin.cn/?target=https://firebase.google.com/ 'Firebase')的替代品。\n\n## BaaS 与 CMS 有何不同？\n\nBaaS 通常只专注于应用的后端服务，而 CMS 则是专注与内容管理。不过 BaaS 比较依赖云服务，而 CMS 通常只依赖于 web 后端技术。如果你想搭建一个内容站点（视频，音频，文章），并且作为网站管理员，那么 CMS 就是一个很好的选择，并且有相当多的主题模板。反之，不想搭建后端服务，减少运营程序，那么毫不犹豫的选择 BaaS。\n\n## 注册 Supabase\n\n进入 [supabase 登录界面](https://app.supabase.com/sign-in) 选择 Continue With Github\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_2yiQ9NHv21.png)\n\n输入 Github 账号密码进入[主页面](https://app.supabase.com/projects '主页面')，新建一个项目\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_0eoOyP8DM2.png)\n\n为该项目起名，设置数据库密码，以及分配地区。\n\n:::caution\n\n创建 supabase 项目对密码要求非常严格，像 a123456 这种根本无法通过，像 ●●●●●●●●●● 密码就可以。\n\n地区方面优先就近原则，而最近的也就是日本与韩国，很无奈 supabase 在大陆和港澳台并未设立服务器。\n\n:::\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_N5CQnx8cnU.png)\n\n等待片刻，你将拥有一个免费的后端服务！\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_Z33n9aUOC7.png)\n\nsupabase 会提供一个二级域名供开发者访问，也就是这里 Project Configuration 的 URL，对应的这个二级域名 azlbliyjwcxxxxx 也就是你这个项目的唯一标识 Reference ID（下文称 项目id）。你可以到 [https://app.supabase.com/project/你的项目id/settings/api](https://app.supabase.com/project/azlbliyjwcemojkwazto/settings/api 'https://app.supabase.com/project/你的项目id/settings/api') 中查看相关配置。\n\n## 体验一下\n\n这里参考到了官方文档 [Serverless APIs](https://supabase.com/docs/guides/database/api 'Serverless APIs')。\n\n首先，创建一个 todos 表，并新增字段（列）task 为 varchar 类型，Save 保存。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_Do9LHoUsYo.png)\n\nInsert row 添加一行记录，id 为 1，task 为 code。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_R9PEyH-spd.png)\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_MLm6_i1Pb-.png)\n\n现在有了数据后，正常来说我们应该做什么？请求一下数据看看？不不不，应该是设置数据的权限。\n\n打开到下图界面，我们要为 todos 数据新增一个 policy 策略。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_MEKk1-qQFl.png)\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_W-C-pGNh1o.png)\n\nsupabase 针对不同的场景提供了相应的策略方案模板，你也可以根据你的需求进行设置，这里作为演示不考虑太复杂，选择第一个允许任何人都可以请求到 todos 数据。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_Oa_424N4gz.png)\n\n接着下一步即可\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_wV_MqXQXcK.png)\n\n此时就新增了一个所有用户都可查询的 todo 的策略，同样的你还可以添加只有授权用户才能够创建更新删除 todo，更新与删除只能操作属于自己的 todo 资源。\n\n这时候设置好了数据的权限后，就可以尝试去请求了，打开下图页面，将 URL 与 apikey 复制下来。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_GDEeyFCI2E.png)\n\n选择你一个 http 请求工具，这里我选用 [hoppscotch](https://hoppscotch.io/ 'hoppscotch')，将信息填写上去，请求将会得到一开始所创建的 todo 数据。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_aSbRfmlwb9.png)\n\n除了 restful api 风格，还支持 graphql 风格，可查阅文档 [Using the API](https://supabase.com/docs/guides/database/api#using-the-api 'Using the API')\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_R0HtkYmznS.png)\n\n### 使用类库\n\n正常情况肯定不会像上面那样去使用，而是通过代码的方式进行登录，CRUD。这里使用 [Javascript Client Library](https://supabase.com/docs/reference/javascript/installing 'Javascript Client Library')，替我们封装好了 supabase 的功能。\n\n首先，安装依赖\n\n```bash\nnpm install @supabase/supabase-js\n```\n\n创建 客户端实例 \n\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n```\n\n此时准备好上述的URL与apikey，用于创建supabase实例，不过supabase还提供 [type类型支持](https://supabase.com/docs/reference/javascript/typescript-support)，可以将生成的 `database.types.ts` 导入到实例中，如\n\n```typescript\nimport { createClient } from '@supabase/supabase-js'\nimport { Database } from 'lib/database.types'\n\nconst supabase = createClient<Database>(\n  process.env.SUPABASE_URL,\n  process.env.SUPABASE_ANON_KEY\n)\n```\n\n此时有了supabse对象后，就能够请求数据了，像上述通过 http 的方式获取 todos 数据，在这里对应的代码为\n\n```typescript\nconst { data, error } = await supabase\n  .from('todos')\n  .select()\n```\n\n[官方的演示例子](https://supabase.com/docs/reference/javascript/select) 非常清晰，这里就不在演示新增更新等示例。\n\n![image-20230218182910913](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image-20230218182910913.png)\n\n## [Supabase 主要功能](https://supabase.com/docs)\n\n### Database 数据库\n\nsupabase 基于 PostgreSQL 数据库，因此当你创建完项目后，就自动为你分配好了一个可访问的 PostgreSQL 数据库，你完全可以将其当做一个远程的 PostgreSQL 数据主机。\n\n可以在如下页面中查看到有关数据库连接的信息，当然你看不到密码。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_6uCHh3qrlE.png)\n\n测试连接，结果如下，并无问题\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_8-JOTiLI0G.png)\n\n### Authentication 身份验证\n\n[Auth | Supabase Docs](https://supabase.com/docs/guides/auth/overview 'Auth | Supabase Docs')\n\nsupabase 令我感兴趣的是 [Row Level Security](https://supabase.com/docs/learn/auth-deep-dive/auth-row-level-security 'Row Level Security')，supabase 使用 Postgres 的 Row-Level-Security（行级安全）策略，可以限制不同用户对同一张表的不同数据行的访问权限。这种安全机制可以确保只有授权用户才能访问其所需要的数据行，保护敏感数据免受未授权的访问和操作。\n\n在传统的访问控制模型中，用户通常只有对整个表的访问权限，无法限制他们对表中特定数据行的访问。而行级安全技术则通过将访问权限授予到特定的数据行，从而让不同的用户只能访问他们被授权的行。这种行级安全有一个很经典应用场景-多租户系统：允许不同的客户在同一张表中存储数据，但每个客户只能访问其自己的数据行。\n\n这对于传统后端开发而言，如果不借用一些安全框架，实现起来十分棘手，要么业务代码与安全代码逻辑混杂不堪。\n\n权限细分方面，无需担心，supabase 已经为你做好了准备，就等你来进行开发。\n\n#### 第三方登录\n\n对于想要提供第三方登录，supabse 集成多数平台（除了国内），只需要提供 Clinet ID, Client Secret, Redirect URL 便可完成第三方登录。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_OvBRJ_elZR.png)\n\n这里演示下如何使用 Github，首先到打开[New OAuth Application (github.com)](https://github.com/settings/applications/new 'New OAuth Application (github.com)') 创建一个 Oauth Apps，其中 Authorization callback URL 由 supabase 提供，如下图。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_QVspy-oxQK.png)\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_jyaUMSDed2.png)\n\n当你创建完后，会提供 Client ID，与 Client secret，将这两个值填写到 supabase 中，并启用。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_QpRRxpR5o5.png)\n\n此时打开如下页面，将 Site URL 替换成开发环境，或是线上环境，在 Github 登录后将会跳转到这个地址上\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_zmfXC85ayC.png)\n\n此时 supabase 支持 github 登录就已经配置完毕，当你在前端触发登录按钮后，借助[supabase 的 js 库](https://supabase.com/docs/reference/javascript/auth-signinwithoauth 'supabase 的js库')，如\n\n```typescript\nconst {data, error} = await supabase.auth.signInWithOAuth({\n  provider: 'github',\n});\n```\n\n便可完成 Github 第三方登录。\n\n### Bucket 存储桶\n\n接触过对象存储的开发者对 Bucket 应该不陌生，相当于给你一个云盘，这里演示如何使用。\n\n打开如下界面，这里选择公开存储桶，比如说用于图床。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_2Is4Bfwf8f.png)\n\n点击右上角的 upload files，选择你要上传的图片。你可以为此生成一个访问 URL\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_vkuzeZZVJ_.png)\n\n你可以访问 [1.png](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/publilc/1.png) 来查看这张图片。如果是公开的话 一般都是类似https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/new-bucket/1.png\n\n而私有的为 https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/sign/new-bucket/1.png?token=eyJhbGciOiJIUzI1NiIsInR5cCIxxxxxxxxxxxxxxxxx 路径稍微变化了下，还有就是多了个 token，如果不携带 token 则访问不了图片。\n\n你可以到[Supabase Storage API](https://supabase.github.io/storage-api/ 'Supabase Storage API') 查看 storage 相关 api。\n\n:::tip 现学现用\n\n本文中的所有图片数据都来源于 supabase bucket。\n\n:::\n\n### Edge Functions 边缘函数\n\n边缘函数可以分布在全球的接近您的用户各个地方，类似与 CDN，但 CDN 主要服务于静态资源，而 Edge Functions 可以将你的后端应用接口，像 CDN 那样部署到全球各地。\n\n有兴趣可自行了解。\n\n## **使用 Supabase 编写一个简易图床**\n\n如果只单纯看看 supabase 文档，不去动手实践接入一下，总觉得还是差点意思。于是我准备使用 Nuxt 作为前端框架接入 supabase，官方模块 [Nuxt Supabase](https://supabase.nuxtjs.org/ 'Nuxt Supabase') 去编写一个应用。\n\n原本我是打算写个 Todo List 的（恼，怎么又是 Todo List），但是看到 [官方示例](https://supabase.com/docs/guides/resources/examples#official-examples '官方示例')（一堆 Todo List）后我瞬间就没了兴致 🥀。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_1polvJf0q0.png)\n\n思来想去，不妨就简单做个图床吧。项目地址：[https://image.kuizuo.cn](https://image.kuizuo.cn) 有兴趣可自行阅读[源码](https://github.com/kuizuo/image-hosting)。（**写的相对匆忙，仅作为演示，随时有可能删除，请勿将此站作为永久图床！**）\n\n## 一些你可能比较好奇的问题\n\n### 资源\n\n可以到 https://app.supabase.com/project/项目id/settings/billing/usage 中查看相关资源使用情况，这里我就将截图放出来了。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_Bllhp6XlFz.png)\n\n说实话，对于个人独立开发者的项目都绰绰有余了。\n\n### 费用\n\n在 [资费标准](https://supabase.com/pricing '资费标准') 中可以看到，免费版**最多 2 个项目**，不过在上述的资源，其实已经非常香了，毕竟只需要一个 GIthub 账号就能免费使用，还要啥自行车。\n\n![](https://azlbliyjwcemojkwazto.supabase.co/storage/v1/object/public/public/image_MNtdzsdJ2t.png)\n\n### 网速\n\n国内因为没有 supabase 的服务器节点，然后且有防火墙的存在，所以请求速度偏慢。不过体验下来至少不用梯子，速度慢点但也还在可接受范围。\n\n### 域名\n\n用过 vercel 的你应该会想是不是也能自定义域名呢? 当然，不过这是 supabase pro 版才支持，一个月$25(美刀)，算了算了，再一眼 azlbliyjwcxxxxx.supabase.co~~就会爆炸~~感觉也蛮好记的。\n\n## 结语\n\n说句实话，真心感觉 supabase 不错，尤其是对个人/独立开发者而言，没必要自行去购买服务器，去搭建后端服务，很多时候我们只想专注于应用程序的开发和功能实现，而不是花费大量时间和精力在服务器和后端服务的部署和管理上。"
    },
    {
      "id": "use-fresh-build-web-applicatioin",
      "metadata": {
        "permalink": "/use-fresh-build-web-applicatioin",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/使用 Fresh 框架构建 Web 应用.md",
        "source": "@site/blog/program/使用 Fresh 框架构建 Web 应用.md",
        "title": "🍋 使用 Fresh 框架构建Web 应用",
        "description": "使用 Fresh 框架构建Web 应用，用于将链接转换为卡片样式的预览效果图。",
        "date": "2023-02-15T00:00:00.000Z",
        "formattedDate": "2023年2月15日",
        "tags": [
          {
            "label": "deno",
            "permalink": "/tags/deno"
          },
          {
            "label": "fresh",
            "permalink": "/tags/fresh"
          },
          {
            "label": "web",
            "permalink": "/tags/web"
          },
          {
            "label": "project",
            "permalink": "/tags/project"
          }
        ],
        "readingTime": 9.496666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "use-fresh-build-web-applicatioin",
          "title": "🍋 使用 Fresh 框架构建Web 应用",
          "date": "2023-02-15T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "deno",
            "fresh",
            "web",
            "project"
          ],
          "keywords": [
            "deno",
            "fresh",
            "web",
            "project"
          ],
          "description": "使用 Fresh 框架构建Web 应用，用于将链接转换为卡片样式的预览效果图。"
        },
        "prevItem": {
          "title": "将 Supabase 作为下一个后端服务",
          "permalink": "/use-supabase-as-backend-service"
        },
        "nextItem": {
          "title": "Deno不只是个Javascript运行时",
          "permalink": "/deno-is-not-only-a-javascript-runtime"
        }
      },
      "content": "![](https://img.kuizuo.cn/link-maker.png)\n\n这篇文章将使用 deno 的 web 框架 Fresh，一个简单的 Web 应用 [Link Maker](https://link-maker.deno.dev/ 'Link Maker')，一个用于将链接转换成卡片样式的预览效果。\n\n这个项目也放在了 fresh 的 [Showcase](https://fresh.deno.dev/showcase 'Showcase')，感兴趣的可以查看一番。\n\n<!-- truncate -->\n\n## 什么是 fresh？\n\n[fresh](https://fresh.deno.dev/) 自称是下一代 web 开发框架（这句话怎么这么熟悉?），是一个基于 Deno 的 Web 框架。它提供了许多用于构建 Web 应用程序和 API 的工具和功能。Fresh 框架特别强调简单性和灵活性，并着重于提供最佳的性能和开发体验。它支持 TypeScript，并且不需要任何配置或构建步骤。这些特性使得 Fresh 框架成为构建高效和现代 Web 应用程序的理想选择。\n\n:::caution 声明\n\nFresh 的前端渲染层由 Preact 完成，包括 Islands 架构的实现也是基于 Preact。如果你想在 Fresh 中使用其他主流前端框架，目前来说有点无能为力。\n\n:::\n\n## 创建 fresh 项目\n\n[Create a project | fresh docs](https://fresh.deno.dev/docs/getting-started/create-a-project 'Create a project | fresh docs')\n\ndeno 提供了非常友好的创建 fresh 项目的命令，运行:\n\n```shell\ndeno run -A -r https://fresh.deno.dev my-project\ncd my-project\ndeno task start\n```\n\n根据你的喜好进行配置，如下\n\n![](https://img.kuizuo.cn/image_jSRfPu966v.png)\n\n此时会创建如下文件\n\n```bash\nmy-project\n├── components        # 组件\n│   └── Button.tsx    # 按钮组件\n├── deno.json         # deno配置文件\n├── dev.ts            #\n├── fresh.gen.ts      #\n├── import_map.json   # 依赖导入映射\n├── islands           # 群岛(组件群岛)\n│   └── Counter.tsx\n├── main.ts           # 入口文件\n├── routes            # 路由\n│   ├── [name].tsx\n│   ├── api\n│   │   └── joke.ts\n│   └── index.tsx\n├── static            # 静态资源\n│   ├── favicon.ico\n│   └── logo.svg\n└── twind.config.ts   # twind配置文件\n```\n\n介绍几个文件：\n\n- **`dev.ts`**: 项目开发模式的匹配文件，假设你需要区分生产环境和开发环境，就可以通过 dev.ts，prod.ts 命令来指明入口\n- **`main.ts`**: 入口文件，会用于链接 [Deno Deploy](https://deno.com/deploy)。\n- **`fresh.gen.ts`**: 这个清单文件会基于`routes/` 和 `islands/` 文件夹自动生成。包含项目的 route 和 island 信息。\n- **`import_map.json`**: 这是用于管理项目的依赖项的导入映射。这允许轻松地导入和更新依赖项。\n\n其中最主要的两个目录，这里会细说。\n\n### routes\n\n**`routes/`**: 存放项目中的所有路由。文件即路由，每个文件的名称对应于访问该页的路径。注：此文件夹中的代码永远不会直接发送到客户端.\n\n其中 routes/api 通常存放一些 api 接口，这这里你完全可以将其当做一个 deno 的服务端，可以做后端能做的事情，通常来说就是提供一个可请求的 api 接口。\n\n而其他文件就相当于一个可访问的页面组件，同样是文件路由系统，也可以在这里进行 SSR、中间件操作。\n\n### islands\n\n**`Islands/`**: 群岛，Fresh中我并未看到对这一词的解释，你可以到 [astro 群岛](https://docs.astro.build/zh-cn/concepts/islands/) 看看新的 Web 架构模式，主要作用就是用于存放交互式组件（服务端组件），可以在客户端和服务端运行。有点类似与 next.js 的服务端组件，同样有两种状态（服务端，浏览器端）。\n\n这一部分会有点难理解，你只要知道 IsLands 存放的组件有两种状态（服务端，浏览器端），下文称服务端组件，不同于 components 下的组件，服务端组件有一些优势，例如说\n\n- 可以直接访问服务端相关资源\n- 避免了不必要的客户端和服务端之间的交互，因此性能更快\n- 允许一些类库可以直接运行在服务端，因此减小了客户端包文件的大小\n\n**想要真正理解服务端组件，就不得不将其与 SSR 拿来对比了。**\n\nSSR 通常是将数据通过服务端的前端框架渲染成 HTML，直接将 HTML 返回给客户端就可以省去 xhr/fetch 请求的过程，只需要首次请求就能得到数据。此时页面交互，数据更新与传统的前端应用没有任何区别，**通俗点说 SSR 就是省去 xhr/fetch 请求的过程**。\n\n而服务端组件会在服务端完成渲染，然后通过自定义的协议发送到客户端。前端应用会将新的 UI 整体（服务端组件）的合并到客户端 UI 树里面（也有叫 hydration 水合），此过程不会对客户端其他状态产生影响，还能达到保持客户端状态的目的，极大的增强了用户体验。\n\n如果你仔细查看控制面板的网络请求输出，可以看到服务器端组件是可以请求的。（这里用的后面实战的截图作为展示）\n\n![](https://img.kuizuo.cn/image_v73eXB47yI.png)\n\n不过既然服务端组件也有很多限制，就比如说服务端状态下，是无法使用 Web 相关 Api 的，数据传输（通过 props）是有前提的，要 JSON 可序列化，也就是说只能传递基本类型、基本对象、数组，像 Date，自定义类，函数等复制对象是无法传递的。\n\n## 实战\n\n项目还是相对比较简单的，将链接转化为一个卡片样式的预览效果（包含链接的标题，图片，描述）。\n\n核心代码在 [`routes\\api\\link.ts`](https://github.com/kuizuo/link-maker/blob/main/routes/api/link.ts) 下，将会生成 `/api/link` 接口，例如访问 [https://link-maker.deno.dev/api/link?q=https://kuizuo.cn](https://link-maker.deno.dev/api/link?q=https://kuizuo.cn 'https://link-maker.deno.dev/api/link?q=https://kuizuo.cn') 你就可以得到如下 json 数据\n\n```json\n{\n  \"title\": \"愧怍的小站\",\n  \"description\": \"Blog\",\n  \"image\": \"https://kuizuo.cn/img/logo.png\",\n  \"url\": \"https://kuizuo.cn\"\n}\n```\n\n原理就是通过 fetch 请求目标 url，通常来说得到的是一个 html 页面，这时使用 [deno-dom](https://deno.land/x/deno_dom@v0.1.36-alpha/deno-dom-wasm.ts 'deno-dom') 解析成 Dom 对象，通过 css 选择器选取所要的数据，并整合返回给调用方。\n\n有了这个接口，剩下的前端工作就相对比较轻松了，主要也就是细节话的问题。\n\n## 坑点/不足\n\n下面我会说说,在我编写该应用的时候，有哪些开发体验上的不足之处，如果你恰好有使用 Fresh 框架编写 Web 应用的话，最好需要注意下。\n\n### vscode 下对 deno 项目重构并不友好\n\n当我移动项目 .ts/.tsx 文件的时候，vscode 会将该文件与其他引用该文件的路径更改为 .js/.jsx，这就比较蛋疼了，所以每当要移动文件的时候都要尤为小心。\n\n还有就是文件的依赖关系不是那么准确，尤其是在首次进入项目工程的时候，比如说在 routes/test.tsx 中 导入了 `components/Button.tsx` 组件，当你在 tsx 中写了`<Button></Button>` ，vscode 并不会有任何的引入提示，当你打开 `components/Button.tsx` 文件后就又有了，搞得我都怀疑是不是没有该组件。\n\n### 无法直接通过上下文获取 query 参数\n\nfresh 的 handler 提供两个参数，一般来都会写成下面这种形式，可以区分 Get，Post 请求\n\n```typescript\nexport const handler = {\n  async GET(req: Request, ctx: HandlerContext): Promise<Response> {},\n  async POST(req: Request, ctx: HandlerContext): Promise<Response> {},\n};\n```\n\n假设当前的请求是 /api/test?q=123，我想要获取 query 参数的 q，我得这么做\n\n```typescript\nconst url = new URL(req.url);\nconst q = url.searchParams.get('q');\n```\n\n当时我尝试用 ctx.query 和 req.query 来获取 q 参数，然而 ctx 与 req 并没有 query 属性，在翻阅文档与源码，才得知 fresh 并没有将 query 参数解析到 req 或 ctx 下。\n\n至于说为何要用 query 而不是用 param，主要是因为 url 的缘故，比如说 `/api/link/https://kuizuo.cn` 这个链接，这时 param 是解析不出 `https://kuizuo.cn` 完整 url 的，除非url编码，但这对使用者来说就不是很好，于是就舍弃了 param 参数的方案。\n\n### 有些 npm 包在 fresh 无法正常使用\n\n在这个应用中我所使用到了 [html2canvas](https://www.npmjs.com/package/html2canvas 'html2canvas') 库用于将页面的 div 元素转成 canvas，以便转成图片的形式并下载。然后在我导入的时候，要么提示找不到该包（大概率是因为 Commonjs），要么就是 html2canvas 不存在，最终无奈我只好将 html2canvas.min.js 存放在 static 下，并在页面中通过 `<script src=\"/js/html2canvas.min.js\"></script>` 方式导入，这样全局有了 html2canvas 就可使用。\n\n### islands 下的组件要时刻注意 Web Api 调用\n\n我在 islands 下的组件中用到了 localStorage 用于持久化数据，然而在我尝试部署到服务器上的时候发现网站无法访问，并在错误日志中提示 localStorage is not defined。\n\n其实这在很多 hydration 框架中都有这一个问题，在 islands 下的组件有两种状态（浏览器端，服务端），后文就称为客户端组件和服务端组件。也正是如此，服务端组件是没有客户端的运行时环境，就比如说你想要在组件中使用 localStorage 对象用来持久化数据，在两种状态下，首先会在服务端执行一遍，然而服务端并没有 localStorage 对象，此时就会提示 localStorage is not defined。\n\n通常的做法是判断组件当前的状态，可以用如下方式来判断是否为浏览器环境。\n\n```typescript\nimport {IS_BROWSER} from '$fresh/runtime.ts';\n```\n\n然后将 localStorage等 Web 相关 API 的调用放在 IS_BROWSER 的判断中。\n\n\n有篇相关文件非常值得阅读，或许对组件的 hydration 有更好的理解\n\n[💧 Hydration and Server-side Rendering – somewhat abstract](https://blog.somewhatabstract.com/2020/03/16/hydration-and-server-side-rendering/ '💧 Hydration and Server-side Rendering – somewhat abstract')\n\n## 前端框架比较局限\n\n在前面也说过，Fresh 的前端渲染层由 Preact 完成。如果用户要用 React/Vue 那为何不选择生态更好的 next.js/nuxt.js 呢？所以目前来看，Fresh 还是有些无能为力。但可以肯定的是，fresh 的方向与 next.js/nuxt.js 的一致。\n\n## 部署\n\n[deno Deploy](https://dash.deno.com/ 'deno Deploy') 可以非常轻松的部署 fresh 应用，使用 Github 账号登录后，[New Project](https://dash.deno.com/new 'New Project')，从 github 仓库中拉取项目点击 Link 即可部署完毕。\n\n![](https://img.kuizuo.cn/image_CYOAgv6IGe.png)\n\n这里的项目名为 link-maker，那么就会生成 专属访问链接 [https://link-maker.deno.dev](https://link-maker.deno.dev/ 'https://link-maker.deno.dev')（也许要梯子才能访问）\n\n## 结语\n\n最后，在我编写完该应用后，我对其做一个评价吧。收回一开始的一句话，~~fresh 自称是下一代 web 开发框架~~。\n\n如果要让我在 next.js 和 fresh 两个相似的产品中做个选择的话，我肯定毫不犹豫的选择 next.js。一个以一己之力推动了前端的发展，到至今已有越来越多的项目使用 next.js ，我想作为任何一个前端学习者肯定会毫不犹豫的选择 next.js 去编写 web 应用。\n\n就从用户的开发体验而言，就已经很难让我再次选择 fresh，更何况还有像 next.js/nuxt.js 这样的全栈框架。作为一个开发体验（Developer experience）优先的程序员角度来看，如果一个框架想要让别人广泛使用，一定要满足其开发过程，只有沉浸于此，才能不断思考，编写出高质量代码。即便无负担的配置，高性能编译，轻便的部署，这些在他人看来可选择的点（也是 fresh 的点），在我看来却显得很微不足道。\n\n而为什么我会选择尝试 fresh，其实也就想看看能不能找到一个令我眼前一亮的一个全栈 Web 框架，然而目前来看，fresh 还有很长一段距离。"
    },
    {
      "id": "deno-is-not-only-a-javascript-runtime",
      "metadata": {
        "permalink": "/deno-is-not-only-a-javascript-runtime",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Deno不只是个Javascript运行时.md",
        "source": "@site/blog/program/Deno不只是个Javascript运行时.md",
        "title": "Deno不只是个Javascript运行时",
        "description": "Deno 是一个安全的 JavaScript 和 TypeScript 运行时，作者是 Ryan Dahl（也是 Node.js 的原作者）。Deno 的诞生之初是为了解决 2009 年首次设计 Node.js 时的一些疏忽。我认为这种改造动机很有道理，因为我相信每个程序员都希望有机会能重写他们已有 10 年历史的代码。",
        "date": "2023-01-20T00:00:00.000Z",
        "formattedDate": "2023年1月20日",
        "tags": [
          {
            "label": "deno",
            "permalink": "/tags/deno"
          },
          {
            "label": "node",
            "permalink": "/tags/node"
          },
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "typescript",
            "permalink": "/tags/typescript"
          }
        ],
        "readingTime": 14.07,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "deno-is-not-only-a-javascript-runtime",
          "title": "Deno不只是个Javascript运行时",
          "date": "2023-01-20T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "deno",
            "node",
            "javascript",
            "typescript"
          ],
          "keywords": [
            "deno",
            "node",
            "javascript",
            "typescript"
          ]
        },
        "prevItem": {
          "title": "🍋 使用 Fresh 框架构建Web 应用",
          "permalink": "/use-fresh-build-web-applicatioin"
        },
        "nextItem": {
          "title": "Rust实现MD5加密并打包成WebAssembly调用",
          "permalink": "/rust-wasm-md5"
        }
      },
      "content": "<img src=\"https://deno.land/logo.svg\" width=\"150\" height=\"150\" />\n\nDeno 是一个安全的 JavaScript 和 TypeScript 运行时，作者是 Ryan Dahl（也是 Node.js 的原作者）。Deno 的诞生之初是为了[解决 2009 年首次设计 Node.js 时的一些疏忽](https://link.juejin.cn?target=https://www.youtube.com/watch?v=M3BM9TB-8yA)。我认为这种改造动机很有道理，因为**我相信每个程序员都希望有机会能重写他们已有 10 年历史的代码。**\n\ndeno 刚出的时候就听闻了，传言 deno 是下一代 node.js。不过如今看来，还革不了 node.js 的命。如果要说两者字面上的区别，Deno 的来源是 Node 的字母重新组合（Node = no + de），表示\"拆除 Node.js\"（de = destroy, no = Node.js）。\n\n趁着假期学了一段时间的 deno（指[文档](https://deno.land/manual@v1.29.3/introduction '文档')刷了一遍），想分享本人作为 node 开发者在学习 deno 时认为的一些亮点，以及个人对 deno 与 node 见解。\n\n<!-- truncate -->\n\n### 开发环境\n\n[Installation | Manual | Deno](https://deno.land/manual@v1.29.2/getting_started/installation 'Installation | Manual | Deno')\n\n默认情况下 deno 会根据不同的系统，选择相应的安装目录，以及依赖目录，你可以[配置环境变量](https://deno.land/manual@v1.29.3/getting_started/setup_your_environment#environment-variables '配置环境变量')来改变 deno 的默认行为。\n\n这里我选用 vscode 进行开发，安装[deno 官方插件](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno 'deno官方插件')。此时创建一个项目工程文件夹，打开 vscode，并创建 `.vscode/settings.json` 内容如下\n\n```json title='.vscode/settings.json'\n{\n  \"deno.enable\": true,\n  \"deno.lint\": true,\n  \"editor.formatOnSave\": true,\n  \"[typescript]\": {\"editor.defaultFormatter\": \"denoland.vscode-deno\"}\n}\n```\n\n在 vscode 中默认会将 ts 代码认为是 node 运行时环境，因此需要在项目工程下手动配置并启用 deno，让 vscode 以 deno 运行时环境来语法解析 ts 代码。\n\n## deno 的一些亮点💡\n\n因为 deno 与 node 一样，都是 javascript 运行时（deno 合理来说是 typescript 运行时）。所以在 javascript 的部分就没什么好说的了，主要对比 deno 相比与 node 的优势，或说我个人觉得一些使用亮点。\n\n### 官方所介绍的亮点\n\n以下是官方所介绍的[亮点](https://deno.land/manual@v1.29.3/introduction#feature-highlights '亮点')，我对其做了翻译\n\n- 提供[web 平台功能](https://deno.land/manual@v1.29.3/runtime/web_platform_apis 'web平台功能')，采用网络平台标准。例如，使用 ES 模块、Web worker 和支持 `fetch()`。\n- 默认安全。除非显式启用，否则无法访问文件、网络或环境。\n\n- 支持开箱即用的 [TypeScript](https://deno.land/manual@v1.29.3/advanced/typescript 'TypeScript')。\n- 提供单个可执行文件 （`deno`）。\n- 为编辑器提供内置的开发工具，如代码格式化程序 （[deno fmt](https://deno.land/manual@v1.29.3/tools/formatter 'deno fmt')）、linter （[deno lint](https://deno.land/manual@v1.29.3/tools/linter 'deno lint')）、测试运行程序（[deno test](https://deno.land/manual@v1.29.3/basics/testing 'deno test')）和[语言服务器](https://deno.land/manual@v1.29.3/getting_started/setup_your_environment.md#using-an-editoride '语言服务器')。\n- 拥有[一组经过审查（审核）的标准模块](https://deno.land/std@0.172.0 '一组经过审查（审核）的标准模块')，保证与 Deno 一起使用。\n- 可以将脚本[捆绑](https://deno.land/manual@v1.29.3/tools/bundler '捆绑')到单个 JavaScript 文件或[可执行文件](https://deno.land/manual@v1.29.3/tools/compiler '可执行文件')中。\n- 支持使用现有的 npm 模块\n\n以下会针对部分亮点，进行个人的见解。\n\n### 自带实用工具\n\ndeno 则是自带代码格式化（`deno fmt`）、代码风格（`deno lint`）、代码测试（`deno test`）、依赖检查器（`deno info`）等等的功能。而这些在 node 中，你需要通过第三方的库，如 eslint，jest 才能实现。\n\n你可以在项目工程中添加配置文件 [deno.json](https://deno.land/manual@v1.29.2/getting_started/configuration_file 'deno.json')来定制化代码风格（rust 中也有类似的功能），但在 node 中必须要借助第三方的库，或是 IDE 才能实现。\n\n不过也能理解，在当时的编程环境背景下，javascript 还主要作为前端的脚本语言使用，又怎能让 node 来做相关规范呢？（这句话可能有点不妥）\n\n**这点我认为对开发者是否选用你这门语言的一个加分项**，并且这些功能也应该作为编程语言所自带的，有官方的背书（保证），对代码风格才更有所保障。\n\n这里有份 [官方小抄](https://deno.land/manual@v1.29.4/references/cheatsheet#nodejs---deno-cheatsheet '官方小抄') 可以知道通过`deno xxx`等命令能够做到 node 原本需要通过第三方库才能实现的功能。\n\n| Node.js | Deno |\n| --- | --- |\n| `node file.js` | `deno run file.js` |\n| `ts-node file.ts` | `deno run file.ts` |\n| `npm i -g` | `deno install` |\n| `npm i` / `npm install` | _n/a_ |\n| `npm run` | `deno task` |\n| `eslint` | `deno lint` |\n| `prettier` | `deno fmt` |\n| `rollup` / `webpack` / etc | `deno bundle` |\n| `package.json` | `deno.json` / `deno.jsonc` / `import_map.json` |\n| `tsc` | `deno check` |\n| `typedoc` | `deno doc` |\n| `jest` / `ava` / `mocha` / `tap` / etc | `deno test` |\n| `nodemon` | `deno run/lint/test --watch` |\n| `nexe` / `pkg` | `deno compile` |\n| `npm explain` | `deno info` |\n| `nvm` / `n` / `fnm` | `deno upgrade` |\n| `tsserver` | `deno lsp` |\n| `nyc` / `c8` / `istanbul` | `deno coverage` |\n| `benchmarks` | `deno bench` |\n\n### [远程导入](https://deno.land/manual@v1.29.3/basics/modules#remote-import '远程导入')\n\n与 node 不同，使用 node 通常需要从 npm 官方包来下载并导，有 npm 这样的包管理器来统一管理这些包（package），我们通常称这种为中心化，而 deno 与 go 的做法很像，你可以将你的封装好的代码定义成一个包，并将其放在任何网络可访问的地方，比如 github，或是私有地址，然后通过网络读取文件的方式来导入，这种称为去中心化。\n\n:::tip\n\nnode 也不一定要用 npm 来下载模块，也可以本地模块或者私有模块。\n\n:::\n\n关于中心化与去中心化管理，各有优缺，这里不做细致讨论。\n\n以下是 deno 官方远程导入的代码示例：\n\n**Command: deno run ./remote.ts**\n\n```typescript title='remote.ts'\nimport {add, multiply} from 'https://x.nest.land/ramda@0.27.0/source/index.js';\n\nfunction totalCost(outbound: number, inbound: number, tax: number): number {\n  return multiply(add(outbound, inbound), tax);\n}\n\nconsole.log(totalCost(19, 31, 1.2));\nconsole.log(totalCost(45, 27, 1.15));\n\n/**\n * Output\n *\n * 60\n * 82.8\n */\n```\n\n而这里的 `https://x.nest.land/ramda@0.27.0/source/index.js` 可以替换成任何 ES module 特性（import/export）的模块。\n\n### http 的方式运行代码\n\n既然都能通过 http（cdn）远程导入模块，那远程运行文件自然也不成大问题。有时候像快捷体验一下别人的代码，或是想要在浏览器中运行一下代码，这时候就可以通过 http 的方式来运行代码。\n\n这里我准备了一段代码，并部署到我的站点上，你可以通过如下命令得到该代码的执行结果（如果你有安装 deno 的话），放心这段代码并无危害，就是一段简单的 console.log 输出。\n\n```powershell\ndeno run https://deno.kuizuo.cn/main.ts\n```\n\n在第一次使用时下载并缓存代码，你可以通过\n\n```powershell\ndeno info http://deno.kuizuo.cn/main.ts\n```\n\n来查看文件信息，如下\n\n![](https://img.kuizuo.cn/image_deb0_lGYRA.png)\n\ndeno info 还可以查看 deno 的相关配置，默认缓存都设置在 C 盘，你也可以设置**DENO_DIR** 环境变量来更改 deno 目录，可以到 [Set Up Your Environment](https://deno.land/manual@v1.29.3/getting_started/setup_your_environment#environment-variables 'Set Up Your Environment') 查看 deno 相关环境变量。\n\n### 依赖管理\n\n经常使用 node 的开发者应该对 node 的依赖感到无比厌烦，关于这部分强烈建议看 [node_modules 困境](https://juejin.cn/post/6914508615969669127)，你就能知道 node 的 node_modules 设计的是有多少问题。看完你也就能知道为啥越来越多的 node 项目都使用 [pnpm](https://pnpm.io) 作为包管理。\n\n虽然 node 有了 pnpm 包管理器这种情况会好一些，但本质在项目目录还是需要 node_modules 文件。也许你用过其他语言的包管理器，你会发现基本都是将所有用到的依赖全局缓存起来，当不同的项目工程需要用到依赖时，直接去全局缓存中找，而不是像 npm 一样，下载到项目工程目录下，存放在 node_modules 里。\n\n而 deno 也是采用这种这种方式，`no npm install`，`no package.json`，`no node_modules/` ，[使用 npm 包](https://deno.land/manual@v1.29.3/node/npm_specifiers#using-npm-packages-with-npm-specifiers '使用npm包')可以像下面这样，当你使用 deno run 时便会下载好依赖置全局缓存中。\n\n```typescript title=\"app.ts\" {2}\n// @deno-types=\"npm:@types/express@^4.17\"\nimport express from 'npm:express@^4.17';\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\napp.listen(3000);\nconsole.log('listening on http://localhost:3000/');\n```\n\ndeno 刚发布的时候，甚至还不支持 NPM 软件包，这无非是要告诉用户 deno 社区没有轮子，要求用户自己去造一个。不过 deno 团队还是做出了比较正确的选择，支持 npm 软件包，并且还非常友好。\n\n不过如果你在 deno 中使用了 npm 包，可能会存在一些兼容性问题，万一遇到了，也可以通过添加 `--node-modules-dir` 标识，在当前运行目录下创建 `node_modules` 文件夹。详见 [--node-modules-dir flag](https://deno.land/manual@v1.29.4/node/npm_specifiers#--node-modules-dir-flag '--node-modules-dir flag')\n\n### 安全\n\n[Permissions](https://deno.land/manual@v1.29.4/basics/permissions 'Permissions')\n\n在 2022 年 npm 出现过一些恶性的库，如 lodash-utils, faker.js, chalk-next。万一你不小心安装了上面，轻则项目无法运行，输出无意义乱码，重则删除本地文件。\n\n又因为 npm 几乎没有代码审计的机制，任何开发者只需要有一个 npm 的账号就能在上面随意发布他想发布的包。通常来说电脑病毒都是通过随意读取与写入本地文件来达到病毒的目的，但在 deno 中，代码如果尝试写入与读入文件，都需要询问开发者是否允许操作。并且在 linux 系统，你可以指定像 /usr /etc 这样非 root 角色来操作该文件，避免真是病毒文件导致删除不该删除的文件。\n\n此外像命令执行，网络访问，环境变量这些极易危害电脑的权限，deno 都会检测到，并做出提示告诫开发者是否允许执行。总之你能想到的电脑安全隐患，deno 都为你做好了。\n\n### 内置浏览器环境（运行时）\n\n这是我认为 deno 最大的亮点。\n\n总所周知，浏览器的 js 代码有很大概率是无法直接在 node 中跑起来的，原因就是 node 的全局对象中没有浏览器的对象，如 window，document，甚至连`localStorage` 都有！\n\n这说明什么，往常如果你从别的网站扣了一段代码下来，想在 node 运行会发现什么 window is not defined，xxx is not defined。如果想在 node 运行，你必须需要补齐浏览器的环境，此外可以借助 js-dom，happy-dom 等 npm 包。而 window，xxx 这些全局只有浏览器才定义的全局对象在 deno 的运行时同样定义了，可以到[这里](https://deno.land/manual@v1.29.3/runtime/web_platform_apis#using-web-platform-apis '这里')查看支持的 Web 平台 API。\n\n虽说与真实浏览器全局对象有些许差异，但这也足够让开发者少做很多工作。比如 Web 逆向者通常要扣取浏览器的 js 代码，并补齐环境使其能够在 node 中运行，而有了 deno 这将变得非常轻松！\n\n**与其说是 javascript/typescript 运行时，我更愿意说是浏览器运行时！**\n\n### Web 框架\n\n你可以在 [Web Frameworks](https://deno.land/manual@v1.29.2/getting_started/web_frameworks 'Web Frameworks') 中看到 deno 官方所推荐的 Web 框架，其中 [Fresh](https://deno.land/manual@v1.29.2/getting_started/web_frameworks#fresh 'Fresh') 也是最为推荐使用的（后续我也会尝试使用该框架）。\n\n而在 node 社区中，你会看到像 express，koa，nestjs 等等这种非 Node 官方或大背景的 web 框架（而且还很多），而这时对于初学者而言，就有点不知道该如何做出抉择。\n\n而像 java 中你完全可以不用担心该学什么，说学 spring 就是在学 java 这可一点都不为过。可能这也是国内 java，尤其是 spring 的开发者尤为诸多的原因。\n\n吐槽归吐槽，但我想表明的是在有官方的支持下，用户和开发者能够统一使用某个框架，一起维护与使用一个更好的框架。而不是个个 Web 框架的都有各自的优缺点，让使用者去选择，搞得这个框架是另一个框架的轮子一般。\n\n所以我认为这种支持是很有必要。\n\n### 公共托管服务\n\n[Project - Deploy (deno.com)](https://dash.deno.com/ 'Project - Deploy (deno.com)')\n\ndeno 像 vercel/netfily 一样提供了一个代码托管服务，可以将你的 deno 应用部署上去。对，目前来看还无法部署前端应用，因为要指明一个入门文件（main.ts）。\n\n你可以通过 [https://kuizuo.deno.dev/](https://kuizuo.deno.dev/ 'https://kuizuo.deno.dev/') 来访问我使用 deno Deploy 所创建的一个在线项目。将会输出一个`Hello World!` 的页面。\n\n提供一个免费的线上环境体验，对开发者而言尤为重要，尤其是在将自己的项目成果分享给他人展示时，成就感油然而生。\n\n## node 转 deno 开发的一些帮助\n\ndeno 相关的亮点我也差不多介绍完了，也许你对 deno 已经有一丝兴趣想尝试一番，以下我整理的对你也许有所帮助。\n\n- 如果你是一个 Node 用户，考虑切换到 Deno，这里有一个[官方小抄](https://link.juejin.cn/?target=https://deno.land/manual/node/cheatsheet '官方小抄')来帮助你。\n\n- 如果你不想刷 deno 文档，想快速上手 deno 的话，这里我建议推荐看看 deno 官方所推荐的[deno 代码例子 ](https://deno.land/manual@v1.29.4/examples 'deno代码例子 ')，能够非常快速有效了直接了解 deno 标准库以及依赖导入导出。\n\n- deno 是集成了 node 与 npm 的，也就是说允许直接使用 npm 包与 node 标准库，如果你想用 deno 来写 node，也行，详看[Interoperating with Node.js and npm](https://deno.land/manual@v1.29.4/node#interoperating-with-nodejs-and-npm 'Interoperating with Node.js and npm')。\n\n- 想要在 deno 中连接数据库，可看[Connecting to Databases](https://deno.land/manual@v1.29.4/basics/connecting_to_databases#connecting-to-databases 'Connecting to Databases')。\n\n- 如果想看 deno 如何使用 deno 生态的 Web 框架创建一个 Web 服务，推荐[fresh](https://fresh.deno.dev/ 'fresh')框架，并查看该例子[fresh/examples/counter](https://github.com/denoland/fresh/tree/main/examples/counter 'fresh/examples/counter')\n\n## node 火吗?\n\n关于 deno 就暂且落下笔墨，不妨思考一个问题，node 火吗。\n\n作为 node 开发者，我肯定会说 node 火，不过更多是对 javascript 来说火。\n\n:::info 2022 State of JS\n2022 也结束了，不妨查看 [2022 State of JS](https://2022.stateofjs.com '2022 State of JS') 数据报告统计，看看 JavaScript 在 2022 年是如何发展的吧。\n:::\n\n如今 typescript 大势所趋，说 javascript 就等同于说 typescript，而 javascript 和 node 绑定已成事实，而前端也与 javascript 所绑定，如今的前端工程师要是不会 node，都不好意思说自己是个前端工程师。就现阶段看，没了 nodejs，前端技术得倒退十年（不夸张）。\n\n如果是在 Web 前端，Node 确实已经火的一塌糊涂了，然而它的诞生并不是为了 Web 前端，而是希望将 javascript 作为服务器端语言发展。只是后来没有想到的是 Node.js 在前端领域却大放异彩，造就了如今大前端的盛世。\n\n所以在 Web 后端的领域，Node 确实是不温不火，更多的公司都宁可选主流的后端开发语言，而不是优先考虑 Node。不过倒是在 Serverless 领域中，Node 有着一席之地。\n\n所以我想 deno 的出现，不仅是针对 Node.js 的缺陷，更是针对 Node.js 后端开发的不足。至于说 deno 能否完成原先 node 的使命，只有时间能给我们答案。\n\n## 总结\n\n从上述看来，你应该会发现 deno 并不和 node 一样是一个纯运行时环境。因为他不仅仅做了 javascript/typescript 运行时环境，还做了很多开发者好评的功能，一个为 javascript/typescript 提供更好的开发支持的产品。\n\n但好评并不能直接决定销量，这些功能看似可有可无，没有激起用户从 Node.js 切换过来的杰出之处。就我体验完发现，好像 deno 能做的东西 node 大部分也能做，只是相对繁琐重复一些而已。**但人们更倾向于做一件繁琐重复的事情，而不是做一个新的事情。**\n\n扪心自问，我真的很希望 deno 能火，就开发体验而言，比 node 好用太多了，但好用的东西代表不了用的人就多，这个领域中，生态尤为重要。想要让 node 用户转到 deno 开发还有很长一段路要走。\n\n再来反问自己，我现在会将 deno 作为 node 替代品吗，我想我和多数 node 开发者一样，都不会将 deno 作为主力语言(因为有很多项目都已经使用node来进行开发与推动)。但作为个人开发者，尤其是 node 开发者，我认为还是非常有必要去尝试一番 deno，亲手目睹\"下一代Node\"。\n\n希望本文能对你了解 deno 有所帮助。\n\n## 相关推荐文章\n\n[Deno vs. Node.js 哪个更好 - 掘金 (juejin.cn)](https://juejin.cn/post/7168383367602241550 'Deno vs. Node.js哪个更好 - 掘金 (juejin.cn)')\n\n[为什么 Deno 没有众望所归？超越 Node.js 还要做些什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/6956461134299955213 '为什么 Deno 没有众望所归？超越 Node.js 还要做些什么？ - 掘金 (juejin.cn)')\n\n[连发明人都抛弃 node.js 了，还有前途吗？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/327534747 '连发明人都抛弃node.js了，还有前途吗？ - 知乎 (zhihu.com)')\n\n[已经 2022 年了 Deno 现在怎么样了? - 知乎 (zhihu.com)](https://www.zhihu.com/question/517617266 '已经 2022 年了 Deno 现在怎么样了? - 知乎 (zhihu.com)')"
    },
    {
      "id": "rust-wasm-md5",
      "metadata": {
        "permalink": "/rust-wasm-md5",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/Rust实现MD5加密并打包成WebAssembly调用.md",
        "source": "@site/blog/develop/Rust实现MD5加密并打包成WebAssembly调用.md",
        "title": "Rust实现MD5加密并打包成WebAssembly调用",
        "description": "我初识 WebAssembly 是当初想要分析某个网站的加密算法，最终定位到了一个 .wasm 文件，没错，这个就是 WebAssembly 的构建产物，能够直接运行在浏览器中。在我当时看来这门技术很先进，不过如今看来绝大多数的 web 应用貌似都没使用上，迄今为止我也只在这个网站中看到使用 WebAssembly 的（也许有很多，只是没实质分析过）。",
        "date": "2023-01-04T00:00:00.000Z",
        "formattedDate": "2023年1月4日",
        "tags": [
          {
            "label": "rust",
            "permalink": "/tags/rust"
          },
          {
            "label": "wasm",
            "permalink": "/tags/wasm"
          }
        ],
        "readingTime": 4.863333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "rust-wasm-md5",
          "title": "Rust实现MD5加密并打包成WebAssembly调用",
          "date": "2023-01-04T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "rust",
            "wasm"
          ],
          "keywords": [
            "rust",
            "wasm"
          ]
        },
        "prevItem": {
          "title": "Deno不只是个Javascript运行时",
          "permalink": "/deno-is-not-only-a-javascript-runtime"
        },
        "nextItem": {
          "title": "2022年终总结——从逆向转Web开发",
          "permalink": "/2022-year-end-summary"
        }
      },
      "content": "<img src=\"https://img.kuizuo.cn/wasm-ferris.png\" width=\"230\" height=\"150\" />\n\n我初识 WebAssembly 是当初想要分析某个网站的加密算法，最终定位到了一个 `.wasm` 文件，没错，这个就是 WebAssembly 的构建产物，能够直接运行在浏览器中。在我当时看来这门技术很先进，不过如今看来绝大多数的 web 应用貌似都没使用上，迄今为止我也只在这个网站中看到使用 WebAssembly 的（也许有很多，只是没实质分析过）。\n\n恰好最近正在接触 Rust，而 Rust 开发 WebAssembly 也非常方便，因此本文算是我对 Rust + WebAssembly 的初探。\n\n<!-- truncate -->\n\n有关 [WebAssembly ](https://developer.mozilla.org/zh-CN/docs/WebAssembly)不做过多介绍，你可以到 [MDN](https://developer.mozilla.org/zh-CN/docs/WebAssembly) 中查看相关介绍。本文重点于 Rust + WebAssembly 实践与相关工具，在 [Rust and WebAssembly (github.com)](https://github.com/rustwasm) 或 [https://github.com/rwasm](https://github.com/rwasm) 中查看 rustwasm 相关生态。\n\n## 使用 [wasm-pack](https://rustwasm.github.io/wasm-pack/installer/) 打包 rust 为 wasm 文件\n\n下载 wasm-pack，用于将 rust 代码打包成 .wasm 文件\n\n```typescript\ncargo install wasm-pack\n```\n\n使用 cargo 有可能无法安装 wasm-pack（笔者就安装不了 openssl-sys），可以到 [wasm-pack](https://rustwasm.github.io/wasm-pack/installer/) 官网下载对应的二进制文件进行安装。\n\n### 构建 rust lib\n\n```sh\n cargo new --lib hello-wasm\n```\n\n将会创建 rust 库工程，并创建 `src/lib.rs`。修改为以下内容（先不必在意代码）\n\n```rust title='src/lib.rs'\nextern crate wasm_bindgen;\n\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nextern {\n    pub fn alert(s: &str);\n}\n\n#[wasm_bindgen]\npub fn greet(name: &str) {\n    alert(&format!(\"Hello, {}!\", name));\n}\n\n```\n\n接着在 Cargo.toml 文件中添加 wasm-bindgen 依赖，`wasm-bindgen` 来提供 JavaScript 和 Rust 类型之间的桥梁，允许 JavaScript 使用字符串调用 Rust API，或调用 Rust 函数来捕获 JavaScript 异常。\n\n```toml title='Cargo.toml'\n[package]\nname = \"hello-wasm\"\nversion = \"0.1.0\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n```\n\n### 打包\n\n```rust\nwasm-pack build\n```\n\nWebAssembly 构建产物将会输出在 pkg 目录下，如下\n\n```sh\n├─pkg\n|  ├─.gitignore\n|  ├─hello_wasm.d.ts\n|  ├─hello_wasm.js\n|  ├─hello_wasm_bg.js\n|  ├─hello_wasm_bg.wasm\n|  └─hello_wasm_bg.wasm.d.ts\n```\n\n:::note\n\n如果想当 npm 包发布的话，可以添加 —scope 参数，将会在 pkg 下生成 package.json 文件用于发布或当做一个 npm 包来使用，这样也可以在前端工程中直接当做一个模块来导入使用。\n\n```rust\nwasm-pack build --scope mynpmusername\n```\n\n:::\n\n借助 [wasm-pack](https://rustwasm.github.io/wasm-pack/installer/) 可以非常轻松的将 rust 打包成 wasm，同时还提供了 js 相关支持。直接打包成 js 可导入的 npm 包，而不是让用户导入 wasm 文件然后通过浏览器 `WebAssembly` 对象来加载 WebAssembly 代码，其他语言的 WebAssembly 开发也是如此。\n\n此外 [rustwasm](https://rustwasm.github.io/) 还提供了对应的模板 [rustwasm/wasm-pack-template](https://github.com/rustwasm/wasm-pack-template)，可以帮你省去上面的一系列配置操作，专注于你的 wasm 开发。\n\n### 运行\n\n由于上面我们已经将其打包成了一个 npm 包，只需要将配置好 package.json 的依赖即可，本地的话可通过下方格式，将 pkg 目录更改为 hello-wasm，并放置在根目录下。\n\n```rust\n  \"dependencies\": {\n    \"hello-wasm\": \"file:./hello-wasm\"\n  },\n```\n\n这时候就可以通过 js 直接导入使用\n\n```rust\nconst js = import(\"./hello-wasm/hello_wasm.js\");\njs.then(js => {\n  js.greet(\"WebAssembly\");\n});\n```\n\n在 vite 生态中有个 [rwasm/vite-plugin-rsw](https://github.com/rwasm/vite-plugin-rsw) 插件，能够在 vite 中快速使用 wasm-pack。下文中的一个应用示例也将采用该插件进行开发。\n\n## Rust 实现 MD5 算法\n\n回到一开始的标题，在实现这个功能我一般会想 js 如何实现 MD5 算法，通常来说 MD5 算法是个比较流行的加密算法，通过搜索引擎能够快速帮我找到一份 js 的 MD5 算法。不过我更习惯通过包管理器导入的加密库，如[crypto-js](https://www.npmjs.com/package/crypto-js)。\n\n同理，在 rust 中可以到 [crates.io](https://crates.io/) 中也可以找到你想要的库，如 [digest](https://crates.io/crates/digest)，不过我这里主要是实现 MD5 算法便使用的是 [md-5](https://crates.io/crates/md-5)。以下是我的封装代码。\n\n```rust\nuse md5::{Digest, Md5};\n\nfn md5(input: &str) -> String {\n    let mut hasher = Md5::new();\n\n    hasher.update(input.as_bytes());\n\n    let result = hasher.finalize();\n    format!(\"{:x}\", result)\n}\n\nfn main() {\n    let result = md5(\"123456\");\n    println!(\"{}\", result);\n}\n\n```\n\n然后将这一部分的代码替换到一开始的示例中。\n\n```rust title='lib.rs'\nextern crate wasm_bindgen;\nextern crate md5;\n\nuse wasm_bindgen::prelude::*;\nuse md5::{Digest, Md5};\n\n#[wasm_bindgen]\npub fn md5(input: &str)-> String {\n    let mut hasher = Md5::new();\n\n    hasher.update(input.as_bytes());\n\n    let result = hasher.finalize();\n    format!(\"{:x}\", result)\n}\n\n```\n\n此时通过 wasm-pack 将上述代码打包成 npm 包形式即可在 js 中调用 rust 提供的 md5 函数，至此就已经完成了本标题的内容了。\n\n## 在项目中使用\n\n这里我所借用 [rwasm/vite-plugin-rsw](https://github.com/rwasm/vite-plugin-rsw) 插件，在 vite 中配合 wasm-pack 进行开发的一个实例。代码部分就不做解读了，有兴趣可自行到翻阅源码：[kuizuo/rust-wasm-md5](https://github.com/kuizuo/rust-wasm-md5)\n\n在线地址：[http://rust-wasm-md5.kuizuo.cn](http://rust-wasm-md5.kuizuo.cn/) （不保证地址长期可用）\n\n![](https://img.kuizuo.cn/image__XHPNCbC-B.png)\n\n## 思考：为何不使用 js 的 md5 而是 wasm 的 md5\n\n众所周知，你在浏览器中按下 F12 打开 DevTools，并选择源代码面板中就可以看到当前访问的网站的所有代码。\n\n![](https://img.kuizuo.cn/image_6019y_U19n.png)\n\n而对于一些具有熟练度的逆向分析者中，如果不经过任何处理的代码被打包到生产环境中能够快速的定位出某个功能的具体代码位置。\n\n而通过 wasm 就能很有效的将代码隐藏起来，不让逆向分析者查看，就像下面这样\n\n![](https://img.kuizuo.cn/image_BbA3n6wFws.png)\n\n![](https://img.kuizuo.cn/image_81tgfDE_P7.png)\n\n这里我并没有将 md5 更改成不易猜测的名字，你也可自行下断点尝试一番，定位代码。当你定位到具体代码后，就会得到上图的二进制代码格式，几乎无法解读其意思。\n\n不过虽说解读不出 wasm 的原代码（至少目前来说很难反编译成原始代码），但可以通过扣代码的方式来调用 wasm 对外提供的函数（这里为 md5 函数）。\n\n这里仅是 wasm 的一种实际用例，更多情况下应该还是用 Wasm 来提高 web 应用性能的。\n\n## 相关链接\n\n[编译 Rust 为 WebAssembly - WebAssembly | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Rust_to_wasm)\n\n[Rust and WebAssembly](https://rustwasm.github.io/)\n\n[前端入门 ｜ Rust 和 WebAssembly - Rust 精选](https://rustmagazine.github.io/rust_magazine_2021/chapter_2/rust_wasm_frontend.html)\n\n[rwasm/vite-plugin-rsw: 🦞 wasm-pack plugin for Vite (github.com)](https://github.com/rwasm/vite-plugin-rsw)"
    },
    {
      "id": "2022-year-end-summary",
      "metadata": {
        "permalink": "/2022-year-end-summary",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/reference/2022年终总结——从逆向转Web开发.md",
        "source": "@site/blog/reference/2022年终总结——从逆向转Web开发.md",
        "title": "2022年终总结——从逆向转Web开发",
        "description": "距离上一篇博文有一个月之久了，距离上次编写代码也有一周之久了，由于疫情的全面放开，加上福建省教育厅通知的提前返乡，反而让我感到有些不适。往常这个时间点我忙于期末考试，会把代码的事情放一边，等到彻底放假后，开始闭关潜心学习。然而剩余的半个月变成了线上形式，课还是要上，考试还是要考，虽说身在家乡，但心不在焉的 😂。",
        "date": "2022-12-22T00:00:00.000Z",
        "formattedDate": "2022年12月22日",
        "tags": [
          {
            "label": "年终总结",
            "permalink": "/tags/年终总结"
          },
          {
            "label": "summary",
            "permalink": "/tags/summary"
          }
        ],
        "readingTime": 25.71,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "2022-year-end-summary",
          "title": "2022年终总结——从逆向转Web开发",
          "date": "2022-12-22T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "年终总结",
            "summary"
          ],
          "keywords": [
            "年终总结",
            "summary"
          ],
          "toc_max_heading_level": 3
        },
        "prevItem": {
          "title": "Rust实现MD5加密并打包成WebAssembly调用",
          "permalink": "/rust-wasm-md5"
        },
        "nextItem": {
          "title": "GraphQL 实践与服务搭建",
          "permalink": "/graphql-practice"
        }
      },
      "content": "距离上一篇博文有一个月之久了，距离上次编写代码也有一周之久了，由于疫情的全面放开，加上福建省教育厅通知的提前返乡，反而让我感到有些不适。往常这个时间点我忙于期末考试，会把代码的事情放一边，等到彻底放假后，开始闭关潜心学习。然而剩余的半个月变成了线上形式，课还是要上，考试还是要考，虽说身在家乡，但心不在焉的 😂。\n\n12 月已过半，也是时候该写年终总结了。迄今为止，我已学习了 3 年半的编程。（还好不是两年半），当下的技术不再是当初只会易语言的小伙了。只是当下已没有当初如此强烈的热情与精力了，我称之为老了。\n\n现在回头回顾学习编程时间，用一个成语对自己做个评价——**差强人意**。在这些时间段，我其实荒废过一段时间，厌倦过，贪玩过，荒废过，从我的 [Github 热力图](https://github.com/kuizuo'Github热力图') 中其实就能看得出来。就导致欠下技术的，都需要后续花时间去弥补。\n\n要让自己保持每天都处于学习状态真的太难了 😩，生活总有源源不断的琐事打扰着你。在忙碌的时候总是感觉时间不够用，哪怕有时一天花费了数十个小时，也总感觉做的事情太少了；哪怕每天计划都规划得好好的，但总是有一半还未完成。生活中大量的碎片化时间，而编程学习最不需要的就是这些碎片化时间。\n\n回顾整个编程生涯有太多可感慨的，整个旅途几乎是一个人走完的，期间遇到的坎坷就只得依靠搜索引擎来解决，搜索引擎是我再生父母都不为过。没有人给我指引明确的道路，只依靠心中对技术的憧憬不断前行。走过低谷，登过山峰，而如今站稳身子就足矣。\n\n感叹的话语也就是说到这。今年主要总结我为何从逆向转 Web 开发，并明确我未来所要走的方向，也是本文的主题。**仅作为个人感悟，不作为建议参考。**\n\n<!-- truncate -->\n\n## 为什么要写年终总结\n\n先回答一个问题，为什么要写年终总结？\n\n我从高中开始，每年都会记录这一年所发生的比较有印象的事情并写下自己的感悟。所以写年终算是个人习惯，并且我希望能够一直坚持下去，写到不能写为止。\n\n写年终总结是个非常好的自我总结与反思的方式，总结这一年自身的变化，有哪些精彩与满足，有哪些遗憾和不足。同时定制明年的规划，以该目标不断前行，而不是漫无目的地活着，就失去了很多人生的意义。\n\n同时也算是自我评价与建议，很多时候我们会收到很多别人有关自己的评价与建议，可人总会对他人有莫名的排斥感，就难以虚心听从他人的建议，从而犯错许多（说的是我就对了）。年终总结还有个作用就是弥补自己对某件事情未来可能要发生的情况，要如何做到不犯错，预先有个明确的预防意识。\n\n即便可能要花数天的周期去回顾与总结，我也很愿意去总结，我常说回顾过去，就是在仰望未来。写年终所做的也就是这个过程。\n\n写年终总结也算是种分享，分享自己的开发经历，当他人阅读时或许有所启发。\n\n**过去的，就过去了，别将当下的遗憾留到未来，这就是年终的最大意义。**\n\n## 为什么是 Web 开发？而不是逆向\n\n今年大部分的开发时间都花在 Web 开发上，在此期间也接触到许多技术，并通过博客笔记的方式记录下来。\n\n我很庆幸我的 Web 开发从一个 Beginner 到 Intermediate，现在回忆整个学习路程，一路学得都很野很随意，从未系统学习过，总是学到一半，就自认为已经掌握了，便开始进行实战项目，可以说很多知识都是在实战探索中了解的。\n\n虽然很多人都直称我为大佬，但我离 Advanced 还有一大段的路途要走，而这段路途是无比的艰难与漫长。不过好在路不歪，只要肯走终会到达终点 👨‍🦲。\n\n而带我入门的逆向技术，在今年没有丝毫的长进，说得过分点，就是弃坑了。也正如标题所说，至于缘由，细看下文。\n\n### 逆向\n\n熟悉我的人应该知道我之前是做爬虫与逆向分析，但是为何今年的技术栈彻底转型到 Web 开发上。\n\n我常常和别人说起我的技术栈转型（从逆向转到开发），不过比较多的都会比较好奇我为什么不继续深造下去。\n\n在此我也回顾了我**从逆向转变到 Web 开发**的过程，顺带也回答这个问题。不过在这里先说说我个人对逆向的看法：\n\n#### 逆向需要的技术知识面比较广。\n\n就我接触逆向的过程来说，接触了易语言，JavaScript，Python，Java，Php 等等编程语言。\n\n使用过了一堆的逆向工具，如 Frida、IDA、JEB、jadx 等等（我目前能想到比较有名的）。此外还有一堆知识，包括但不限于以下技术：自动化脚本、TCP/HTTP 协议、抓包、爬虫、加密学、图像识别（验证码、滑块位置）、汇编、反编译、AST 反混淆。\n\n**要我说我在逆向中学到的不是如何使用这些工具或掌握某个技能，而是锻炼出一定的阅读与分析代码能力。**工具与技能总是瞬息万变，但阅读与分析代码能力却是实实在在，一成不变的，也是逆向中最值得学习的。\n\n有接触过 [CTF](https://baike.baidu.com/item/ctf/9548546) 想必再熟悉不过逆向工程的技术面广了。\n\n#### 越来越多的网站或应用程序不断加强安全防护，未来只会越来越难逆向。\n\n逆向分析，说白话就是去看别人的代码，进行一些修改手段，达到自己想要的目的。比如修改某个软件的标题或作者信息、将别人的代码“偷”过来用、爬取某些网站或软件的数据。\n\n但是随着现在越来越多潜在的安全问题，很多框架底层，服务厂商，都会对一些可能有安全问题的代码进行警告或者底层处理。比如使用 ORM 框架能够有效防止 SQL 注入，前端框架中涉及 XSS 攻击也会有相应的错误提示与处理，再如浏览器跨域以及跨站点 cookie 不共享，都是为了用户的安全而去考虑的。这样的例子有太多了。\n\n简单说说安卓逆向的过程：拿到一个 Apk，发现有加壳（给代码加固让逆向者不易于看到源代码），这时候就需要通过脱壳才能查看到源代码；此时就算脱完了壳，接下来可能将面对经过混淆过的代码，这份代码难以用人眼去阅读，不调试运行，单靠静态分析很难分析出东西，这时候可能就要借助 AST 对代码进行还原；还原完了配合动静分析将代码给扣出来，而在分析的时候可能又有各种检测，比如抓包，反调试以阻碍逆向进度；最后就算逆向工作都做完了，代码也扣下来了，还要尝试运行扣完的代码，这时候极大可能还不一定能运行，然后又要回头看看到底那一步做错了。\n\n可以说逆向的工作就是不断地调试，不断分析，最终拿到想要的结果。整个过程可以说非常耗时且折磨人，心智如果不够强大，真的容易劝退（我当下耐心也早不如当初了）。但是得到最终的目的，将非常爽，成就感爆棚，相当于一个解了几小时的题，最终被攻克的感觉。\n\n前阵子在逆向圈中，看到过一张图，大致也把我的逆向学习流程也表达了出来，最终我的逆向学习也确实止步在 Flutter 上。\n\n![](https://img.kuizuo.cn/1cd67d5812e3061e_zy9LIkXWIM.jpg)\n\n上面所说到的逆向技术中，例如加壳，代码混淆，反调试，风控等等，都是阻碍逆向手段。同样对于爬虫而已，通常会采取反爬措施，包括但不限于封 IP、封账号、JS 参数加密、代码混淆、浏览器指纹、TLS 指纹、验证等。而且防护手段可以说是越来越多，逆向的难度也就越来越大。并且在服务开发那边只需要修改一点东西，逆向可能就需要从头再来一遍。\n\n**未来逆向的难度只增不减，但薪资可不一定保证这趋势。**\n\n#### 风险\n\n从上面也不难看出逆向常常与安全挂钩，如果一个网站或软件不是那么好被逆向，那么间接说明安全性是比较高的。可一旦涉及到安全，同时又是互联网，就免不了网络安全与法律相关的风险。\n\n在大多数逆向的对象（网站，软件）中，多数都是他人的劳动产物，当你未经他人允许的情况下，去爬取他人的数据，或是修改一些版权信息再次发布出来，就属于非法行为。本质和未经他人允许，偷人家的东西性质是一个样的。并且在有防护措施的情况下，绕过网站防护措施获取数据属于违背权利人意愿读取、收集数据，将有较大可能被认定为对计算机信息系统的 “侵入”。\n\n要知道在逆向的行业中，有很多都是擦边灰产，至少我所在的逆向圈是这样的，抱着【仅供学习为参考，请勿用于非法用途】的想法做逆向工程。路子极易走歪，很少能够正常去走安全岗位的。相信你应该能看到许多类似的案件，如【某某程序员因非法侵入 xx 网站，获刑 x 年】。这不是危言耸听，目前国家对网络安全以及非法数据获取的打击力度，也将决定了这些案件将会越来越多，爬虫逆向也将会越来越邢。\n\n### 自身因素\n\n简单介绍完我认为爬虫和逆向的看法后，再来说说自身因素。\n\n#### 更想写代码，而不是看代码\n\n我是很享受写代码的过程，一份高质量的代码会让人赏心悦目。我为此特意学习下设计模式、重构技巧以及 TDD 测试。这些在逆向中基本难以涉及，但是这些对开发的体验和代码的健壮性都是非常重要的，也是让我个人觉得技术有所提升的技能点。\n\n在逆向分析中，大部分时间都不是在写代码而是在看（分析）代码，而反编译出来的代码，很有可能是带有混淆过的代码，而你想要分析这一块代码的作用，只能去一步步调试，将代码啃下来，从而推断运行时某变量的值，或是某个函数的作用。\n\n虽然说开发岗位中，有很多情况下也是在看代码的日子中度过的，但相比反编译阅读代码而言，至少不至于那么晦涩难懂。\n\n#### 更想碰新技术，而不是旧技术\n\n其次，在逆向分析中，遇到的网站或软件所用的技术一般都是较为稳定成熟的技术，而这些技术往往不是很新，因此需要去了解很多旧的技术，但这些旧技术仅仅只对逆向分析有用，甚至过段时间很有可能就会遗忘。并且要了解的旧技术还不少，学得将会特别杂。\n\n而我又是一个喜新厌旧的人，对任何新鲜事物都抱有好奇尝试的态度。我终将认为旧的技术被淘汰是迟早的问题，新技术的出现肯定不是无缘无故的出现，必然是为了解决某些问题而诞生的，如性能，开发体验，安全等等。\n\n这里有篇我对新技术的看法，推荐阅读一番。[深谈个人对新技术的看法 - 愧怍的小站 (kuizuo.cn)](https://kuizuo.cn/talk-new-technologies-opinion'深谈个人对新技术的看法 - 愧怍的小站 (kuizuo.cn)')\n\n#### 更想开源，而不是闭源\n\n在逆向开发，不，是在灰产开发中，有很多代码是别指望开源出来的，这背后会涉及到商业利益或是版权等问题。一旦代码放出来，将意味着你的代码将有很大的可能被别人利用做坏事，最终甚至祸及到自己。所以大多数情况下，你多半只能将自己的应用发布出去，而不是将源码开源，通常也就带有商业化的性质。\n\n我想任何开发者肯定是希望自己的代码走的更远，走的正规，而不是被拿来做违背自身意愿的事情。\n\n开源不仅能为自己提升一些技术知名度，展现自身技术的一面，同时代码被他人使用与认可，这番成就感就足够继续坚持开源下去。因为我有很多技术都是通过开源项目中学到的，所以我能感受到开源带来的魅力，也是对于前人的崇拜，想走开源的原因。\n\n**因为淋过雨，所以很想为别人撑把伞**\n\n### 小结\n\n其实在今年出头我还特意复习了一波安卓逆向，为了更深入了解了更底层的知识与工具（当然现在忘得也差不多了），因一些特殊原因我的电子设备不在了，别问，问就是坏了到现在还没修好。就导致我的编程语言环境，逆向工具，虚拟机配置，代码等数据直接灰飞烟灭，也让我停滞了 1 个月的学习。\n\n我想这才是我从逆向转 Web 开发的最重要的理由了。\n\n逆向的学习对我开发有很大的帮助。例如开发中的安全问题，我在开发中都会时刻考虑去考虑该问题。如加壳、SQL 注入、代码混淆、接口限流、接口幂等性（Fiddle R 包）等等安全性问题。\n\n我庆幸我学过逆向，让我学到很多在开发中比较难学到的技能，如调试，阅读源码，而这些也是绝大多数 Web 开发者都欠缺的能力。\n\n逆向应该就暂以告终，未来会有很长的一段时间，甚至以后不再接触深入专研逆向。\n\n每当回想，【当时那么难的加密算法都能搞得定，开发一个功能还能有多难】，保持着这种心态，也让我保持着开发。\n\n也是逆向激起我对编程的兴趣，可以说没有接触逆向开发，我也不太可能会接触到 Web 开发。\n\n## 但 Web 开发就一定好吗？\n\n上面对逆向的看法仅个人分析而言，但是 Web 开发就一定好吗？我不敢下绝对的肯定，不同人不一定适合相同的技术，**但是我特别看好 Web 技术（尤其是 JavaScript，偏前端向）**，以下是我看好的点。\n\n### 应用性广\n\n目前仍有很多人还停留在 JavaScript 只能编写前端页面的水平，自从 Node.js 问世，目前绝大多数的应用都可以使用 JavaScript 进行编写。\n\n换句话说，只要你会 JavaScript 就可以编写很多应用了。有个在国外经常被应用的一条和 JavaScript 有关系的著名定律：\n\n**Atwood 定律：任何可以用 JavaScript 编写的应用程序，最终都会用 JavaScript 编写**\n\nWeb 前端开发不用多说，目前还得用 JavaScript 来编写。而后端开发通过 Node.js 也有一己之力。近几年特别流行跨平台开发，也就是一份代码，多端运行。\n\n使用 React Native 或是 Uniapp 这样的前端应用框架，顺带去了解一下相应平台的 API，就能够编写出安卓或 IOS 应用，做过小程序开发肯定知道小程序的技术栈就使用到前端开发的技术栈，如果你会前端开发，就能很轻松的上手小程序开发了。\n\n并且越来越多的软件都是网页版优先，然后再通过 Electron 这样的跨平台解决方案，实现不同平台间的程序。诸如 Vscode，Typeorm 等等便是其中的佼佼者。\n\n不过本质上都是在不同应用的平台上套浏览器的壳，然后接入一些该平台的接口，因此普遍应用的体积与内存都相对比较大，与原生相比自然是略逊与原生，不过这点性能上的差异在如今硬件升级如此普遍的物质生活也显得微不足道了。\n\n但借助浏览器自带的跨平台性，你所编写的应用能够非常轻松的让他人访问，只需要用户有个浏览器，并且通过上述跨平台的解决方案，也能够有效的将你的 web 应用转成其他平台的应用，而不是在耗费时间与精力去编写另一套代码。\n\n在一些技术文档上，会有 API/SDK 的支持，而绝大多数都支持使用 JavaScript/Node.js，也许该功能本身并不是使用 JavaScript 来编写的，但完全可以通过 JavaScript 来轻松调用该功能。并且如今 JavaScript 生态如此庞大，你不必担心库/包的问题，npm 作为世界上最大的开放源代码的生态系统（包管理器），在这里你几乎找得到你所想要的库/包。\n\n此外有越来越多的第三方服务平台（通常称 Fass，函数即服务），专门提供数据接口与用户鉴权，如 firebase/supabase 或是国产的云开发产品（如小程序）。前端程序员只需要专注与业务代码，借助第三方开发平台，就能够编写一个高可用的应用。反而也映衬了，Web 开发好像可以没有后端，但必须要有前端的观念。\n\n### 工作量将越来越多\n\n这句话的意思可能有点加班那味道，但我所要表明的是可以做的事情多了，意味着你的工作量增加了，同时你的编码价值也就提升了，不过实际价值（工资）的话不一定提升，因为这主要看老板和地区。\n\n怎么理解呢，我举几个例子。\n\n现在大部分的 web 应用都采用前后端分离的形式，但在曾经则是由后端通过模板语言渲染成 HTML 直接返回，通过前后端分离的形式，前端只需要专注页面交互的编写，而后端只需要保证接口可靠性。并且前后端分离也有一个特别显著的特点，能非常有效的节省服务器的资源，原本服务器的渲染动作迁移至客户端来做。也许有人会说，那这样 SEO 优化该怎么办，这不就有了 Next.js、Nuxt.js 这样的 SSR（服务端渲染） 框架，而这些工作，也是前端要做的。\n\n并且越到后面你越能感觉到客户端（前端）远比服务端（后端）做的东西来的多，比如开发阶段的数据 Mock，前端国际化，设计原型等等。之所以会有这种感觉，也许是因为我的大部分开发都是前端，这里你也可以回想当下的工作量与往年相比是多了还是不变。\n\n### 技术更新快\n\n前端真的是每隔一段时间，必定会出一些新的技术，也不由让不少前端学习者感叹真的学不动。但伴随着新的技术出现，必然会有新的岗位与机会，这也是我看好前端的一个点。\n\n**不过这种机会在国内不太多见，反而在国外特别普遍。** 多的不说，自行体会。\n\n忘记从哪看到的一句话：“前端工程师的一大焦虑：永远能（且必须要）看到大量前沿的技术，但自己手上的活儿跟不上，导致眼高手低。”\n\n不只是前端，做技术这行的，必须要跟着技术发展的角度，并且要时刻关注最新，主流的技术。\n\n---\n\n有关 Web 开发的一些想法与感悟就写到这，其实还有蛮多可写的，比如选择 Vue 与 React？为什么是 JavaScript？有太多自我审问的话题了，不过由于当下时间相对紧迫，有机会的话再续写吧。\n\n综上，也就是我看好 Web 技术的几个点，也回答了我未来的方向。希望这些能够帮助一些不知抉择方向的伙伴。\n\n## 在实践中学习\n\n回顾整个技术栈，基本都是在项目实践中不断学习。也许是因为逆向的缘故，因为逆向基本上都是靠实战出来的，导致我的学习路线也趋于实践。\n\n不过在我看来，写项目是最直接能体现出所想学的技术。我在学习一门新技术时，我通常会用项目或者博文的形式来总结我的学习过程。我也乐意花时间在这上面，并将其分享出来。当有其他人也在学习这门技术时，看到该项目或博文，我就认为非常有意义。\n\n**我在学任何一门技术，会使用该技术写点东西；换言之是为了写点东西，而去学点不一样技术。**\n\n## 技术心态的变化\n\n如今来看，确实没那么想写代码，尤其是那种工作量大，重复性强的代码，而编写这些代码，其实与搬砖无任何区别，本质也是重复性与劳动性的任务。\n\n曾经可能是因为接触得比较少，对于很多软件背后的原理及实现一概不知，所以看到啥就都想写写看，最终很多项目都成为半成品。\n\n而随着越深入的学习，反而自己所想实现的东西，前人都已经帮我们实现好了。完全可以借用前人的代码，在此基础上学习与使用，而不必从头再来，耗费很多不必要的时间。\n\n到最后为了实现一开始所想实现的东西，不用再费尽心思，去开源社区搜寻一番，总能找到与自己所要实现的类似的产品，此时只需要会看，会改，总能达到自己最终要实现的东西，有时候自己也称为了别人口中的 CV 工程师。\n\n也正因如此，写代码的欲望就不再那么强烈。很多自认为无意义的代码或者是以后都不一定用得上的代码就少写了许多。于是乎缺少了很多自我思考与专研的时间，虽说也确实节省了很多不必要的时间，加快最终功能的实现，但这就是自己想要的编程生活吗？或者说这就是绝大多数人的编程生活。\n\n## 何来的自驱力\n\n现在回想，是什么驱使我学习，我心中的答案是无能。\n\n当你什么都不会时，或者是目前的能力还不足够将某件事情做好，你就会不断地焦虑，犹如热锅上的蚂蚁，想做但又怕做不好。\n\n我有很多社会技能是欠缺的，比如人际交往，谈话技巧，合作行为等等，并且我本身也不愿去学习这些技能。正因如此，只有不断发挥自身长处，用自己所擅长的领域弥补自己的短板，以提升自我在社会的竞争力，以至于不那么容易被淘汰。\n\n## 返校的一年\n\n今年也是我重归学校的一年，倘若，去年没有休学一年的话，如今我可能已经在外实习了，转瞬一年就过去了，如今的我还沉浸在当初休学和别人创业工作的日子。\n\n也是因为当时休学急迫，后事做得并未完善，学校的一些课程并未申请缓考，最终视为缺考，即挂科。然后此前对大学的课程也是抱着可有可无的心态，也挂了几门课程，如果不是辅导员告知，我还有 34 学分要补（20 学分为严重预警，40 学分为退学或降级处理），我都不曾了解自己在学校挂了这么多科 😂。最离谱的是有个同班同学正好就被降级处理了，不过好在今年上半年并未挂科，加上下半年也重修了一些课程，还不至于离本科毕业证书越走越远。\n\n回到学校后，就感觉如同坐牢一般，只不过环境相对舒适一番，尤其是在疫情当下更是如此，我这一年出校玩乐的次数好像不超过 10 次。当我仔细回想一下大学的真正意义是什么？貌似就是混个日子，混个证书。我也想不出大学能够有什么实质性的作用，也许是因为我所处的学校不行，换个好一点的大学或许都不是这样了。\n\n不过今年回学校反而去参加了曾经都不怎么看上的社团（虽然现在也差不了多少），给社团写了些项目，主要也为了给自己重返学校带点个人知名度。但因为学校不是那么有名（臭名可能有），所以这里就不便放上相关信息。\n\n### 考研\n\n明年的话我就大三下了，面对我的有条熟知的考研路。说实话，从目前来看，我对考研不抱有太大的希望，我是属于实践派的那种，我坚信没有什么是试不出来。背理论，刷八股，我很反感。\n\n不知道由于什么原因，总感觉一段时间不写代码，真的就不会写代码。仿佛与自己写的代码成为了陌生人一般（所以写注释的重要性就体现出来了）\n\n倘若读研的话，必然将会有数个月的时间重心不在代码上，到时候回来编写代码时，又发现自己好像又重新学了一遍似的。加之万一上岸失败的心理落差，会让自我觉得这几个月的努力都白费。而我又恰好是一位结果论者，即只在意结果，不在意过程如何。在别人的眼中，是难以看到你考研备战努力的过程，只会在意你上没上岸。这便是我不想考研因素之一。\n\n但今年在互联网上所认识伙伴中挺多给我过于高的评价，都认为我作为一个学生，能有这水平是不是在某某牛逼的高校读书。然而并不是，我甚至都不好意思述说自己的高校，感觉是当下的污点。也正因如此反而让我有点过于焦虑，就从身份上，这不得让我萌生读研的一丝丝想法，也不至于死绝考研。\n\n自我认为离真正的大佬还差很长的一段距离，我只是靠着三分钟热度，加上爱折腾，才维系下去，而那些真正的大佬是肯花费大量时间去编写他们所认为有意义的代码。\n\n:::info\n\n如果可以的话，在下方的留下你对我的评价与建议。我尽可能的争取在明年这时候完成你心目中我的样子。\n\n:::\n\n## 结语\n\n今年的年终就告一段落，与之前的年终总结相比，篇幅缩减了许多，主要感觉之前写的挺多流水账的，废话挺多的。也有一点是因为时间相对紧迫，其实 12 月我还没放假，都处于线上上课，线上考试的状态，而线上考试的方式我就不得吐槽了，提前打印给定的答题纸，题目以电脑的方式展示，最终将答案手写到答题纸上并通过手机扫描（扫描全能王）成 PDF 的格式提交，当然摄像头必然也是有的。总之麻烦事还是有的，还没到彻底闲下来闭关学习的时候。\n\n按往常可能还有明年的规划，但我现在认为很多时候都难以依照自身意愿做事，而规划正好自己所设想美好的计划，很容易事与愿违。因为回顾过往的规划，有太多美好的计划，但在实际分析下也将变得不堪一击。不止项目需要可行性分析，人生计划同样需要，一些天马行空幻想，其实就不再有意义去记录了。\n\n**坚持做自己想做的事情，而不是逼自己做不愿做的事情**。这是我编程学习中座右铭，也是给予他人编程学习的建议。\n\n<p align=\"right\">写于2022年12月22日    By 愧怍</p>"
    },
    {
      "id": "graphql-practice",
      "metadata": {
        "permalink": "/graphql-practice",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/GraphQL实践.md",
        "source": "@site/blog/program/GraphQL实践.md",
        "title": "GraphQL 实践与服务搭建",
        "description": "有关 GraphQL 介绍及上手实践，并在 Nest.js 和 Strapi 中搭建 GraphQL 服务",
        "date": "2022-11-24T00:00:00.000Z",
        "formattedDate": "2022年11月24日",
        "tags": [
          {
            "label": "api",
            "permalink": "/tags/api"
          },
          {
            "label": "graphql",
            "permalink": "/tags/graphql"
          },
          {
            "label": "nest",
            "permalink": "/tags/nest"
          },
          {
            "label": "strapi",
            "permalink": "/tags/strapi"
          }
        ],
        "readingTime": 12.323333333333334,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "graphql-practice",
          "title": "GraphQL 实践与服务搭建",
          "date": "2022-11-24T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "api",
            "graphql",
            "nest",
            "strapi"
          ],
          "keywords": [
            "api",
            "graphql",
            "nest",
            "strapi"
          ],
          "description": "有关 GraphQL 介绍及上手实践，并在 Nest.js 和 Strapi 中搭建 GraphQL 服务"
        },
        "prevItem": {
          "title": "2022年终总结——从逆向转Web开发",
          "permalink": "/2022-year-end-summary"
        },
        "nextItem": {
          "title": "重构kz-admin",
          "permalink": "/refactor-kz-admin"
        }
      },
      "content": "![](https://img.kuizuo.cn/320f3e5a66900d68e93de38154989948.png)\n\n> GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n\n大概率你听说过 GraphQL，知道它是一种与 Rest API 架构属于 API 接口的查询语言。但大概率你也与我一样没有尝试过 GraphQL。\n\n事实上从 2012 年 Facebook 首次将 GraphQL 应用于移动应用，到 GraphQL 规范于 2015 年实现开源。可如今现状是 GraphQL 不温不火，时不时又有新的文章介绍，不知道的还以为是什么新技术。\n\n:::tip 目标\n本文将上手使用 GraphQL，并用 Nestjs 与 Strapi 这两个 Node 框架搭建 GraphQL 服务。\n:::\n\n<!-- truncate -->\n\n关于 GraphQL 介绍，详见官网 [GraphQL | A query language for your API](https://graphql.cn/ 'GraphQL | A query language for your API') 或相关介绍视频 [GraphQL 速览：React/Vue 的最佳搭档](https://www.bilibili.com/video/BV1fM4y1A7U1/ 'GraphQL 速览：React/Vue 的最佳搭档')\n\n## GraphQL 与 Restful API 相比\n\n![](https://img.kuizuo.cn/9a7412200a062646b729c8419be28b35.jpeg)\n\n### Restful API\n\nRestful 架构的设计范式侧重于分配 HTTP 请求方法（GET、POST、PUT、PA TCH、DELETE）和 URL 端点之间的关系。如下图\n\n![](https://img.kuizuo.cn/17fc41e2de8d829dc2d41e31a0775df3.png)\n\n但是实际复杂的业务中，单靠 Restful 接口，需要发送多条请求，例如获取博客中某篇博文数据与作者数据\n\n```http\nGET /blog/1\n\nGET /blog/1/author\n```\n\n要么单独另写一个接口，如`getBlogAndAuthor`，这样直接为调用方“定制”一个接口，请求一条就得到就调用方想要的数据。但是另写一个`getBlogAndAuthor` 就破坏了 Restful API 接口风格，并且在复杂的业务中，比如说还要获取博文的评论等等，后端就要额外提供一个接口，可以说非常繁琐了。\n\n有没有这样一个功能，将这些接口做一下聚合，然后**将结果的集合返回给前端**呢？在目前比较流行微服务架构体系下，有一个专门的中间层专门来处理这个事情，这个中间层叫 BFF（Backend For Frontend）。可以参阅 [BFF——服务于前端的后端](https://blog.csdn.net/qianduan666a/article/details/107271974 'BFF——服务于前端的后端')\n\n![](https://img.kuizuo.cn/image_Y4u9tNpZwR.png)\n\n但这些接口一般来说都比较重，里面有很多当前页面并不需要的字段，那还有没有一种请求：**客户端只需要发送一次请求就能获取所需要的字段**\n\n有，也就是接下来要说的 GraphQL\n\n### GraphQL\n\n![](https://img.kuizuo.cn/8a141ec5fa73781d66fb2e1b60f9b49d.jpg)\n\nREST API 构建在请求方法（method）和端点（endpoint）之间的连接上，而 GraphQL API 被设计为只通过一个端点，即 `/graphql`，始终使用 POST 请求进行查询，其集中的 API 如 http://localhost:3000/graphql，所有的操作都通过这个接口来执行，这会在后面的操作中在展示到。\n\n:::info\n但是想要一条请求就能得到客户端想要的数据字段，那么服务端必然要做比较多的任务😟（想想也是，后端啥都不干，前端就啥都能获取，怎么可能嘛）。\n\n而服务端要做的就是搭建一个 GraphQL 服务，这在后面也会操作到，也算是本文的重点。\n:::\n\n接下来便会在客户端中体验下 GraphQL，看看 GraphQL 究竟有多好用。\n\n## **在线体验 GraphQL**\n\n可以到 [官网](https://graphql.cn/learn/ '官网') 中简单尝试入门一下，在 [Studio](https://studio.apollographql.com/sandbox/explorer 'Studio (apollographql.com)') 可在线体验 GraphQL，也可以到 [SWAPI GraphQL API](<https://swapi-graphql.netlify.app/?query={\n  person(personID: 1) {\n    name\n  }\n}> 'SWAPI GraphQL API (swapi-graphql.netlify.app)') 中体验。\n\n下面以 `apollographql` 为例，并查询 People 对象。\n\n### query\n\n查询所有 People 并且只获取 `name`、`gender`、`height` 字段\n\n![](https://img.kuizuo.cn/image_kvWUNtlUbf.png)\n\n查询 personID 为 1 的 Person 并且只获取 `name`，`gender`，`height` 字段\n\n![](https://img.kuizuo.cn/image_Msg9xwWFrl.png)\n\n查询 personID 为 2 的 Person 并且只获取 `name`，`eyeColor`、`skinColor`、`hairColor` 字段\n\n![](https://img.kuizuo.cn/image_hX0l36Acme.png)\n\n从上面查询案例中其实就可以发现，我只需要在 person 中写上想要获取的字段，GraphQL 便会返回带有该字段的数据。避免了返回结果中不必要的数据字段。\n\n```javascript\n{\n\tperson{ \n\t\t# 写上想获取的字段 \n\t}\n}\n```\n\n如果你不想要 person 数据或者想要其他其他的数据，不用像 Restful API 那样请求多条接口，依旧请求`/graphql`，如\n\n![](https://img.kuizuo.cn/image_Z0b6ya-auG.png)\n\n:::info\n\n**无论你想要什么数据，一次请求便可满足。**\n\n:::\n\n### mutation\n\nGraphQL 的大部分讨论集中在数据获取（也是它的强项），但是任何完整的数据平台也都需要一个改变服务端数据的方法。即 CRUD。\n\nGraphQL 提供了 [变更(Mutations)](https://graphql.cn/learn/queries/#mutations '变更（Mutations）') 用于改变服务端数据，不过 `apollographql` 在线示例中并没有如 `createPeople` 字段支持 。这个片段在线体验中就无法体验到，后在后文中展示到。这里你只需要知道 GraphQL 能够执行基本的 CRUD 即可。\n\n### fragmen 和 subscribtion\n\n此外还有 `fragment ` 与 `subscription` 就不做介绍。\n\n### 小结\n\n尝试完上面这些操作后，可以非常明显的感受到 GraphQL 的优势与便利，本来是需要请求不同的 url，现在只需要请求 `/graphql`，对调用方（前端）来说非常友好，香是真的香。\n\n可目前只是使用了别人配置好的 GraphQL 服务，让前端开发用了特别友好的 API。但是，对于后端开发而言，想要提供 GraphQL 服务可就不那么友善了。因为它不像传统的 restful 请求，需要专门配置 GraphQL 服务，而整个过程是需要花费一定的工作量（定义 Schema，Mutations 等等），前面也提到想要一条请求就能得到客户端想要的数据字段，那服务端必然需要额外的工作量。\n\n不仅需要在后端中配置 GraphQL 服务，用于接收 GraphQL 查询并验证和执行，此外前端通常需要 GraphQL 客户端，来方便使用 GraphQL 获取数据，目前实用比较多的是[Apollo Graph](https://www.apollographql.com/platform/ 'Apollo Graph')，不过本文侧重搭建GraphQL 服务，因此前端暂不演示如何使用 GraphQL。\n\n你可能听过一句话是，**graphq​l 大部分时间在折磨后端**，并且要求比较严格的数据字段，但是好处都是前端。把工作量基本都丢给了后端，所以在遇到使用这门技术的公司，尤其是后端岗位就需要考虑有没有加班的可能了。\n\n以下便会开始实际搭建 GraphQL 服务，这里会用 Nest.js 与 Strapi 分别实践演示。\n\n## Nest.js\n\n官方文档：[GraphQL + TypeScript | NestJS](https://docs.nestjs.com/graphql/quick-start 'GraphQL + TypeScript | NestJS')\n\n模块：[nestjs/graphql](https://github.com/nestjs/graphql 'nestjs/graphql')\n\n仓库本文实例代码仓库： [kuizuo/nest-graphql-demo](https://github.com/kuizuo/nest-graphql-demo 'kuizuo/nest-graphql-demo')\n\n**创建项目**\n\n```bash\nnest new nest-graphql-demo\n```\n\n**安装依赖**\n\n```bash\nnpm i @nestjs/graphql @nestjs/apollo graphql apollo-server-express\n```\n\n**修改 app.module.ts**\n\n```typescript title='app.module.ts'\nimport {Module} from '@nestjs/common';\nimport {GraphQLModule} from '@nestjs/graphql';\nimport {ApolloDriver, ApolloDriverConfig} from '@nestjs/apollo';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      autoSchemaFile: true,\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n### resolver\n\n设置了`autoSchemaFile: true` ，nest.js 将会自动搜索整个项目所有以 `.resolver.ts` 为后缀的文件，将其解析为 `schema.gql` 比如说创建`app.resolver.ts`\n\n```typescript title='app.resolver.ts'\nimport {Resolver, Query} from '@nestjs/graphql';\n\n@Resolver()\nexport class AppResolver {\n  @Query(() => String) // 定义一个查询,并且返回字符类型\n  hello() {\n    return 'hello world';\n  }\n}\n```\n\n在 `graphql` 中 `resolver` 叫解析器，与 `service` 类似（也需要在 `@Module` 中通过 `providers` 导入）。`resolver`主要包括`query`(查询数据)、`mutation`(增、删、改数据)、`subscription`(订阅，有点类型 `socket`)，在 `graphql` 项目中我们用 `resolver` 替换了之前的控制器。\n\n这时候打开[http://127.0.0.1:3000/graphql](http://127.0.0.1:3000/graphql 'http://127.0.0.1:3000/graphql')，可以在右侧中看到自动生成的 Schema，这个 Schema 非常关键，决定了你客户端能够请求到什么数据。\n\n尝试输入 GraphQL 的 query 查询（可以按 Ctrl + i 触发代码建议（Trigger Suggest），与 vscode 同理）\n\n![](https://img.kuizuo.cn/image_a3yl4oVtSU.png)\n\n此时点击执行，可以得到右侧结果，即`app.resolver.ts` 中 `hello` 函数所定义的返回体。\n\n![](https://img.kuizuo.cn/image_bK9bvZ3QMm.png)\n\n### [Code first](https://docs.nestjs.com/graphql/quick-start#code-first) 与 [Schema first](https://docs.nestjs.com/graphql/quick-start#schema-first)\n\n在 nestjs 中有 [Code first](https://docs.nestjs.com/graphql/quick-start#code-first) 与 [Schema first](https://docs.nestjs.com/graphql/quick-start#schema-first) 两种方式来生成上面的 Schema，从名字上来看，前者是优先定义代码会自动生成 Schema，而后者是传统方式先定义Schema。\n\n在上面一开始的例子中是 Code First 方式，通常使用该方式即可，无需关心 Schema 是如何生成的。下文也会以 Code First 方式来编写 GraphQL 服务。\n\n也可到官方示例仓库中 [nest/sample/31-graphql-federation-code-first](https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first) 和 [nest/sample/32-graphql-federation-schema-first](https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first) 查看两者代码上的区别。\n\n### 快速生成 GraphQL 模块\n\nnest 提供 cli 的方式来快速生成 GraphQL 模块\n\n```typescript\nnest g resource <name>\n```\n\n![](https://img.kuizuo.cn/image_L9yYAn78Dw.png)\n\n比如创建一个 blog 模块\n\n```bash\nnest g resource blog --no-spec\n? What transport layer do you use? GraphQL (code first)\n? Would you like to generate CRUD entry points? Yes\nCREATE src/blog/blog.module.ts (217 bytes)\nCREATE src/blog/blog.resolver.ts (1098 bytes)\nCREATE src/blog/blog.resolver.spec.ts (515 bytes)\nCREATE src/blog/blog.service.ts (623 bytes)\nCREATE src/blog/blog.service.spec.ts (446 bytes)\nCREATE src/blog/dto/create-blog.input.ts (196 bytes)\nCREATE src/blog/dto/update-blog.input.ts (243 bytes)\nCREATE src/blog/entities/blog.entity.ts (187 bytes)\nUPDATE src/app.module.ts (643 bytes)\n```\n\n便会生成如下文件\n\n![](https://img.kuizuo.cn/image_XemqTcfz_D.png)\n\n```typescript title='blog.resolver.ts'\nimport {Resolver, Query, Mutation, Args, Int} from '@nestjs/graphql';\nimport {BlogService} from './blog.service';\nimport {Blog} from './entities/blog.entity';\nimport {CreateBlogInput} from './dto/create-blog.input';\nimport {UpdateBlogInput} from './dto/update-blog.input';\n\n@Resolver(() => Blog)\nexport class BlogResolver {\n  constructor(private readonly blogService: BlogService) {}\n\n  @Mutation(() => Blog)\n  createBlog(@Args('createBlogInput') createBlogInput: CreateBlogInput) {\n    return this.blogService.create(createBlogInput);\n  }\n\n  @Query(() => [Blog], {name: 'blogs'})\n  findAll() {\n    return this.blogService.findAll();\n  }\n\n  @Query(() => Blog, {name: 'blog'})\n  findOne(@Args('id', {type: () => Int}) id: number) {\n    return this.blogService.findOne(id);\n  }\n\n  @Mutation(() => Blog)\n  updateBlog(@Args('updateBlogInput') updateBlogInput: UpdateBlogInput) {\n    return this.blogService.update(updateBlogInput.id, updateBlogInput);\n  }\n\n  @Mutation(() => Blog)\n  removeBlog(@Args('id', {type: () => Int}) id: number) {\n    return this.blogService.remove(id);\n  }\n}\n```\n\n此时 Schema 如下\n\n![](https://img.kuizuo.cn/image_sJCQpllOXK.png)\n\n不过`nest cli`创建的`blog.service.ts` 只是示例代码，并没有实际业务的代码。\n\n此外`blog.entity.ts`也不为数据库实体类，因此这里引入`typeorm`，并使用`sqlite3`\n\n### 集成 Typeorm\n\n安装依赖\n\n```typescript\npnpm install @nestjs/typeorm typeorm sqlite3\n```\n\n```typescript title='app.module.ts'\nimport {Module} from '@nestjs/common';\nimport {AppController} from './app.controller';\nimport {AppService} from './app.service';\nimport {GraphQLModule} from '@nestjs/graphql';\nimport {ApolloDriver, ApolloDriverConfig} from '@nestjs/apollo';\nimport {AppResolver} from './app.resolver';\nimport {BlogModule} from './blog/blog.module';\nimport {TypeOrmModule} from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'sqlite',\n      database: 'db.sqlite3',\n      entities: [__dirname + '/**/*.entity{.ts,.js}'],\n      synchronize: true,\n    }),\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      autoSchemaFile: true,\n      playground: true,\n    }),\n    AppModule,\n    BlogModule,\n  ],\n  controllers: [AppController],\n  providers: [AppService, AppResolver],\n})\nexport class AppModule {}\n```\n\n将 `blog.entity.ts` 改成实体类，代码为\n\n```typescript title='blog.entity.ts'\nimport {ObjectType, Field} from '@nestjs/graphql';\nimport {\n  Column,\n  Entity,\n  PrimaryGeneratedColumn,\n  CreateDateColumn,\n  UpdateDateColumn,\n} from 'typeorm';\n\n@ObjectType()\n@Entity()\nexport class Blog {\n  @Field(() => Int)\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Field()\n  @Column()\n  title: string;\n\n  @Field()\n  @Column({type: 'text'})\n  content: string;\n\n  @Field()\n  @CreateDateColumn({name: 'created_at', comment: '创建时间'})\n  createdAt: Date;\n\n  @Field()\n  @UpdateDateColumn({name: 'updated_at', comment: '更新时间'})\n  updatedAt: Date;\n}\n```\n\n其中 `@ObjectType()` 装饰器让 `@nestjs/graphql` 自动让其视为一个 `type Blog`\n\n而 `@Field()` 则是作为可展示的字段，比如 `password` 字段无需返回，就不必要加该装饰器。\n\n:::tip\n如果你认为 添加 `@Field()` 是件繁琐的事情（nest 官方自然也想到），于是提供了 [GraphQL + TypeScript - CLI Plugin ](https://docs.nestjs.com/graphql/cli-plugin) 用于省略 `@Field()` 等其他操作。（类似于语法糖）\n\n借用官方的话: \n\n> Thus, you won't have to struggle with @Field decorators scattered throughout the code.\n\n因此，您不必为分散在代码中的@Field 装饰符而烦恼。\n:::\n\n:::caution\n\n`@nestjs/graphql` 会将 typescript 的 number 类型视为 Float，所以需要转成 Int 类型，即 `@Field(() => Int)`\n\n:::\n\n为 BlogService 编写 CRUD 数据库业务代码，并在 dto 编写参数效验代码，这里简单暂时部分代码。\n\n```typescript title='blog.service.ts' \nimport {Injectable} from '@nestjs/common';\nimport {InjectRepository} from '@nestjs/typeorm';\nimport {Repository} from 'typeorm';\nimport {CreateBlogInput} from './dto/create-blog.input';\nimport {UpdateBlogInput} from './dto/update-blog.input';\nimport {Blog} from './entities/blog.entity';\n\n@Injectable()\nexport class BlogService {\n  constructor(\n    @InjectRepository(Blog)\n    private blogRepository: Repository<Blog>,\n  ) {}\n\n  create(createBlogInput: CreateBlogInput) {\n    return this.blogRepository.save(createBlogInput);\n  }\n\n  findAll() {\n    return this.blogRepository.find();\n  }\n\n  findOne(id: number) {\n    return this.blogRepository.findOneBy({id});\n  }\n\n  async update(id: number, updateBlogInput: UpdateBlogInput) {\n    const blog = await this.blogRepository.findOneBy({id});\n    const item = {...blog, ...updateBlogInput};\n    return this.blogRepository.save(item);\n  }\n\n  remove(id: number) {\n    return this.blogRepository.delete(id);\n  }\n}\n```\n\n```typescript title='create-blog.input.ts'\nimport {InputType, Field} from '@nestjs/graphql';\n\n@InputType()\nexport class CreateBlogInput {\n  @Field()\n  title: string;\n\n  @Field()\n  content: string;\n}\n```\n\n此时\n\n![](https://img.kuizuo.cn/image_7-twN56Aym.png)\n\n### CRUD\n\n下面将演示 graphql 的 Mutation。\n\n#### 新增\n\n![](https://img.kuizuo.cn/image_NPqShDN3Pl.png)\n\n#### 修改\n\n![](https://img.kuizuo.cn/image_c4ycwRs-po.png)\n\n#### 删除\n\n![](https://img.kuizuo.cn/image_xpkHhpS1-K.png)\n\nQuery 就不在演示。\n\n### 小结\n\n至此，在 Nest.js 中配置 GraphQL 服务的就演示到此，从这里来看，Nest.js 配置 GraphQL 服务还算比较轻松，但是做了比较多的工作量，创建 resolver，创建 modal（或在已有实体添加装饰器），不过本文案例中只演示了基本的 CRUD 操作，实际业务中还需要涉及鉴权，限流等等。\n\n## Strapi\n\nStrapi 官方提供 [GraphQL 插件](https://market.strapi.io/plugins/@strapi-plugin-graphql 'GraphQL插件') 免去了配置的繁琐。更具体的配置参见 [GraphQL - Strapi Developer Documentation](https://docs.strapi.io/developer-docs/latest/development/plugins/graphql.html 'GraphQL - Strapi Developer Documentation')\n\n这里我就选用 [kuizuo/vitesse-nuxt-strapi](https://github.com/kuizuo/vitesse-nuxt-strapi 'kuizuo/vitesse-nuxt-strapi') 作为演示，并为其提供 graphQL 支持。\n\nstrapi 安装\n\n```javascript\nnpm install @strapi/plugin-graphql\n```\n\n接着启动 strapi 项目，并在浏览器打开 graphql 控制台 [http://localhost:1337/graphql](http://localhost:1337/graphql 'http://localhost:1337/graphql')，以下将演示几个应用场景。\n\n### 例子\n\n#### 查询所有 todo\n\n![](https://img.kuizuo.cn/image_4GFUs8CmQJ.png)\n\n#### 查询 id 为 2 的 todo\n\n![](https://img.kuizuo.cn/image_NMM4e3L_y8.png)\n\n#### 查询 id 为 2 的 todo 并只返回 value 属性\n\n![](https://img.kuizuo.cn/image_E1eWrzjaEs.png)\n\n#### 新增 todo\n\n![](https://img.kuizuo.cn/image_pclR7Zb6TE.png)\n\n#### 更新 todo\n\n![](https://img.kuizuo.cn/image_g3RJL7RQWR.png)\n\n#### 删除 todo\n\n![](https://img.kuizuo.cn/image_m7s17q2TG0.png)\n\n由于 [Nuxt Strapi](https://strapi.nuxtjs.org/ 'Nuxt Strapi') 提供 [useStrapiGraphQL](https://strapi.nuxtjs.org/usage#usestrapigraphql 'useStrapiGraphQL') 可以非常方便是在客户端调用 GraphQL 服务。\n\n```html\n<script setup lang=\"ts\">\n  const route = useRoute();\n  const graphql = useStrapiGraphQL();\n\n  // Option 1: use inline query\n  const restaurant = await graphql(`\n  query {\n    restaurant(id: ${route.params.id}) {\n      data {\n        id\n        attributes {\n          name\n        }\n      }\n    }\n  }\n`);\n\n  // Option 2: use imported query\n  const restaurant = await graphql(query, {id: route.params.id});\n</script>\n```\n\n### 小结\n\n对于 Strapi 来说，搭建 GraphQL 服务基本没有配置的负担，安装一个插件，即可配合 Strapi 的 content-type 来提供 GraphQL 服务。\n\n## 总结\n\n**GraphQL** 翻译过来为 **图表 Query Language**，我所理解的理念是通过 json 数据格式的方式去写 SQL，而且有种前端人员在写 sql 语句。在我看来 GraphQL 更多是业务数据特别复制的情况下使用，往往能够事半功倍。但对于本文中示例的代码而言，GraphQL 反倒有点过于先进了。\n\n如今看来，GraphQL 还处于不温不火的状态，目前更多的站点主流还是使用 Restful API 架构。我不过我猜测，主要还是大多数业务没有 API 架构的升级的需求，原有的 Restful API 虽说不够优雅，但是也能够满足业务的需求，反而 GraphQL 是一个新项目 API 架构的选择，但不是一个必须的选择。\n\n至于如何选择，可以参阅官方 [GraphQL 最佳实践](https://graphql.cn/learn/best-practices/)，至于说有没有必要学 GraphQL，这篇文章 [都快 2022 年了 GraphQL 还值得学吗](https://blog.csdn.net/kevin_tech/article/details/120735500) 能给你答案。我的建议是了解即可，新项目可以考虑使用，就别想着用 GraphQL 来重构原有的 API 接口，工作量将会十分巨大，并且还可能是费力不讨好的事。反正我认为这门技术不像 Git 这种属于必学的技能，我的五星评分是⭐⭐\n\n但多了解一门技术，就是工作面试的资本。回想我为何尝试 GraphQL，就是因为我无意间看到了一份 ts 全栈的远程面试招聘，在这份招聘单中写到 【会 graphql 编写是加分项】。所以抱着这样的态度去尝试了一番，说不准未来就是因为 graphql 让我拿到该 offer。当然也是因为很早之前就听闻 GraphQL，想亲手目睹下是否有所谓的那么神奇。"
    },
    {
      "id": "refactor-kz-admin",
      "metadata": {
        "permalink": "/refactor-kz-admin",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/重构kz-admin.md",
        "source": "@site/blog/project/重构kz-admin.md",
        "title": "重构kz-admin",
        "description": "kz-admin 是一个基于 NestJs + TypeScript + TypeORM + Redis + MySql + Vben Admin 编写的一款前后端分离的权限管理系统",
        "date": "2022-11-07T00:00:00.000Z",
        "formattedDate": "2022年11月7日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "admin",
            "permalink": "/tags/admin"
          }
        ],
        "readingTime": 5.0633333333333335,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "refactor-kz-admin",
          "title": "重构kz-admin",
          "date": "2022-11-07T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "admin"
          ],
          "keywords": [
            "project",
            "admin"
          ],
          "description": "kz-admin 是一个基于 NestJs + TypeScript + TypeORM + Redis + MySql + Vben Admin 编写的一款前后端分离的权限管理系统",
          "image": "/img/project/kz-admin.png"
        },
        "prevItem": {
          "title": "GraphQL 实践与服务搭建",
          "permalink": "/graphql-practice"
        },
        "nextItem": {
          "title": "Protocol 协议复现模板",
          "permalink": "/protocol-template"
        }
      },
      "content": "![](https://img.kuizuo.cn/logo_irKdpu5Epv.png)\n\n> kz-admin 使用 NestJs + TypeScript + TypeORM + Redis + MySql + Vben Admin\n> 等技术栈，并采用 monorepo 管理项目，希望这个项目在 ts 全栈的路上能够帮助到你。\n\n详细介绍可以参见 [kz-admin后台管理系统](/kz-admin)\n\n## 为何重构\n\n前段时间基于我的 [kz-admin](https://github.com/kuizuo/kz-admin \"kz-admin\")\n模板写了一个link-admin的项目（可以访问 [link.kuizuo.cn](http://link.kuizuo.cn/ \"link.kuizuo.cn\") 在线体验，账号 admin，密码a123456），是一个“一次性”充值链接管理系统，具体自行体验即可（项目未开源）。\n\n该项目有前端管理页面，后端服务，和一个链接使用页面，共三个项目。\n\n每次启动时候，都需要进入到对应项目下，打开终端，输入命令。要么使用`npm-run-all` 来批量执行 dev 与 build 命令。\n\n想到后续项目的应用场景大概率也可能是多项目的，于是就准备使用 turborepo 将项目重构为 monorepo 管理，将前后端项目都统一放到一个仓库中，并且将 nestjs 版本升级到 v9，顺便在完善一下api接口文档，并提供 [ApiFox](https://www.apifox.cn/ \"ApiFox\") 文档。\n\n<!-- truncate -->\n\n## monorepo重构\n\nmonorepo的重构相对简单，首先使用 [Turborepo](https://turbo.build/repo/docs/getting-started/create-new \"Turborepo\") 新建一个 monorepo 的仓库，目录结构如下\n\n![](https://img.kuizuo.cn/image_Svd1WZKBdf.png)\n\n将 packages 与 apps 下的文件清空，然后把原 kz-admin 的[前端项目](https://github.com/kuizuo/kz-vue-admin)与[后端项目](https://github.com/kuizuo/kz-nest-admin)放到 apps 下。修改下 README.md 与 package.json 其启动命令即可。\n\n![](https://img.kuizuo.cn/image_eYL2rKrakb.png)\n\n## 依赖升级\n\n我原先的nestjs依赖是8.0.0，但是技术发展太快，nestjs\n9.0.0都已经发布了，所以这次更新属于大版本更新，通常属于**破坏性更新，可能会导致原代码失效**，所以更新依赖要慎重。\n\n我使用的是[antfu/taze](https://github.com/antfu/taze \"antfu/taze\") 来更新依赖，也可以使用 `yarn upgrade-interactive -- latest`。\n\n```javascript\nnpx taze -r\n```\n\n由于此次属于大版本更新，所以使用`taze major`，小版本则使用 `taze minor`。\n\n![](https://img.kuizuo.cn/image_xJ_Bh1NZih.png)\n\n`npx taze major -r -w` 将更新依赖写入到package.json下，接着执行pnpm i更新依赖即可。\n\n既然都将nestjs更新了，那么nestjs相关生态的库自然也是要更新的，于是就遇到的typeorm 0.2.0 → 0.3.0用法的问题，主要是将findOne等方法改写，如 `findOne(id) → findOneBy({ id })` 。整个过程还算顺利，\n\n## 使用ApiFox编写接口文档与接口测试\n\n在原项目中我Swagger写的其实够完善，但是在代码协同上只给前端一个Swagger地址不是很友好。但直到我接触并体验一段时间ApiFox后，让我更想去编写Swagger，给前端同事一个良好的Api接口测试体验，因为我自身也作为前端开发者，我太清楚API接口文档的重要性了。\n\n其实早听闻ApiFox，但当时我还在用ApiPost，觉得ApiPost足够好用就没有更换的欲望。直到看到别人给我分享用ApiFox编写的接口文档时，让我眼前一亮，至于有多好用，可以参阅官方的介绍视频[21分钟学会Apifox](https://www.bilibili.com/video/BV1ae4y1y7bf \"21分钟学会Apifox\")。发自使用者内心的好用，下面会有些实际接口案例来说明到底有多好用。\n\n你可以访问 [https://admin.kuizuo.cn/swagger-ui](https://admin.kuizuo.cn/swagger-ui \"https://admin.kuizuo.cn/swagger-ui\") 来查看kz-admin的Swagger文档\n\njson格式为[https://admin.kuizuo.cn/swagger-ui/json](https://admin.kuizuo.cn/swagger-ui/json \"https://admin.kuizuo.cn/swagger-ui/json\")，用于导入ApiFox中。\n\nApiFox在线链接: [https://www.apifox.cn/apidoc/shared-7a07def2-5b82-4c71-bf57-915514f61f25](https://www.apifox.cn/apidoc/shared-7a07def2-5b82-4c71-bf57-915514f61f25 \"https://www.apifox.cn/apidoc/shared-7a07def2-5b82-4c71-bf57-915514f61f25\") 访问密码: kz-admin\n\n### 数据实体\n\n本次重构对于数据实体花费的时间比较多，主要就是数据实体重命名，如\n\n- CreateUserDto → UserCreateDto\n\n- UpdateUserDto → UserUpdateDto\n\n- DeleteUserDto → UserDeleteDto\n\n- PageUserDto→ UserPageDto\n\n- ...\n\n将操作动词后置，这样做好处就是不用从一堆`CreatxxxxDto`中找一个`CreateUserDto`，而是转变成从几个`UserxxxxDto`找`UserCreateDto`，就像下图这样，左侧Swagger，右侧ApiFox，在数据实体比较多的时候显示的会更加直观。\n\n![](https://img.kuizuo.cn/image_a4g_9OfyUw.png)\n\n![](https://img.kuizuo.cn/image_avg9_2fE5G.png)\n\n当然在ApiFox中可以通过搜索来筛选模型，但在开发体验方面，我认为此次重命名重构还是非常有必要的。\n\n定义数据实体（Schemas）非常重要，这样我们就能知道该请求接口应该传递什么参数，会接收到什么样的数据。\n\n### 接口文档\n\nApifox是以文档作为驱动的，可以说把Swagger文档写好，Apifox就会好用。直接上例子\n\n以用户新增和分页查询用户为例，直接上效果图（左侧是ApiFox，右侧为Swagger代码）\n\n![](https://img.kuizuo.cn/image_Zs3cEmA7KD.png)\n\n![](https://img.kuizuo.cn/image_WLjlJRNBlH.png)\n\n在定义完Swagger并通过ApiFox导入后，不用修改ApiFox就能得到上述效果。这里强烈建议将ApiFox接口问题，与nestjs的Swagger代码进行对比，就能体会到写好Swagger就能得到一份如此优雅的Api文档。\n\n做前端和做后端看到这文档，这不得发自内心的赞美。\n\n### 了解更多\n\n此外 ApiFox 的好处远远不止于此，篇幅有限，好东西不是一句两句就能说明白的东西，建议自行体验一番，绝对会有不一样的收获。\n\n## 回顾项目\n\nVben admin 是我21年6月当时接触 Vue3 的第一个项目，在当时Vue3测试版已经发布，而vue-element-admin都早已烂大街了，也有点审美疲劳了。想给自己换一个后台管理系统的模板，恰好无意间刷到了 Vben Admin，管理面板的效果让我眼前一亮，迄今为止我都认为非常耐看。\n\n但是Vben Admin仅仅只是前端模板与mock数据，并无后端数据，于是就正好利用我使用的 Node 后端框架 Nestjs 来编写后端服务。但当时项目并不完善，在我编写了几个相似的后端管理的项目后，将核心部分抽离出来，并将其封装出来，kz-admin也就此诞生。\n\n鸣谢 [hackycy/sf-nest-admin](https://github.com/hackycy/sf-nest-admin)，我的后端 nestjs 架构与部分代码都借鉴该项目。\n\n最后也要感谢 Vben 项目，在当时让我进一步了解到 Vite + Vue + TypeScript 等最新前端相关技术。"
    },
    {
      "id": "protocol-template",
      "metadata": {
        "permalink": "/protocol-template",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/Protocol 协议复现模板.md",
        "source": "@site/blog/project/Protocol 协议复现模板.md",
        "title": "Protocol 协议复现模板",
        "description": "一个用于快速复现请求协议的 Web 开发模板。基于 Nuxt3 开发，并集成了NaiveUI，Unocss，等相关工具库封装。",
        "date": "2022-10-30T00:00:00.000Z",
        "formattedDate": "2022年10月30日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "protocol",
            "permalink": "/tags/protocol"
          },
          {
            "label": "template",
            "permalink": "/tags/template"
          },
          {
            "label": "nuxt3",
            "permalink": "/tags/nuxt-3"
          }
        ],
        "readingTime": 17.376666666666665,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "protocol-template",
          "title": "Protocol 协议复现模板",
          "date": "2022-10-30T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "protocol",
            "template",
            "nuxt3"
          ],
          "keywords": [
            "project",
            "protocol",
            "template",
            "nuxt3"
          ],
          "description": "一个用于快速复现请求协议的 Web 开发模板。基于 Nuxt3 开发，并集成了NaiveUI，Unocss，等相关工具库封装。",
          "image": "/img/project/protocol.png"
        },
        "prevItem": {
          "title": "重构kz-admin",
          "permalink": "/refactor-kz-admin"
        },
        "nextItem": {
          "title": "rollup.js 初体验",
          "permalink": "/rollup-js-experience"
        }
      },
      "content": "<p align=\"center\">\n  <img src=\"https://api.kuizuo.cn/api/icon/carbon:api.svg\" width=\"80\" height=\"80\" />\n</p>\n\n<p align=\"center\">\n  <i> Artwork from <a href=\"https://v3.nuxtjs.org/\">Nuxt3</a></i>\n</p>\n\n<h1 align=\"center\">Protocol</h1>\n<p align=\"center\">🧪 一个用于快速复现请求协议的 Web 开发模板。</p>\n\n<p align=\"center\">\n  <a href=\"https://github.com/kuizuo/protocol\">\n    <img src=\"https://img.shields.io/github/stars/kuizuo/protocol?style=social\" alt=\"GitHub stars\" />\n  </a>\n  <a href=\"https://protocol.kuizuo.cn\">🖥 在线预览</a>\n  <a href=\"https://stackblitz.com/github/kuizuo/protocol\">\n    <img src=\"https://developer.stackblitz.com/img/open_in_stackblitz.svg\" />\n  </a>\n</p>\n\n<br />\n\n<!-- truncate -->\n\n## 为什么我要写这样的一个模板(网站)\n\n我曾经是做 API 请求的，经常要模拟某些请求（协议复现）。所以写过比较多的 api 请求代码，在此期间尝试编写过许多代码方式和软件形态。但都不令我满意，不是过于繁琐，就是开发太慢，都达不到我想要的预期。尤其是开发体验，可以说是苦不堪言。\n\n就在前段时间接触了 SSR 框架（Nuxt3）与 Serverless Function，并用其写了一些项目，如 [api-service](https://github.com/kuizuo/api-service 'api-service') 。而[某了个羊刷次数的网站](https://7y8y.vercel.app)的实现，则让我意外发现这貌似就是我理想中的的协议复现最佳实现？于是我立马开启了 VSCode，将我的这一想法用代码的方式来实现出来，在经历了两周几乎不间断的开发，最终达到了我的预期效果！\n\n在 [模拟请求|协议复现方案](https://kuizuo.cn/request-protocol-scheme '模拟请求|协议复现方案') 这篇文章中我对协议复现的一些方案总结，而这篇就是对 SSR 框架方案的一个具体实践。\n\n## 技术栈\n\n这个模板基于[Nuxt3](https://v3.nuxtjs.org/)开发的，该框架拥有全栈开发能力（即全栈框架），并有诸多[模块](https://modules.nuxtjs.org/)，即装即用。同时由于采用`Serverless Function` 方式来定义 api 接口，可以轻易地部署在自有服务器或[Vercel](https://vercel.com 'Vercel')， [Netlify](https://www.netlify.com/ 'Netlify')这样的平台上。由于要做到敏捷开发，该模板集成了[Naive UI](https://www.naiveui.com/ 'Naive UI') 组件库，组件库的质量足够胜任常规前端业务开发。此外还封装了一些我个人的所用到的工具库以提高开发效率。\n\n为此我给这个模板起名 Protocol，即协议，也可以认为是礼仪。**一个用于快速复现请求协议的 Web 开发模板。**\n\n废话不多数，就正式来介绍下 [Protocol](https://github.com/kuizuo/protocol 'Protocol')。\n\n## 目录结构\n\n```bash\nprotocol\n├── assets # 前端静态资源文件\n├── components # 组件\n├── composables # 组合式API\n├── content # content 模块\n│   ├── changelog.md # 更新日志\n│   └── help.md # 帮助说明\n├── data # 持久化数据\n│   └── db\n├── layouts # 布局\n├── nuxt.config.ts # nuxt 配置文件\n├── package.json # 依赖包\n├── pages # 页面\n├── plugins # 插件\n├── public # 服务端静态资源文件\n│   └── logo.svg\n├── server # 服务端文件\n│   ├── api # 后端接口\n│   └── protocol # 协议请求逻辑代理\n├── stores # pinia 状态管理\n│   └── user.ts # 用户状态\n├── types # 类型定义\n│   └── user.d.ts # 用户类型声明文件\n├── ecosystem.config.js # pm2 配置文件\n├── nitro.config.ts # nitro 配置文件\n├── app.config.ts # 前端配置文件\n└── app.vue # 入口文件\n\n```\n\n从这个项目的目录结构中其实就可以看出，本项目是集成了**全栈**能力，并且使用 Vue 与 Node 来编写前端与后端，并**不会产生前后端分离的分割感**，只需要打开一个项目即可开始工作。这得益于[Nuxt3](https://v3.nuxtjs.org/ 'Nuxt3') 与 [Nitro](https://nitro.unjs.io/ 'Nitro')。\n\n由于是基于 Nuxt3 开发的，所以使用该项目是需要一些 SSR 开发经验。如果你还没有接触 SSR，可以根据你熟悉的前端框架选择对应的 SSR 框架来尝试体验一番。~~都要 2023 年了，不会还有前端程序员没用过 SSR 框架吧。~~\n\n## **基本功能**\n\n### 全栈开发\n\n这里我不想过多介绍 Nuxt3 的基本功能与使用，在我的一个 [基于 Nuxt3 的 API 接口服务网站](https://kuizuo.cn/use-nuxt3-build-api-server#nuxt3-介绍 '基于Nuxt3的API接口服务网站') 的项目中，有简单介绍过 Nuxt3，有兴趣可以去看看。\n\n这里你只需要知道 Nuxt3 具有全栈开发的能力，如果你想，完成可以基于 Nuxt3 这个技术栈来实现 Web 开发的前端后端工作。\n\n### 类型提示\n\n首先，最重要的就是类型提示，对于大多数 api 请求而言，类型往往常被忽略。这就导致不知道这个请求的提交参数、响应结果有什么数据字段。举个例子\n\n![](https://img.kuizuo.cn/image_75GsdEZuLK.png)\n\n这是一个 post 请求用于实现登录的，但是这个响应数据 data 没有任何具体提示（这里的提示是 vscode 记录用户常输入的提示），这时候如果一旦拼接错误，就会导致某个数据没拿到，从而诱发 bug。同理提交的请求体 body 不做约束，万一这个请求还有验证码 code 参数，但是我没写上，那请求就会失败，这是就需要通过调试输出，甚至需要抓包比对原始数据包才能得知。\n\n最主要的是没有类型约束的情况下，非常容易出现出现访问的对象属性不存在，做 js 开发的肯定经常遇到如下错误提示。\n\n```javascript\nUncaught TypeError: Cannot read properties of undefined (reading 'data')\n```\n\n有太多很多时候就是因为没有类型，无形间诱发 bug。就极易造成开发疲惫，不愿维护代码，这也是很多做 api 接口都常常忽视的一点。包括我之前也是同样如此。\n\n对于 js 而言，上述情况自然是解决不了，但这种场景对于 ts 来说在适合不过了。所以 Protocol 自然是集成了 ts，并且有良好的类型提示。下面展示几张开发时的截图就能体会到，当然你前提是得会 ts 或者看的懂 ts。\n\n![](https://img.kuizuo.cn/image_VbEuizLRfz.png)\n\n上面的类型提示演示代码仅仅作为体现类型的好处，将类型定义（interface，type 等）和核心逻辑都在同一个文件自然不好，容易造成代码冗余。实际开发中，更多使用命名空间，将类型写到 ts 声明文件.d.ts 中。比如将上面的改写后如下\n\n![](https://img.kuizuo.cn/image_48-YSpYd1g.png)\n\n![](https://img.kuizuo.cn/image_9b9ns2BM67.png)\n\n就在我写这篇文章做代码演示的时候，又发生了拼写错误，如下图。由于使用 ts 类型与 eslint，所以在开发时的问题我就能立马发现，而不是到了运行时才提示错误。\n\n![](https://img.kuizuo.cn/image_PfpxCKZomB.png)\n\n**有了类型提示能非常有效的避免上述问题**。同时 ts 并不像 java 那样的强类型语言，你完全可以选择是否编写 ts 的类型（type 或 interfere），这由你决定，你乐意都可以将 typescript 写成 anyscript，因为确实有些人确实不喜欢写类型。\n\nts 的类型提示仅是其次，此外还配置了 eslint 对代码检查，让代码在 2 个空格缩进，无分号，单引号等代码规范下。保证代码质量，而不会出现这边一个分号，那边来个双引号的情况。\n\n### 工具库\n\n要想在实际项目中使用，还需要做很多功课，例如数据格式转换，编码，加解密，cookie 存储，IP 代理等等。这段时间也特此对常用工具封装成 npm 包，也就是 [@kuizuo/http](https://www.npmjs.com/package/@kuizuo/http) 与 [@kuizuo/utils](https://www.npmjs.com/package/@kuizuo/utils)。\n\n大部分的代码我都会采用最新的 ECMAScript 标准来编写，目的也是为了简化代码，减少不必要的负担。\n\n### 数据库\n\n既然是全栈框架，那么必然少不了数据库的存取，[nitro](https://nitro.unjs.io/guide/introduction/storage 'nitro') 自然是提供了数据存储选择，即 [unjs/unstorage](https://github.com/unjs/unstorage#http-universal 'unjs/unstorage')。使用特别简单：\n\n```javascript\nawait useStorage().setItem('test:foo', {hello: 'world'});\nawait useStorage().getItem('test:foo');\n```\n\n不指定则使用内存，当然了想要持久化配置，[nitro](https://nitro.unjs.io/guide/introduction/storage#defining-mountpoints 'nitro') 也提供了相关配置\n\n```javascript title='nitro.config.ts'\n// nitro.config.ts\nimport {defineNitroConfig} from 'nitropack';\nexport default defineNitroConfig({\n  storage: {\n    redis: {\n      driver: 'redis',\n      /* redis connector options */\n    },\n    db: {\n      driver: 'fs',\n      base: './data/db',\n    },\n  },\n});\n```\n\n并根据不同前缀（根据 nitro.config.ts 中的 storage 对象的属性）存储在不同存储位置，如\n\n```javascript\n// 存内存缓存中\nawait useStorage().setItem('cache:foo', {hello: 'world'});\nawait useStorage().getItem('cache:foo');\n\n// 存db中\nawait useStorage().setItem('db:foo', {hello: 'world'});\nawait useStorage().getItem('db:foo');\n\n// 存redis中\nawait useStorage().setItem('redis:foo', {hello: 'world'});\nawait useStorage().getItem('redis:foo');\n```\n\n从目前来看，[unjs/unstorage](https://github.com/unjs/unstorage#http-universal 'unjs/unstorage')并没有提供 sql 数据库的方案。不过对于这类项目而言，似乎也没有上 sql 数据库的必要，文件和 redis 就足以了。如果需要也可以[自定义 drivers](https://github.com/unjs/unstorage#making-custom-drivers '自定义 drivers')。\n\n:::caution 注意\n\n由于 Vercel 是不支持文件读写的，所以想要文件方式数据存储功能就行不通，需要更换存储方案，比如远程 redis 数据库。\n\n如果是部署到自由的服务器（通常是 Linux 系统），则需要分配相应的读写权限。\n\n:::\n\n### 用户凭证存储\n\n通常来说，有两种用户凭证，Cookie 和 Token，有了上述数据存储的方案，存取用户凭证并不是什么难题。不过用户凭证更多的是用来鉴权的，这时候就需要配置前端[Middleware](https://v3.nuxtjs.org/guide/directory-structure/middleware#middleware-directory) 和后端 [Middleware](https://v3.nuxtjs.org/guide/directory-structure/server#server-middleware)，至于选择哪种，根据实际网站情况来选择即可。\n\n### 更新日志与帮助说明\n\n我提供了两个 md 页面，更新日志（ChangeLog）和帮助说明（Usage），如果需要更新内容，在根目录下 `content` 文件夹中找到对应文件修改即可。\n\n如果你想在创建新的 md 页面只需要在 content 中新建一个文件（如test.md），在页面路由创建同名vue文件(test.vue)，将下方的 path 修改相应文件名即可。\n\n```html title='pages/test.vue'\n<script setup lang=\"ts\">\ndefinePageMeta({\n  layout: 'markdown',\n});\n</script>\n\n<template>\n  <div>\n    <ContentDoc class=\"prose text-left\" path=\"/test\" />\n  </div>\n</template>\n```\n\n### 打包与部署\n\n传统的 node 后端框架，通常需要将原文件或者打包后的文件放到服务器上，执行 `npm i` 下载 `package.json` 里的依赖文件，然后执行运行命令启动。这一步骤的下载依赖就尤为致命，因为通常下载依赖将会特别耗时。\n\n但 Nuxt3 则是会将前后端的资源文件，打包到 `.output` 文件夹下，以本项目为例，打包的大小为 14.6MB,gzip 压缩为 3.11MB（写本章时的记录），如果不使用[Content](https://content.nuxtjs.org/) 模块体积将会更小。打包完成提示如下\n\n```bash\nΣ Total size: 14.6 MB (3.11 MB gzip)\n√ You can preview this build using node .output/server/index.mjs\n```\n\n然后你只需要将 `.output` 整个文件夹放到服务器上，并且安装好 node 环境，输入 `node .output/server/index.mjs` 即可启动项目，默认端口为 3000。当然也可以通过 pm2 的配置文件来启动，配置文件如下\n\n```javascript title='ecosystem.config.js'\nmodule.exports = {\n  apps: [\n    {\n      name: 'Protocol',\n      exec_mode: 'cluster',\n      instances: '1',\n      env: {\n        NITRO_PORT: 8010,\n        NITRO_HOST: 'localhost',\n        NODE_ENV: 'production',\n      },\n      script: './.output/server/index.mjs',\n    },\n  ],\n};\n```\n\n接着执行 `pm2 start ecosystem.config.js --env production` 即可运行。相比传统需要手动下载依赖的方式，Nuxt3 则是直接将 web 项目实际所需要的依赖都打包在一起，只需要在有 node 环境下机器中就可以立马运行，无需等待依赖下载。\n\n如果部署在 Vercel 或 Netlify 就更轻松了，根据官方的步骤即可做到一键部署。\n\n## **开发流程（形态）**\n\n介绍完工具库，如果不介绍下开发流程，很多人都不知道该如何起手，这里我会用 Github 的 api 作为案例演示，也就是模板源代码中所演示的那样。当然，后续我会根据一些实战项目考虑弄个案例展示（在写中），以来方便使用与完善该模板。毕竟如果开发者自己都不愿意用，又怎么去说服他人来使用呢。\n\n### 修改内容\n\n如何修改某文字内容或某图标，这里就不再赘述了，Ctrl + Shift + F 搜索你想修改的内容并修改即可。大部分能修改的配置都写在了 `app.config.ts` 下。\n\n```javascript title='app.config.ts'\nexport default defineAppConfig({ title: 'Protocol', description:\n'一个用于快速复现请求协议的Web开发模板。', author: { name: 'kuizuo', link:\n'https://github.com/kuizuo', qq: 'https://im.qq.com/', wx: 'https://wx.qq.com/',\n}, })\n```\n\n通过 `const appConfig = useAppConfig()` 获取配置对象数据。\n\n### **定义协议复现逻辑代码（重要）**\n\n这里以调用 Github 的 api 为例，因为业务相对简单，所以使用的是静态方法来调用，简单展示一下代码\n\n```javascript title='server/protocol/github/index.ts'\nimport { AHttp } from '@kuizuo/http'\n\nconst http = new AHttp({ baseURL: 'https://api.github.com' })\n\nexport class Github {\n\n  static async getUser(username: string) {\n    const { data } = await http.get<API.User>(`/users/${username}`)\n    return data\n  }\n\n  static async getRepos(username: string) {\n    const { data } = await http.get<API.Repo[]>(`/users/${username}/repos`)\n\n    return data\n  }\n}\n\n```\n\n我个人是习惯也喜欢将逻辑部分用 [class](https://es6.ruanyifeng.com/#docs/class) 的方式来编写，也推荐用这种去定义这些业务逻辑代码。这里我举个例子来说明，假设现在有一个博客网站，有登陆、获取博文列表、评论等功能。那么我会这么写\n\n```javascript\nimport { AHttp } from '@kuizuo/http'\n\ninterface User {\n  username: string\n  password: string\n}\n\nexport class Blog {\n  public http: AHttp\n  public user: User\n\n  constructor(user: User) {\n    this.http = new AHttp({ baseURL: 'https://blog.kuizuo.cn' })\n    this.user = User\n  }\n\n  async login() {\n    // login logic code\n  }\n\n  async getBlogList() {\n    // getBlogList logic code\n  }\n\n  async comment(id: number) {\n    // comment logic code\n  }\n}\n\n```\n\n定义完这些后，我只需要实例化一个对象 account，调用 login 方法即可登录，后续的获取博文列表与评论操作我只需要拿这个 account 来操作即可。\n\n```javascript\nconst account = new Blog({username: 'kuizuo', password: '123456'});\nawait account.login();\n\nconst blogList = await account.getBlogList();\n\nawait account.comment(1);\n```\n\n如果想换一个账号操作，就需要重新按照上面的方式实例化一个新的对象，拿这个对象操作即可。\n\n并且这种方式在迁移代码的时候尤为方便，可以直接将这份代码放到不同的 Node 项目中来运行。\n\n通常也是在这一流程中，会编写大量的类型代码，来完善整个项目，保证代码的健壮。通常我会在同文件下或者在 types 下定义 `.d.ts` 声明文件，通过声明文件与命名空间，无需导入即可全局使用类型。\n\n### 定义后端数据接口\n\n定义完复现协议的逻辑代码后，那么就到前后端数据交互部分了，首先定义后端的接口，由于上面我们已经定义好了协议复现逻辑代码，这边只需要导入使用即可。就像下面这样\n\n```javascript title='server/api/uesr/[username].ts'\nimport { Github } from '~~/server/protocol/github'\nimport { ResOp } from '~~/server/utils'\n\nexport default defineEventHandler(async (event) => {\n  const { username } = event.context.params\n\n  const user = await Github.getUser(username)\n\n  if (!user.login)\n    return ResOp.error(404, user.message ?? 'User not found')\n\n  await useStorage().setItem(`db:github:user:${username}`, user)\n\n  return ResOp.success(user)\n})\n```\n\n这一部分的代码建立在 Serverless Function 上，每一个接口都是以函数的方式对外暴露出去。这些代码会根据文件位置生成对应的路由，比如说上面的文件为 `server/api/user/[username].ts`，就映射为 `/api/user/:username`，前端请求 `/api/user/kuizuo` 通过`event.context.params.username` 便可以拿到 username 的值为 kuizuo。\n\n至此后端部分就暂以告告落。\n\n### 定义前端状态管理\n\n对于前端而言，肯定是需要全局管理一些数据状态的，这样能够在不同的组件间共享数据，并且需要持久化这些数据，以保证下次用户再次打开网页的时候无需向后台请求数据，pinia 持久化使用到了 [pinia-plugin-persistedstate](https://github.com/prazdevs/pinia-plugin-persistedstate) 插件。\n\n同时在状态管理中，会定义一些方法来调用后端接口。如下演示\n\n```javascript title='stores/user.ts'\nimport { useMessage } from 'naive-ui'\n\nexport const useUserStore = definePiniaStore('user', () => {\n  const user = ref<API.User | null>(null)\n  const repos = ref<API.Repo[]>([])\n  const message = useMessage()\n\n  async function getUser(username: string) {\n    const { data } = await http.get<API.User>(`/api/user/${username}`)\n\n    if (data.login) {\n      user.value = data\n      message.success('获取成功')\n    }\n    else {\n      message.error(data.message)\n    }\n  }\n\n  async function getRepos() {\n    const username = user.value?.login\n    const { data } = await http.get<API.Repo[]>(`/api/repo/${username}`)\n    repos.value = data\n  }\n\n  async function reset() {\n    user.value = null\n    repos.value = []\n  }\n\n  return {\n    user,\n    repos,\n    getUser,\n    getRepos,\n    reset,\n  }\n}, {\n  persist: {\n    key: 'user',\n  },\n})\n\n```\n\n这里的 http 是经过封装的，因为返回数据格式如：`{\"code\":200,\"data\":{},\"message\":\"success\"}` ，但对于业务逻辑而言，我们通常只需要关注 `data` 里面的数据，而请求的状态 code 与信息 message 则不是所要着重关系的对象。\n\n至于想要返回原数据，还是带有 code, message 的数据，因人而异，我更喜欢后者将数据格式规范化，这样我就能知道本次请求的状态结果，在响应拦截器中就能够进行预先处理。\n\n在 vue 组件中只需要使用演示如下\n\n```html title='components\\Demo.vue'\n<script setup lang=\"ts\">\nlet username = $ref('kuizuo');\nlet loading = $ref(false);\n\nconst userStore = useUserStore();\nconst user = $computed(() => userStore.user);\n\nasync function getUser() {\n  loading = true;\n  try {\n    await userStore.getUser(username);\n  } finally {\n    loading = false;\n  }\n}\n</script>\n```\n\n### 编写前端页面与组件\n\n这一部分自由发挥即可了，这里我是集成了 NaiveUI 与 Unocss，足够应对大部分的前端开发需求。没什么过多要说的了。\n\n### 流程总结\n\n整个开发流程就是这样的，如果我想要添加一个功能，用于获取 Github 用户已点的 Star 项目列表，那么按照上面流程将会清晰的实现出来。\n\n这里仅举调用 Github api 为例，想调用其他第三方的 api 都不成问题，本模板只提供一个这样的开发流程（形态）能够帮助快速实现 Web 站点开发，同时极易部署，做到敏捷开发。\n\n对比传统前后端分离的开发流程，这种开发流程可以说更加清晰，更加规范，更加高效。\n\n## 一些问题\n\n### 遇到图片防盗链怎么办?\n\n我的做法相对比较简单粗暴，直接在图片中添加`referrerpolicy='no-referrer'` 就像下面这样。\n\n```html\n<img src=\"src\" referrerpolicy=\"no-referrer\" />\n```\n\n如果你想要集成到 HTML 或者 CSS ，可以直接在 `<head>` 标签下添加如下代码.\n\n```html\n<meta name=\"referrer\" content=\"no-referrer\" />\n```\n\n参阅[Referrer-Policy - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy 'Referrer-Policy - HTTP | MDN (mozilla.org)')\n\n### 跨域问题\n\n几乎不会遇到跨域问题，因为所有的接口都相当于转发过一遍，不是由前端直接发送，而是后端接收到后，通过服务器来进行发送，然后将数据在返还给前端。\n\n## 考虑做的\n\n### 编写一个后台管理系统\n\n这个模板如果要实现鉴权是相对比较简单的，前后端配置[Middleware](https://v3.nuxtjs.org/guide/directory-structure/middleware 'Middleware') 即可实现。使用 cookie 和 token 都随意，甚至第三方的登录。\n\n但这时数据多了，难免需要去管理数据，不如专门为此编写一个后台管理系统，同时提供一个鉴权相关的功能。主要还是借助 ntrio 来开发，毕竟提供全栈开发能力，要实现只是时间开发的问题。\n\n### 使用 tauri 编译跨平台程序\n\n编译成跨平台程序有一个好处，就是所有的流量请求与接收都是存放在用户的机器中，就相当于传统的桌面应用开发。而部署在 Web 端请求流量的压力都将会来到服务器上，就避免不了用户量大，导致请求缓慢，甚至 ip 被封禁的问题。\n\n由于我暂且还不会 tauri 开发，也还不会 rust，所以这个功能估计得到寒假才有可能去实现了。electron 占用比较大的资源空间，不作为跨平台框架优先选择。\n\n## 写在最后\n\n这种开发形态自打我接触协议复现到前端开发我就考虑过，但奈何在没接触 ssr 框架之前，这种开发形态多半是需要前后端分离，要么使用模板语言，这样接口交互方面将会十分繁琐，开发效率过于低效。\n\n因此当我发觉 ssr框架的可行性后，我几乎整整花费了两周的时间在不断的探索与完善中，希望将其编写成一个我日后随时都会用到的模板，即写即用，极速上线。因为这样的开发场景对我来说太过于常见了，而很多时间就是因为没有一个相应的模板与工具库，代码总是东凑西凑，后续维护与测试总是花费不小的时间去解决。\n\n目前这种方案已有初步雏形，由于一些特殊的因素，我并未将已经写过的站点作为案例放在这上面作为演示，而将 Github api 作为演示，后续大概率会弄个案例展示供参考学习。\n\n后续我还是会不断去完善与维护该项目，并基于该项目去重构我的一些项目。\n\n**本模板仅仅是 web 模板，任何开发者用该模板做什么样的站点都与本人无关。仅作为个人技术专研，仅供学习参考。**"
    },
    {
      "id": "rollup-js-experience",
      "metadata": {
        "permalink": "/rollup-js-experience",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/rollup.js初体验.md",
        "source": "@site/blog/develop/rollup.js初体验.md",
        "title": "rollup.js 初体验",
        "description": "rollup.js",
        "date": "2022-10-18T00:00:00.000Z",
        "formattedDate": "2022年10月18日",
        "tags": [
          {
            "label": "rollup",
            "permalink": "/tags/rollup"
          },
          {
            "label": "webpack",
            "permalink": "/tags/webpack"
          },
          {
            "label": "utils",
            "permalink": "/tags/utils"
          }
        ],
        "readingTime": 3.43,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "rollup-js-experience",
          "title": "rollup.js 初体验",
          "date": "2022-10-18T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "rollup",
            "webpack",
            "utils"
          ],
          "keywords": [
            "rollup",
            "webpack",
            "utils"
          ]
        },
        "prevItem": {
          "title": "Protocol 协议复现模板",
          "permalink": "/protocol-template"
        },
        "nextItem": {
          "title": "深谈个人对新技术的看法",
          "permalink": "/talk-new-technologies-opinion"
        }
      },
      "content": "![rollup.js](https://img.kuizuo.cn/rollupjs.png)\n\n\n近期准备写一个工具包 [@kuizuo/utils](https://github.com/kuizuo/utils \"@kuizuo/utils\")，由于要将其发布到npm上，必然就要兼容不同模块（例如 CommonJS 和 ESModule），通过打包器可以很轻松的将代码分别编译成这不同模块格式。\n\n恰好 [rollup 3](https://github.com/rollup/rollup/releases/tag/v3.0.0 \"rollup 3\") 正式发布，也算是来体验一下。\n\n<!-- truncate -->\n\n### 为什么不是Webpack？\n\n`rollup` 的特色是 `ES6` 模块和代码 `Tree-shaking`，这些 `webpack` 同样支持，除此之外 `webpack` 还支持热模块替换、代码分割、静态资源导入等更多功能。\n\n当开发应用时当然优先选择的是 `webpack`，但是若你项目只需要打包出一个简单的 `bundle` 包，并是基于 `ES6` 模块开发的，可以考虑使用 `rollup`。\n\n**`rollup` 相比 `webpack`，它更少的功能和更简单的 api，是我们在打包类库时选择它的原因。**例如本次要编写的工具包就是这类项目。\n\n## 支持打包的模块格式\n\n目前常见的模块规范有：&#x20;\n\n- IFFE：使用立即执行函数实现模块化 例：`(function(){})()`\n\n- CJS：基于 CommonJS 标准的模块化\n\n- AMD：使用 Require 编写\n\n- ESM：ES 标准的模块化方案 ( ES6 标准提出 )\n\n- UMD：兼容 CJS 与 AMD、IFFE 规范\n\n以上 Rollup 都是支持的。\n\n## 使用\n\n官方有一篇文章 [创建你的第一个bundle](https://rollupjs.org/guide/en/#creating-your-first-bundle \"创建你的第一个bundle\") ，不过英文文档比较难啃，同时通过命令方式+选项的方式来打包肯定不是工程化想要的。\n\n### 配置文件\n\n所以这里所演示的是通过 `rollup.config.js` 文件，通过`rollup -c` 来打包。\n\n一个示例文件如下\n\n```javascript title='rollup.config.js'\nexport default {\n  input: 'src/main.js',\n  output: {\n    file: 'bundle.js',\n    format: 'cjs'\n  }\n};\n```\n\n执行 `rollup -c` 就会将`main.js` 中所引用到的js代码，通过`commonjs`的方式编写到`bundle.js`，就像这样。\n\n```javascript title='bundle.js'\n'use strict';\n\nvar foo = 'hello world!';\n\nfunction main () {\n  console.log(foo);\n}\n\nmodule.exports = main;\n\n```\n\n但是更多的情况下，是需要同时打包多个模块格式的包，就可以在output传入数组，例如\n\n```javascript title='rollup.config.js'\nexport default {\n  input: 'src/main.js',\n  output: [{\n    file: 'bundle.cjs',\n    format: 'cjs'\n  }, {\n    file: 'bundle.mjs',\n    format: 'esm'\n  }]\n};\n```\n\n便会生成 `bundle.cjs`, `bundle.mjs` 两种不同的模块格式的文件。同时在 `package.json` 中，指定对应模块路径，在引入时，便会根据当前的项目环境去选择导入哪个模块。\n\n```javascript title='package.json'\n{\n  \"main\": \"bundle.cjs\",\n  \"module\": \"bundle.mjs\"\n}\n```\n\n### 结合rollup插件使用\n\n不过更多情况下，rollup需要配置插件来使用。官方插件地址：[rollup/plugins: 🍣 The one-stop shop for official Rollup plugins (github.com)](https://github.com/rollup/plugins \"rollup/plugins: 🍣 The one-stop shop for official Rollup plugins (github.com)\")\n\n比如使用 [rollup-plugin-esbuild](https://github.com/egoist/rollup-plugin-esbuild \"rollup-plugin-esbuild\") 插件来使用[esbuild](https://esbuild.docschina.org/ \"esbuild\")（也是一个打包器，并且构建非常快）来加快打包速度。可以使用 [@rollup/plugin-babel](https://github.com/rollup/plugins/tree/master/packages/babel \"@rollup/plugin-babel\") 借助babel，编译成兼容性更强的js代码或者代码转换等等。\n\n以下是rollup+插件的配置示例，来源 [antfu/utils/rollup.config.js](https://github.com/antfu/utils/blob/main/rollup.config.js \"antfu/utils/rollup.config.js\") ，也作为本次工具包的配置。\n\n```javascript title='rollup.config.js'\nimport esbuild from 'rollup-plugin-esbuild'\nimport dts from 'rollup-plugin-dts'\nimport resolve from '@rollup/plugin-node-resolve'\nimport commonjs from '@rollup/plugin-commonjs'\nimport json from '@rollup/plugin-json'\nimport alias from '@rollup/plugin-alias'\n\nconst entries = [\n  'src/index.ts',\n]\n\nconst plugins = [\n  alias({\n    entries: [\n      { find: /^node:(.+)$/, replacement: '$1' },\n    ],\n  }),\n  resolve({\n    preferBuiltins: true,\n  }),\n  json(),\n  commonjs(),\n  esbuild({\n    target: 'node14',\n  }),\n]\n\nexport default [\n  ...entries.map(input => ({\n    input,\n    output: [\n      {\n        file: input.replace('src/', 'dist/').replace('.ts', '.mjs'),\n        format: 'esm',\n      },\n      {\n        file: input.replace('src/', 'dist/').replace('.ts', '.cjs'),\n        format: 'cjs',\n      },\n    ],\n    external: [],\n    plugins,\n  })),\n  ...entries.map(input => ({\n    input,\n    output: {\n      file: input.replace('src/', '').replace('.ts', '.d.ts'),\n      format: 'esm',\n    },\n    external: [],\n    plugins: [\n      dts({ respectExternal: true }),\n    ],\n  })),\n]\n\n```\n\n以下是对应的npm 安装命令\n\n```bash\npnpm i -D rollup @rollup/plugin-alias @rollup/plugin-commonjs @rollup/plugin-json @rollup/plugin-node-resolve rollup-plugin-esbuild rollup-plugin-dts\n```\n\n关于rollup更多使用，不妨参见 [rollup官方文档](https://rollupjs.org/ \"rollup官方文档\")，以及一些使用 rollup 来打包的开源项目。\n\n## 类似工具\n\n类似的工具还有 [webpack.js](https://webpack.js.org/ \"webpack.js\"), [esbuild](https://esbuild.github.io/ \"esbuild\"), [parceljs](https://parceljs.org/ \"parceljs\")\n\n不过就打包类库而言，并不要求过强的性能，有个相对简单的配置就足以，而 [rollup](https://rollupjs.org/ \"rollup\") 正是这样的打包工具。\n\n## 相关文章\n\n[【实战篇】最详细的Rollup打包项目教程](https://juejin.cn/post/7145090564801691684 \"【实战篇】最详细的Rollup打包项目教程\")\n\n[一文带你快速上手Rollup](https://zhuanlan.zhihu.com/p/221968604 \"一文带你快速上手Rollup\")"
    },
    {
      "id": "talk-new-technologies-opinion",
      "metadata": {
        "permalink": "/talk-new-technologies-opinion",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/lifestyle/深谈个人对新技术的看法.md",
        "source": "@site/blog/lifestyle/深谈个人对新技术的看法.md",
        "title": "深谈个人对新技术的看法",
        "description": "目前技术圈的发展速度可谓是有目共睹，尤其是前端，每隔一段时间就出新的技术，可以说让很多初学者非常畏惧，没有一个明确的方向不知道从何学起。",
        "date": "2022-10-15T00:00:00.000Z",
        "formattedDate": "2022年10月15日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "杂谈",
            "permalink": "/tags/杂谈"
          },
          {
            "label": "感悟",
            "permalink": "/tags/感悟"
          }
        ],
        "readingTime": 15.203333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "talk-new-technologies-opinion",
          "title": "深谈个人对新技术的看法",
          "date": "2022-10-15T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "杂谈",
            "感悟"
          ],
          "keywords": [
            "随笔",
            "杂谈",
            "感悟"
          ],
          "sticky": 6
        },
        "prevItem": {
          "title": "rollup.js 初体验",
          "permalink": "/rollup-js-experience"
        },
        "nextItem": {
          "title": "前端自动化测试",
          "permalink": "/frontend-automated-testing"
        }
      },
      "content": "目前技术圈的发展速度可谓是有目共睹，尤其是前端，每隔一段时间就出新的技术，可以说让很多初学者非常畏惧，没有一个明确的方向不知道从何学起。\n\n同时也有很多人，只局限于使用手头已掌握的技术，而不愿去尝试新技术。举个例子，如今 vue3 都已经正式发布，但仍还有停留在 vue2 不愿尝试 vue3 的开发者。而 java 都发布 18 版本了，可还有很多人都还使用着 java8，这种现象可以说是非常常见了。\n\n这里说说我个人编码经验与看法，**仅作为个人观点，没别的意思**。\n\n<!-- truncate -->\n\n熟悉我的人应该都知道，我对很多新鲜的技术有一种难以用言语表达的情感，又哭又笑。属于是那种看到感兴趣的就会开始尝试，在之前也许更强烈。\n\n驱使我去接触的原因无非就以下几点：\n\n- 开发体验、性能提升\n- 对已有技术的厌倦感和对新鲜事物的好奇心\n- 更多机会与方向\n- 对未来技术趋势有更好的了解\n\n## 写不完的代码\n\n首先要知道一点，在任何的软件开发迭代中都没有最终形态的代码。说白话就是代码都是不断更新的，永远写不出最好的代码。\n\n你能看到如今很多开源项目或者商业项目都在不断新增代码或者功能，除非作者不维护了，不然这份代码可以说写到世界末日。\n\n究其原因还是因为社会不断在发展，硬件升级，性能提升，不断的业务需求。毕竟人都在进步，社会难道还不能进步。所以必然会有新的技术出现，只是出现的时间快慢，与技术难点突破。\n\n## 开发体验、性能提升\n\n毋庸置疑，在购买方面，肯定是买新不买旧，同样的在技术（软件更新）方面也是则从用新不用旧。驱使软件和框架更新的原因也就是新增了某些功能（特性），对用户（开发者）的体验有所提升。一般而言比较少的会存在反向更新的操作，这里除了某些国产软件~~（如某信，某 Q 等等）~~\n\n就我对此的看法也是如此，假设一个开发工具启动花费了 5s 钟启动，而在它的最新版只需要 1s 钟就能够启动，你会选择更新尝试吗？。再比如一个框架原先的代码需要 10 行代码才能实现的功能，由于新版本提供一个语言级别的语法糖，使该功能只需一行。\n\n并且我对开发体验非常在意，尤其是不好用，或者不好配置的东西，我基本秉持能不用就不用的原则，像 vue2 与 webpack 就是这样，我跟愿意使用 vue3 或 vite。诸如此类的替换有非常多，便不一一列举。\n\n要我肯定毫不犹豫的更新去使用，但有些人可能对此提升不是很在意，又或者是升级的成本相对较高，也可能是因为这个开发工具（框架）他用的比较少，更新的意义自然就不大。\n\n## 对代码厌倦和对新事物的好奇心\n\n我写代码时常处于三分钟热度的状态，有些东西可能也就一开始的时候感觉比较新奇，然后就不了了之了。我对此的看法主要还是容易对代码产生厌倦感，不想写代码，不愿意学习。当厌倦感产生了，自然而然就放弃编写，也就是三分钟热度的状态。不过也能侧重体验一点，那就是肯定我对此不是那么感兴趣，既然不是那么感兴趣的东西，又何必在写下去呢？\n\n接着过段时间又遇到了一个新的技术，冲击了我的好奇心，开始尝试。 如此重复，就会发现啥都学了一点，但实际是啥都没学到。但至少，让我肯去学习，而不是在原地踏步。而从心底里就想接触的新鲜事物，每次接触到就能满足自己内心的好奇心，就这一点我便知足了。\n\n### 重构的艺术\n\n如果回头看看自己 1，2 年前写的代码，会发现原来自己也曾写过丑陋不堪的代码，也成为过自己所讨厌的样子。如果这份代码我将来还会用到，那么我就尝试去重构，也许在当时还不支持某种特性，代码就无法简化。基于现有的水平，便会发现很多代码都有可改善的地方，可以化繁为简。代码重构属于将杂乱摆放的东西，收拾的整整齐齐的样子。重构是在提升观赏度和舒适度的同时，还减少 bug 的诱发概率。\n\n> 在编程语言级别水平上，也就是我为什么会想去使用最新的版本（ES2022，TypeScript 4.9），即便是兼容性的问题，我也会去使用，就是因为能够满足我对代码的舒适度，这便足以。\n\n### 生态与解决问题方面\n\n我是很感谢新技术的出现，他实实在在的解决了一些我已有的痛点，提升了我的开发体验。当然它也让我踩了无数的坑，也折磨过我。但不可否认的是，我的自我解决问题的能力也在不断提升，如果我学的是一门比较流行的技术，那么我所遇到的问题，很有可能别人也遇到过，并将他的解决方案分享出来。而我就很容易根据报错描述找他的解决方案来解决我的问题。但在新技术下，用的人自然而然就少了，所分享的问题解决方案也就少了，所以在这种环境下，我就需要自行翻看源码，查阅文档，提出 issues 才能够解决问题。自然而然解决问题的能力也就有所提升。\n\n像流行框架能有这么有问题解决方案，就是因为强大的生态，同时这也是生态好处之一。\n\n> 因此也有很多人顾忌使用新技术，就是因为遇到问题不知如何解决。包括我也是，但通常我会观察一段时间，等成熟了我才去尝试，而不是直接上手，避免踩一些不必要且耗时的坑。\n\n### 总是活在舒适圈\n\n在圈内有着熟悉的环境，与认识的人相处，做自己会做的事，所以会感到很轻松、很自在。但是当踏出这个圈子的界限的时候，就马上会面对不熟悉的变化与挑战，因而感到不舒适，很自然的想要退回到舒适圈内。\n\n我在阅读英文博客的时候，我也时常感到不舒适，阅读不下去。我也很想回到舒适圈，使用翻译软件来翻译但是这样就会导致我非常依赖翻译软件，就间接失去了一次英文环境与英语能力的提升。\n\n长时间待在舒适圈，会让自己过得很舒服，但是却很难提升自己。不过想想也是，**提升的过程不就是苦尽甘来**。\n\n以目前来看有一种这样的学习趋势，别人学什么，当下什么技术火，就去学什么。我其实特别反感这种现象，也不推崇这种学习理念。我会做出我的解释：\n\n首先，什么技术会火就学什么，这固然没什么问题，如果一门技术没有热度，没有生态，那么学了的意义不大，一是难有长久稳定的技术发展，二是不能将技术变现。而绝大多数人之所以选择火的技术，有很大一点是因为有前人给他铺了很多“路”，如学习指南，思维导图，视频教程仿佛跟着学就能成为编程大牛似的。可一旦没有这些，就不知道该如何下手。始终都是跟着别人步伐学习，思维很难扩散出去。\n\n并且这种现象必然会导致内卷，首先看看国内的技术，Vue 和 Spring boot 的可以说 10 个 web 开发程序员中有 8 个技术栈是这套，比麻花还是卷了，可薪资呢？\n\n这里我并不想贴相关的薪资图片，你完全可以自行去了解，但是我可以肯定且直接告诉你，React 的薪资普遍会比 Vue 高上一截，而 Java 后端开发，如果技术只停留在 CRUD 的层面，工资普遍也高不了多少。\n\n**如果你不去拓展自身的技术栈，不多去了解一些未来的可能会火的技术，还停留在当下，活在舒适圈。那么薪资大概率不变，并且自身会有很大被劝退的概率。**\n\n与时俱进，这是我认为不断学习新技术，提升自身技术栈，非常重要的一点。**过得舒服，反而过得难受**\n\n## 更多的机会与方向\n\n技术更新迭代越来，也带来越多的机会，这对于接触前端的我感到尤为明显。假设当下又出了某某技术，那么必然会引起软件开发者的关注，于此同时就带来了维护者，贡献者，甚至是一些金主投资商。像 [Tailwind CSS](https://tailwindcss.com) 与 [Vercel](https://vercel.com/) 就是一个很好的例子，两个前端明星项目，有兴趣可以了解它们的故事。\n\n**不过这种机会在国内不太多见，反而在国外特别普遍。**\n\n但必须要承认的一个事实，如今技术发展过于迅猛，加上目前就业行情不容乐观，当别人了解过的东西，你却不了解，那么别人所能遇到的机会自然就比你多。说的难听点也就是没有对技术提升的想法，今后项目迭代的过程中使用到一些前沿技术就难以胜任。\n\n### 没有目标的学习，等同于乱学\n\n**没有一个明确的目标，学任何（新）技术都是乱学，充其量也就只比不学好一点。**\n\n这在我初学阶段尤为明显，我一开始也不清楚我以后会从事什么行业，可以说是什么都乱学一顿。在我的一篇年终总结 [2019.7-2020.7 编程年记](https://kuizuo.cn/2019.7-2020.7-log) 中可以说是尤为明显，尤其是在 [定一下明年的目标](https://kuizuo.cn/2019.7-2020.7-log#定一下明年的目标) 的段落中，最后我真正深入学习的也就是只有 Web 开发。\n\n我相信很多初学者也会遇到类似的问题，不知道学什么，想学好找工作的但是薪资不高，想学感兴趣的但又不知如何下手。说实话，要我回到当初，我也难以抉择。也有可能处于摆烂状态或是乱学一同，到头来啥都会一点点，但是又好像啥也不会的样子。\n\n这里我是奉劝先定一个短期的目标，为了这个目标我要去学习哪些技术知识。这里就说我未来一年的目标为例：我未来一年想写开源项目，为开源社区做一份微薄贡献，乃至从事开源行业。那么我就需要了解写开源我需要那些预备知识，例如 Github 的使用，项目规范，英文交流等对应开源项目的技能知识，这才是我所该学的，并且能够实实在在用到的，且对我未来有用的。\n\n## 对未来技术趋势有更好的了解\n\n**当你了解的技术越多，你就越能知道自己适合哪些技术。**并且当你去尝试过后，更能加深你对某个技术的信仰。\n\n在未来技术只会越来越多，因为当下要解决太多问题，有太多的业务需求开发。只要不断有需求，就不断会有技术更新。但技术更新必然是朝着好的方向去发展，即技术趋势方向。而了解的越多，能看到技术趋势也就更远，方向就更难偏移。\n\n像我目前就比较看好未来 js/ts 的发展，这也是使我从逆向和爬虫转到 Web 开发行业上，并且将会长期发展下去。\n\n但很多程序员就缺乏这种对**技术的认可**，甚至眼光比较浅薄，认为自己当下所学的就足以，可没却从未到真正的”外面”去看过。\n\n当有了对未来技术趋势的了解，自身就有相对明确的目标学习，而不是漫无目的学习，跟风学习。\n\n## 我是如何了解到这些技术的？\n\n也许有些人并不在意新技术是否学习，而是好奇我是如何知道这些技术的。这个问题非常好，我自己简单总结通过那些途径来获取到这些相关技术的新闻。\n\n主要有以下几种来源：\n\n- 多加技术群，不定时看群聊\n- **多刷技术大佬文章（推特），或者是技术公众号和掘金（最多的也是最有效的）**\n- 订阅一些技术周刊，或订阅某个项目\n\n没啥技巧，就靠刷技术文章，自然而然的了解也就越来越多了。\n\n尤其是第二点，也是我了解这些新技术的最直接途径。与其自己去主动了解新的技术，将刷抖音的时间改成刷技术文章，了解新技术就是分分钟的事情。可以说我写博客是因为这个契机，记录自己用到的技术的开发过程，并分享个人的开发体验，让更多人了解到这些新技术。\n\n## 面对新技术该怎么学？\n\n其实更多时候是比较在意如何去学一门新技术，而不是找一门新技术，当阅历多了，技术自然就了解的多。这里我分享下我对于新技术是如何起步与学习的。\n\n首先我会列举出我近期感兴趣的技术，这一步很关键，我当然不可能每个技术都去尝试一遍，时间精力根本不够。通常在我了解到这个技术的时候，比如文章与视频中，都会介绍到这个的优点与用法，这就足以了。\n\n但想要进一步的学习，还是得依靠实战项目（至少我都是通过实战项目来学习的），这时候我会看看手头的项目，看看有没有能够基于上面所列举出的新技术升级的想法，如果有的话，那正好就当重构与新技术的学习，这是最好的，也是相对比较节省时间的。\n\n但如果没有的话，我通常是会考虑另写一个项目，而这个项目可能是某个灵感的实现，也可能是久违想写的项目，或者是复刻某个感兴趣的站点，总之从上面所列举出来的技术中去选择一个来进行实践。在项目实践中去尝试使用这些新技术，哪怕只是实现一个简单的demo，也总比单纯的刷文档，看代码来的有效。\n\n**在项目实践中学习，永远是最直接也是最有效的**。回想你编写课设或者工作的项目，是不是在项目开发中进步的最快？如果这时候还有点时间紧迫感，进步反而会更快。（当然焦虑和压力也会随之提升）\n\n## 最后感悟\n\n关于本文，必然有引来一些不同看法与见解，每个人都有对不同事物的理解，我只是将我对新技术的看法，以文章的方式输出出来。本文并未带有任何的技术的偏见，我对任何技术都保持一视同仁，并且愿意去尝试学习。\n\n不必抱怨新技术发展的过快，自己来不及学，学不完。或者担心自己学的东西在未来将会淘汰，等同于白学。学习过程就是一个非常好的经验总结，当你回顾整个学习过程，其实都没有白学。反而多一次的学习过程，在未来学习新的东西时，学习的成效也会显著提升。保持不断学习，就永远来的及学习。\n\n更多时候，不应该只学如何使用，而是该想想这东西是在什么样的契机下如何被创造出来的，解决了什么问题。而这个问题在未来有没有什么更好的解决方案可替代，如果有更好的解决方案，那么必将又将发展出新的技术来更好的解决这个问题。这在我曾经的学习中，我是从未考虑到的，只专注于学习，而没去了解为什么。\n\n我是希望越来越多的新技术出现，无论它是为了解决什么，必然能解决某些人的一些需求，那么它的出现就很有意义。至于未来该技术和相关生态发展如何，不得而知。也没人敢笃定未来这个技术必定会火，就去学这门技术。绝大大多情况下都是比较看好这门技术，认为未来可期，同时又感兴趣，就开始学习并使用。"
    },
    {
      "id": "frontend-automated-testing",
      "metadata": {
        "permalink": "/frontend-automated-testing",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/前端自动化测试.md",
        "source": "@site/blog/advice/前端自动化测试.md",
        "title": "前端自动化测试",
        "description": "v2-45d641f2191559d4eff581d0607efd611440w",
        "date": "2022-10-06T00:00:00.000Z",
        "formattedDate": "2022年10月6日",
        "tags": [
          {
            "label": "frontend",
            "permalink": "/tags/frontend"
          },
          {
            "label": "test",
            "permalink": "/tags/test"
          }
        ],
        "readingTime": 8.033333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "frontend-automated-testing",
          "title": "前端自动化测试",
          "date": "2022-10-06T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "frontend",
            "test"
          ],
          "keywords": [
            "frontend",
            "test"
          ]
        },
        "prevItem": {
          "title": "深谈个人对新技术的看法",
          "permalink": "/talk-new-technologies-opinion"
        },
        "nextItem": {
          "title": "Gitea 与 Drone 实践",
          "permalink": "/gitea-drone-practice"
        }
      },
      "content": "![v2-45d641f2191559d4eff581d0607efd61_1440w](https://img.kuizuo.cn/v2-45d641f2191559d4eff581d0607efd61_1440w.jpg)\n\n如果你的项目要长期使用并维护的话，那么代码自动测试就非常有必要使用。因为没人能保证在修改代码后，不会引发其他额外 bug（功能失效，渲染失败），而在修改完代码后，跑一遍测试就能很大程度让开发者发现自己所修改的代码是否存在问题，是否会导致原有功能失效。\n\n尤其是在其他人接手这个项目时，诱发 bug 的概率自然也就更高（因为他有很大的可能不知道这部分代码的上下文的功能用途），所以这也就是为什么很多开源项目与大型企业的公司都会使用自动化测试，以及要求一定的代码覆盖率。\n\n当然如果项目不是长期维护的，那么完全没必要编写测试代码，这么做无疑是在浪费开发者的时间。\n\n<!-- truncate -->\n\n## 适合引入自动化测试的场景\n\n提前简单总结下**适合引入自动化测试的场景（优点）**：\n\n- 中长期项目迭代/重构（需要频繁的修改代码）\n\n- 准确定位代码问题，提高代码质量\n\n- 引用了不可控的第三方依赖，极易发生 bug（例：beta 版相关的包）\n\n测试的目的在于，**及时发现错误，提高代码质量和开发效率，避免存在 BUG 的代码发布上线造成损失**。\n\n自动化测试要注意的点\n\n- 并不是所有项目都适合引入自动化测试，反而会增加一定代码成本\n\n- 如果项目开发阶段还不稳定，那么手动测试效率会比自动化测试更好\n\n- 有些代码可能这辈子都不会在碰第二次，就没有编写自动化测试的意义\n\n**在代码编写阶段，建议只对重点功能进行测试，没必要一定追求过高的测试覆盖率**。注意，是编写阶段\n\n## 测试思想\n\n### TDD：Test-Driven Development（测试驱动开发）\n\n- TDD：Test-Driven Development（测试驱动开发）：TDD 则要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行\n\n### BDD：Behavior-Driven Development（行为驱动开发）\n\n- BDD：Behavior-Driven Development（行为驱动开发）：BDD 可以让项目成员（甚至是不懂编程的）使用自然语言来描述系统功能和业务逻辑，从而根据这些描述步骤进行系统自动化的测试\n\n## 自动化测试类型\n\n测试类型有以下几种：\n\n- **单元测试（Unit Testing）**\n\n  代码中多个组件共用的工具类库、多个组件共用的子组件等。通常情况下，在公共函数/组件中一定要有单元测试来保证代码能够正常工作。单元测试也应该是项目中数量最多、覆盖率最高的。\n\n- **集成测试（Integration Testing）**\n\n  测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期。集成测试是安全感较高的测试，能很大程度提升开发者的信心，集成测试用例设计合理且测试都通过能够很大程度保证产品符合预期。\n\n- **UI 测试 （UI Testing）**\n\n  对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。\n\n- **端对端测试（End-to-End Testing）**\n\n  将整个应用放到真实的环境中运行，包括数据在内也是需要使用真实的。\n\n关于测试框架，我主要使用 [Vitest](https://vitest.dev/) 与 [Cypress](https://cypress.io/)。这两个作为测试框架都相对比较新，并且性能与开发上会比 [Jest](https://jestjs.io/)，[Puppeteer](https://pptr.dev/) 来的好。本文的一些测试示例也是基于这两类框架之上。\n\n:::note\n\n其实还有个接口测试，不过这就不是前端要关心的内容了，所以就没列举在这上面。\n\n:::\n\n## 自动化测试的误区\n\n自动化测试和普通说的测试是有些不大一样的，有很多测试，其实都不能归类为前端自动化测试。这里我会举个例子来说明一下。\n\n在自动化测试来说有个要求：**自动化测试要的不是某次测试执行的是否通过，而是每次执行都必须通过。**\n\n怎么理解这句话呢：比方说我要测试获取博客列表的函数，假设实际的接口失效了，那么就会导致结果与预期不一致，就会导致代码测试不通过。既然不通过，那我就要去查看为什么不通过。当我点击这个单元测试的时，发现原来是后端接口失效了。可万一哪天这个接口突然好了，又或者发现刚刚原来没插网线导致的请求失败导致测试不通过。像这些 **不稳定因素** 在前端自动化测试中就会使用 mock 的方式，强制返回一定格式的数据给测试框架。到这里你可能会好奇，为什么要这么做？\n\n想想看，如果因为接口失效导致测试失败，是因为测试代码的问题吗？那跟测试代码有毛关系，明显是后端或者服务器的问题。我们要测试的是**获取博客列表的函数，而不是在测试接口（接口自动化测试）**。测试接口不应该是前端要做的事情。确保后端返回正确的响应结果，前端能够对这些数据进行处理渲染，这才是我们要做的。\n\n**每次测试都存在不可控的因素，就会导致每次测试结果都有可能不同，这就违背测试的意义了。** 所以这也就是为什么要数据 mock 的原因了。\n\n**给测试输入的值，在经过测试后，要保证输出的值与我们预期想要结果的值相同。**\n\n## 自动化测试到底在测试什么？\n\n其实目前前端有个尴尬的点，目前绝大部分实际业务项目里，前端的单元测试都没啥鸟用，UI 自动测试又太难搞。\n\n这就导致很多开发者不清楚到底要测试什么，导致对测试特别不重视，包括我一开始也是如此。看到很多文章都是在演示测试 1+1 =2，介绍测试框架，很少从实际项目中出发进行测试。不过原因无非就是实际项目写的少，就别说测试代码了。再不然就是写过的代码都不怎么维护（重构，阅读），自然的就不会去写测试了。\n\n不过确实没什么好举例的，因为太多东西可以写成单元测试了，比方说`formatTime.test.ts`, `param2Obj.test.ts`,`validate.test.ts`，从文件名就知道在测试什么了，就看开发者想不想写的问题了。\n\n可以到 [vitest-dev/vitest](https://github.com/vitest-dev/vitest 'vitest-dev/vitest') / [facebook/jest](https://github.com/facebook/jest) 等测试框架中的 example 中查看测试案例。\n\n关于 UI 测试和 e2e 测试，我非常推荐看看 cypress 的[Todo 示例](https://example.cypress.io/todo 'Todo示例')，测试的特别清楚，这里放张官方测试结果供参考。\n\n![](https://img.kuizuo.cn/image_a_B5FPFfJI.png)\n\n这里补充一句，vitest 是能做 UI 测试的，可以通过 [vuejs/test-utils](https://github.com/vuejs/test-utils 'vuejs/test-utils') 库来实现，但是 vitest 的运行环境是 nodejs，通过 jsdom 等库来模拟浏览器环境，而 cypress 是实实在在的运行在浏览器上，而且有可视化页面操作。这两者的区别也就是运行时环境的区别，有些实际场景对真实环境是有需求的，所以针对 UI 测试更多会选择像 cypress 这种直接运行在浏览器的测试框架。\n\n## 为何我开始重视起测试?\n\n在之前我根本不会在意测试，就连已有的测试代码我都不会尝试运行。就在前段时间我正重构我的一个项目时，但当我写了一大部分的代码后，我尝试运行发现有些功能失效了。于是我进一步的排查，终于找到我修改代码并还原成我原来的代码。\n\n假设一开始有份完整的测试代码，当我修改一部分代码后，跑一遍测试查看测试情况。发现没问题后，再开始下一步的代码工作，反复测试，直到最终重构完毕。**与其浪费代码的时间，不如将这些时间去用来完善测试代码**。不仅自己后续使用需要，到时候项目交付给别人的时，别人也不至于修改你的代码时兢兢业业。\n\n**究其原因是为了保证代码质量**。\n\n当然，虽说重视，但我也不会立马为已有的项目增加测试.耗时且费力不讨好。更多时候只会在准备重构的项目，或者是新项目上去增加测试代码。\n\n编写这篇文章主要解惑我自己对往常对测试的看法，也借此机会养成 TDD 模式的开发的习惯。\n\n## 参考文章\n\n[试试前端自动化测试！（基础篇） - 掘金 (juejin.cn)](https://juejin.cn/post/6844904194600599560)"
    },
    {
      "id": "gitea-drone-practice",
      "metadata": {
        "permalink": "/gitea-drone-practice",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Gitea 与 Drone 实践.md",
        "source": "@site/blog/program/Gitea 与 Drone 实践.md",
        "title": "Gitea 与 Drone 实践",
        "description": "使用 Gitea 搭建一个轻量级 git 私有仓库，并配置 Drone CI 来实现自动构建与部署。",
        "date": "2022-09-28T00:00:00.000Z",
        "formattedDate": "2022年9月28日",
        "tags": [
          {
            "label": "git",
            "permalink": "/tags/git"
          },
          {
            "label": "gitea",
            "permalink": "/tags/gitea"
          },
          {
            "label": "drone",
            "permalink": "/tags/drone"
          }
        ],
        "readingTime": 5.91,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "gitea-drone-practice",
          "title": "Gitea 与 Drone 实践",
          "date": "2022-09-28T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "git",
            "gitea",
            "drone"
          ],
          "keywords": [
            "git",
            "gitea",
            "drone"
          ],
          "description": "使用 Gitea 搭建一个轻量级 git 私有仓库，并配置 Drone CI 来实现自动构建与部署。"
        },
        "prevItem": {
          "title": "前端自动化测试",
          "permalink": "/frontend-automated-testing"
        },
        "nextItem": {
          "title": "模拟请求|协议复现方案",
          "permalink": "/request-protocol-scheme"
        }
      },
      "content": "之前搭建过 Gitlab，但是就只是搭建而已，并未实际使用，因为我大部分的代码还是存放在 [Github](https://github.com/kuizuo?tab=repositories) 上。\n\n并且大部分项目都是在 [Vercel](https://vercel.com) 上运行的（Vercel 是真好用），但是最近国内访问 vercel 情况不容乐观，貌似被墙了呜呜。然后 Gitlab 的资源占用非常严重，几乎占用了一半的服务器性能，可 [点我](https://kuizuo.cn/gitlab-code-management-environment#运行状态) 查看运行状态。与此同时，随着很多私有项目越来越多，使用 git 私有仓库以及 Vercel 部署，肯定不如自建私有 git 服务和自有服务器部署使用体验来好。\n\n于是就想搭建一个轻量级仓库，同时支持 CI/CD。经过一番的调研，决定使用 Gitea 和 Drone 作为解决方案。\n\n<!-- truncate -->\n\n## Gitea\n\n[Gitea](https://gitea.io/zh-cn/ 'Gitea') 是一个开源社区驱动的轻量级代码托管解决方案，后端采用 [Go](https://golang.org/ 'Go') 编写，采用 [MIT](https://github.com/go-gitea/gitea/blob/master/LICENSE 'MIT') 许可证.\n\n你可以在 [横向对比 Gitea 与其它 Git 托管工具](https://docs.gitea.io/zh-cn/comparison/#横向对比-gitea-与其它-git-托管工具 '横向对比 Gitea 与其它 Git 托管工具') 查看 gitea 与其他 git 工具的优势与缺陷。\n\n### 安装\n\n这里我选用 Docker 进行安装，安装文档可在[官方文档](https://docs.gitea.io/zh-cn/ '官方文档')中查看其他安装方式\n\n\n```yaml title='docker-compose.yml'\nversion: '3'\n\nnetworks:\n  gitea:\n    external: false\n\nvolumes:\n  gitea:\n    driver: local\n\nservices:\n  server:\n    image: gitea/gitea:1.17.1\n    container_name: gitea\n    environment:\n      - USER_UID=1000\n      - USER_GID=1000\n    restart: always\n    networks:\n      - gitea\n    volumes:\n      - gitea:/data\n      - /etc/timezone:/etc/timezone:ro\n      - /etc/localtime:/etc/localtime:ro\n    ports:\n      - '10800:3000'\n      - '2221:22'\n```\n\n根据自身需求配置 docker-compose.yml 内容。运行 `docker-compose up` 等待部署\n\n服务器防火墙与云服务安全组都需要开放端口才可访问，`服务器ip:10800`，将会出现如下界面\n\n![](https://img.kuizuo.cn/image_8ix-AMvt3t.png)\n\n**因为修改配置相对比较麻烦，所以在首次安装的时候，请根据实际需求进行配置安装。**\n\n### 修改配置\n\n假设要修改其中的配置的话，gitea 的后台管理面板是无法直接修改的。需要到 `/data/gitea/conf/app.ini` 中修改，具体修改的配置 参阅 [自定义 Gitea 配置 - Docs](https://docs.gitea.io/zh-cn/customizing-gitea/ '自定义 Gitea 配置 - Docs')\n\n:::caution 注意\n必须完全重启 Gitea 以使配置生效。\n:::\n### 迁移仓库\n\n从其他第三方 git 仓库迁移到 gitea，可以访问[https://git.kuizuo.cn/repo/migrate](https://git.kuizuo.cn/repo/migrate 'https://git.kuizuo.cn/repo/migrate') 来迁移仓库\n\n![](https://img.kuizuo.cn/image_sRQV5hAKUh.png)\n\n稍等片刻，取决于访问 github 仓库的速度。有可能还会迁移失败，就像下面这样。\n\n![](https://img.kuizuo.cn/image_X9IpG2q36n.png)\n\n所以可以申请访问令牌（Access Token），在 [New Personal Access Token](https://github.com/settings/tokens/new 'New Personal Access Token') 处创建。迁移成功后，如下图所示\n\n![](https://img.kuizuo.cn/image_Rug0AmD8GE.png)\n\n### 镜像仓库\n\n很大部分时间，gitea 只能作为我的副仓库，或者说 github 的镜像仓库。\n\ngitea 也提供镜像仓库的方案，官方文档[Repository Mirror](https://docs.gitea.io/en-us/repo-mirror/ 'Repository Mirror')\n\n![](https://img.kuizuo.cn/image_Q5IaHnKCYJ.png)\n\n## Drone\n\n由于 Gitea 并没有内置 CI/CD（持续集成/持续部署） 的解决方案，所以需要配置第三方的，这里推荐使用 Drone CI。\n\nDrone 是面向繁忙开发团队的自助服务持续集成平台。相对于常见的Jenkins，选中 Drone 的原因在于它非常简洁，不像 Jenkins 那样复杂，同时它拥有可以满足基本需求的能力，并且提供了许多实用的[插件](https://plugins.drone.io/)，如GitHub，Email，微信，钉钉等\n\n### 安装 \n\n由于我们使用了 gitea，所以 drone 中选择 gitea 来安装，这是官方文档 [Gitea | Drone](https://docs.drone.io/server/provider/gitea/ 'Gitea | Drone')，照着操作即可。\n\n需要安装 Server 和 Runner，一个是 Drone 的服务，另一个用于检测 Git 记录，以重新构建项目。\n\n这里贴下 drone 的 docker 配置（根据文档和自己部署的 git 服务配置来替换）。\n\n```yaml title='server'\ndocker run \\\n  --volume=/var/lib/drone:/data \\\n  --env=DRONE_GITEA_SERVER=https://try.gitea.io \\\n  --env=DRONE_GITEA_CLIENT_ID=05136e57d80189bef462 \\\n  --env=DRONE_GITEA_CLIENT_SECRET=7c229228a77d2cbddaa61ddc78d45e \\\n  --env=DRONE_RPC_SECRET=super-duper-secret \\\n  --env=DRONE_SERVER_HOST=drone.company.com \\\n  --env=DRONE_SERVER_PROTO=https \\\n  --publish=80:80 \\\n  --publish=443:443 \\\n  --restart=always \\\n  --detach=true \\\n  --name=drone \\\n  drone/drone:2\n```\n\n```yaml title='runner'\ndocker run --detach \\\n  --volume=/var/run/docker.sock:/var/run/docker.sock \\\n  --env=DRONE_RPC_PROTO=https \\\n  --env=DRONE_RPC_HOST=drone.company.com \\\n  --env=DRONE_RPC_SECRET=super-duper-secret \\\n  --env=DRONE_RUNNER_CAPACITY=2 \\\n  --env=DRONE_RUNNER_NAME=my-first-runner \\\n  --publish=3000:3000 \\\n  --restart=always \\\n  --name=runner \\\n  drone/drone-runner-docker:1\n```\n\n查看连接情况\n\n```bash\ndocker logs runner\n```\n\n执行完毕后，然后访问线上的 drone 服务，点击 CONTINUE 将会跳转到你的 Git 授权页面\n\n![](https://img.kuizuo.cn/image_rUdNHPlB73.png)\n\n点击应用授权，再次回到 drone，此时页面 Dashboard 列出了 gitea 的所有仓库（如果没有的话，可以点击右上角的 SYNC 来同步）。\n\n![](https://img.kuizuo.cn/image_TXWZgDOhrQ.png)\n\n\n\n## 实战\n\n上述只是安装了，我们还需要编写 `.drone.yml` 配置文件来告诉 drone 我们要做什么，编写过程与 Github Action类似。相关文档: [Pipeline | Drone](https://docs.drone.io/pipeline/overview/ 'Overview | Drone')\n\n### 部署前端项目\n\n这里就选用 [antfu/vitesse](https://github.com/antfu/vitesse 'antfu/vitesse') 作为演示。这里省略 clone 仓库的步骤。进入到自己的 gitea 仓库，然后添加 `.drone.yml` 文件，内容如下：\n\n```yaml\nkind: pipeline\ntype: docker\nname: ci\n\nsteps:\n  - name: install & build\n    image: node\n    commands:\n      - npm config set registry http://mirrors.cloud.tencent.com/npm/\n      - npm i -g pnpm\n      - pnpm i\n      - pnpm run build\n\n  - name: upload\n    image: appleboy/drone-scp\n    settings:\n      host:\n        from_secret: host\n      username:\n        from_secret: username\n      password:\n        from_secret: password\n      port: 22\n      command_timeout: 2m\n      target: /www/wwwroot/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}\n      source:\n        - ./dist\n```\n\n这里对 `.drone.yml` 配置进行详解：\n\n其中 build 这个不用多说，与 node 构建相关的，不过多介绍。\n\nupload 则使用[appleboy/drone-scp](https://plugins.drone.io/plugins/scp 'appleboy/drone-scp')插件，可以将构建出来的文件通过发送到服务器指定位置。在这里 source 对应就是构建的文件，target 则是要移动的位置，这里的 `/www/wwwroot/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}` 对应本项目为 `/www/wwwroot/kuizuo/vitesse`。此外 ssh 的 host，username，password 或 key，都作为环境变量（私有变量的方式传递，这在 drone 的控制台中可以设置）。\n\n由于每次构建可能需要删除原有的已部署的资源文件，那么可以使用 [appleboy/drone-ssh](https://plugins.drone.io/plugins/ssh) 插件来执行终端命令来删除，例如\n\n```yaml\nkind: pipeline\nname: default\n\nsteps:\n  - name: deploy\n    image: appleboy/drone-ssh\n    environment:\n        DEPLOY_PATH:\n            from_secret: /www/wwwroot/${DRONE_REPO_OWNER}/${DRONE_REPO_NAME}\n    settings:\n        host:\n            from_secret: host\n        username:\n            from_secret: username\n        password:\n            from_secret: password\n        port: 22\n        command_timeout: 2m\n        envs: [DEPLOY_PATH]\n        script:\n            - rm -rf $${DEPLOY_PATH}\n```\n\n具体就因人而异了，这里我仅作为演示。\n\n大致介绍完毕（其实已经介绍差不多了），有关更多插件可以参阅 [drone 插件](https://plugins.drone.io 'drone 插件')。这里开始演示，进入 drone 页面，找到仓库，默认情况下，所有仓库都处于未激活状态。\n\n![](https://img.kuizuo.cn/image_6XBrsAY8VE.png)\n\n点击 `ACTIVATE REPOSITORY` 根据选项选择，点击右上角的`NEW BUILD`选择分支，添加 drone 环境变量（私有变量），即上面的 from_secret 后面的内容（host，username，password），即可开始运行。\n\n![](https://img.kuizuo.cn/image_PAM6QQS1V_.png)\n\n静等 PIPELINE 执行完毕，结果如下\n\n![image-20220928152635955](https://img.kuizuo.cn/image-20220928152635955.png)\n\n此时打开宝塔，跳转到指定目录下，就可以看到构建的内容都已经放到指定位置了\n\n![image-20220928152725853](https://img.kuizuo.cn/image-20220928152725853.png)\n\n这时候只需要配置下 nginx，就能将页面展示到公网上，这里就不在这里赘述。当完成上述配置完毕后，每次只需要 pull request，drone 就会自动拉取 gitea 的代码，并开始执行`.drone.yml`中的任务。\n\n### 部署 nest 项目\n\nTODO。。。\n\n## 参考文章\n\n[【CI/CD】搭建 drone 服务，构建前端 cicd 工作流，实现博客的自动化打包并部署 - 掘金 (juejin.cn)](https://juejin.cn/post/7073380337766072350 '【CI/CD】搭建drone服务，构建前端cicd工作流，实现博客的自动化打包并部署 - 掘金 (juejin.cn)')\n\n[单机部署 CI/CD 进阶版：宝塔+gitea+drone | Laravel China 社区 (learnku.com)](https://learnku.com/articles/71333)"
    },
    {
      "id": "request-protocol-scheme",
      "metadata": {
        "permalink": "/request-protocol-scheme",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/模拟请求 协议复现方案.md",
        "source": "@site/blog/develop/模拟请求 协议复现方案.md",
        "title": "模拟请求|协议复现方案",
        "description": "模拟请求/协议复现 最佳实践方案",
        "date": "2022-09-25T00:00:00.000Z",
        "formattedDate": "2022年9月25日",
        "tags": [
          {
            "label": "http",
            "permalink": "/tags/http"
          },
          {
            "label": "protocol",
            "permalink": "/tags/protocol"
          }
        ],
        "readingTime": 16.53,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "request-protocol-scheme",
          "title": "模拟请求|协议复现方案",
          "date": "2022-09-25T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "http",
            "protocol"
          ],
          "keywords": [
            "http",
            "protocol"
          ],
          "description": "模拟请求/协议复现 最佳实践方案"
        },
        "prevItem": {
          "title": "Gitea 与 Drone 实践",
          "permalink": "/gitea-drone-practice"
        },
        "nextItem": {
          "title": "记 Github 学生认证",
          "permalink": "/github-student-certification"
        }
      },
      "content": "前段时间看了别人的一个写了羊了个羊刷次数网页版，但是 js 代码做了混淆，然后我的那个解混淆的工具还没适配上，短时间内还原不了。但由于是网页版，所以抓包数据还是能看到的，于是就准备复刻了一个（其实就没有也照样能写出来，因为确实没啥难度）。\n\n可在此体验：[7y8y.vercel.app](https://7y8y.vercel.app) （当然由于官方改动，现在功能已经失效了，但看看页面到不成问题，可能需要科学上网）\n\n原本我是不考虑写的，但是这背后所涉及到的技术以及技术框架我是特别想聊聊，加之以后我也有很大的可能会再写一个类似的刷 xx 的网页版，所以就考虑写一个类似的模板以便后续应用需求。\n\n相关模板：[https://github.com/kuizuo/protocol](https://github.com/kuizuo/protocol)\n\n与此同时，我也快有半年的时间没碰**协议复现**（网络通信协议重新实现，后文都简称协议复现）。我更喜欢说这个词，也有的人会说**模拟请求**，对应的关键词可能有 post 请求，抓包，发包，爬虫等等，但大致的意思是**抓取请求数据包，然后脱离宿主机（浏览器，手机），将抓取的数据包重新发送一遍**。\n\n你也可以理解成爬虫，但和爬虫相比，要做的不只是爬取数据，而是要基于某些请求包（或者说调用他人不提供的 api 接口，即爬取），来实现一定的功能。比如登录协议，签到协议，抢购协议，游戏封包等等，然后不依靠宿主机（即不用登录浏览器或者应用设备）就能实现诸如登录，签到等功能（在后台记录是有的）。因为这些都是基于网络通信协议的，只要抓包（抓取数据包），然后使用编程提供的网络请求模块来模拟请求，达到重新发包，重新请求的目的。在网页中有 http 协议，websocket 协议，而游戏中有相应的与游戏服务器对应的协议，邮件短信文件又是不同的协议（这里的协议都叫网络通信协议），所以我个人更倾向于称之为协议复现。\n\n所以要做协议复现，那基本上有一定的逆向功底和爬虫能力，还有网络通信协议相关的知识了。此次的开发也算是回顾下这些相关技术了。\n\n:::danger\n\n注：**本项目仅用于学习研究使用，请勿将本项目的任何内容用于商业或非法目的，否则后果自负。**\n\n:::\n\n<!-- truncate -->\n\n在这里容我多废话几句，讲一个我之前的开发经历，可以说这个开发经历算是这篇文章的由来。\n\n## 小区开门应用\n\n### 应用需求\n\n在之前住的一个小区，有个门禁系统，需要安装一个开门的 app（后文都称开门 app），然后注册一个账号到物业那边登记为户主或家庭成员。\n\n每次开门的时候，都需要打开这个开门 app，然后点击你要的开的门，接着门就打开了。或者叫保安开个门，总之就是特别麻烦，还不提供创建应用快捷方式。\n\n于是我想的是将接口数据“偷”了过来，将大门列表展示在前端上，然后点击对应的大门，然后将大门 id 转发给原 app 的服务器，就实现了开门的效果，也就是这个小区开门的网页版的核心逻辑。\n\n大致界面如下，展示小区的大门，点击即可开门（远程）\n\n![](https://img.kuizuo.cn/image_Zv0hXU8h1j.png)\n\n因为是网页版的，所以只需要在浏览器打开对应的网址，点击大门即可（主要还是这个 app 不提供桌面快捷方式，点击这个 app 还需要观看首屏广告，手机网页浏览器提供某个网站的快捷打开） 。此外他人也不用到物业登记，就能开门，对于一些朋友或者住户来说，省去了物业登记的繁琐。\n\n不过这个软件还是有挺多要注意的点：首先就是鉴权了，由于我当时主要目的是为了我自己和身边朋友，网站也没有特意发布到互联网上，所以就没做鉴权相关的，不然正常情况下是一定要做鉴权和调用记录的，以及 ip 白名单的。否则搞不好登录原 app 的账号直接因为调用过于频繁直接给禁用了；最主要的安全问题，这里的安全可不只是网站的安全，而是现实的安全。想想如果有一个可以随意进出小区大门的程序，那么任何人都可以进入这个小区，小区的公共设施，业主生活质量安全等等谁来保障？而且最主要所绑定的账号还是我的，万一小区真出了事，那么我的责任将会非常大。\n\n综合考量，这个应用是绝对不可能大肆发布到网上的。个人自用问题还是不大，因为这种调用量对服务器几乎没有什么压力。\n\n我的初衷也仅仅只是因为作为开发者的我，**降低了我点击开门的频率，免去登记的繁琐。**\n\n在当时我甚至想基于手机的 GPS 定位，来实现靠近小区自动开门。真羡慕当时我的一堆想法，但也遗憾当时没有去尝试实现这一个想法。\n\n### 开发\n\n这个应用就大致初衷就说到这了，接下来我要说说开发，这也就是本文说要的重点内容了。下面是我当时的项目结构：\n\n![](https://img.kuizuo.cn/image_7J7PhsdaQy.png)\n\n不难看出，这是一个前后端分离的项目，其中前端使用 uniapp 来开发一套代码多端运行，并且使用的是 Hbuilder 编辑器来开发。而后端就是常规的 Node 后端服务，使用的是 Express 框架。\n\n技术栈就介绍完毕，这里我要介绍整个流程。\n\n就说说获取大门列表和开门的两个接口请求：\n\n#### 获取大门列表\n\n后端接口：`http://localhost:3000/api/list`\n\n这个接口主要的作用就是获取原开门 app 的大门列表，这里简单介绍下代码\n\n```javascript\nrouter.get('/list', async (req, res, next) => {\n\n  // 模拟请求获取所有大门数据\n  let url = `https://xxx.com/api/getDoorList`\n  let data = {\n    xxx: {}\n  }\n\n  let json = await (await axios.post(url, data)).data\n\n  return json // [{...},{...},{...}]\n})\n```\n\n然后前端请求后，将列表数据渲染到页面上。\n\n#### 开门请求\n\n后端接口：`http://localhost:3000/api/open`\n\n```javascript\nrouter.get('/open', async (req, res, next) => {\n  let { id } = req.query\n\n  // 模拟请求开门\n  let url = `https://xxx.com/api/openDoorControl`\n  let data = {\n    id: id\n  }\n\n  let json = await (await axios.post(url, data)).data\n\n  return json // { \"code\": 0 ,\"msg\": \"success\" }\n})\n```\n\n这里的代码也仅仅只是作为演示，实际代码可不止这么简单，因为还需要涉及到登录，加密等等环节。\n\n我的前端页面访问地址是 http://localhost:5000，我需要 http://localhost:3000/api/list 和 http://localhost:3000/api/openDoor。\n\n可能有些人会问，为啥要后端服务，不直接在前端向开门 app 的服务器发送请求，然后将响应直接渲染到前端上。比如直接在前端代码中写 openopenDoor 函数\n\n```javascript\nasync function openDoor(id) => {\n\n  // 模拟请求开门\n  let url = `https://xxx.com/api/openDoorControl`\n  let data = {\n    id: id\n  }\n\n  let json = await (await axios.post(url, data)).data\n\n  return json // { \"code\": 0 ,\"msg\": \"success\" }\n})\n```\n\n这个疑惑在我初次想使用 web 端来实现协议复现的时候也考虑过，但浏览器不支持。这也是我下面所要说的\n\n### 同源策略 跨域\n\n一般用户的浏览器是有非常强的页面安全策略的，这里要说的就是同源策略，更细分点就是跨域，比如说 kuizuo.cn 这个站点，想要向 baidu.com 发送请求，请求是能够正常发送过去的，但是 kuizuo.cn 这个站点是接收不到任何数据。因为 kuizuo.cn 和 baidu.com 根本不是同一个网址，专业点说就是不同源，这种不同源的请求在浏览器，称为跨域请求。\n\n![](https://img.kuizuo.cn/image_QLEJFPTkb6.png)\n\n跨域请求如果请求的服务端不允许跨域，即响应协议头没有如下内容\n\n```text\naccess-control-allow-credentials: true\naccess-control-allow-headers: Content-Type, Authorization, X-Requested-With\naccess-control-allow-methods: GET, POST, PUT, DELETE, OPTIONS\naccess-control-allow-origin: *\n```\n\n浏览器会直接拒绝接收响应，但浏览器确实将请求发送给了服务端（打开控制台中的网络是看不到该请求的响应结果的）。\n\n跨域限制只存在于浏览器端，在其他环境下是不存在，请求都是能够发送出去，并且是可以接收到的。所以说为什么不在前端直接向原应用程序的服务器发送请求，罪魁祸首也就是**同源策略**。\n\n### 不支持修改协议头\n\n像 origin，reference，user-agents 等协议头是无法修改的\n\n```text\norigin: https://xxx.com\nreferer: https://xxx.com/api/test\nuser-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.42\n```\n\n而有些请求是会效验你的设备信息，来源地址，这些内容在浏览器中都写在协议头中，且浏览器不支持修改。使用浏览器来发送数据，无疑就是告诉服务器我是浏览器发送的。服务器判断来源不是自家的域名，那就直接拒绝响应。像防盗链就是检测 referer 。\n\n## 方案\n\n### 桌面端应用开发\n\n正是因为同源策略的限制，导致做协议复现时往往都会选择在本地中直接运行，比如使用易语言，python 等语言，将应用打包成 exe，然后跑在 window 系统上。\n\n![](https://img.kuizuo.cn/image_hyjd395YGI.png)\n\n这样的应用会有以下几点缺陷：\n\n- **易破解**：由于你的大部分核心逻辑最终都会进行编译打包成 exe，如果会些破解技术，恰好你不做任何防护手段，要破解你的程序非常容易。所以也就为什么很多 exe 程序（尤其是易语言）会带有 .vmp.exe 也就是 vmp 加壳，让程序很难被分析与破解。并且我就可以开启系统抓包，就可以看到应用程序模拟发送的请求数据包是什么。\n\n- **不易跨平台**：大多数的协议复现都是 exe 桌面应用程序，虽然也有安卓，但一般比较少。对于非 windows 用户或者说手头不方便用电脑的用户就很难体验到，并且还要特意安装一个应用，应用程序更新也需要重新安装。\n\n其实我说的这些，也算是绝大部分都是桌面应用程序的一个“通病”，但也不是没有优点，这在后面介绍后端应用开发的会做一个比较。\n\n### 后端应用开发\n\n另一种方式就是我自行搭建一个后端服务，然后将我要模拟的请求封装成一个接口供外部调用。只要我的这个后端服务允许跨域请求，那么我在浏览器或者在桌面端应用都能调用该接口。这样做调用者根本不可能知到你这个接口返回的数据的核心代码（除非他能渗透你的服务器）。\n\n![](https://img.kuizuo.cn/image_pVEHwQk1AJ.png)\n\n别人像要复现一个相同的协议请求的话，就必须自行抓包分析原站点的数据。而原站点可能做了一定的防护手段，例如验证码 浏览器指纹等风控手段。对于一般人而言，非常难破解。但是假设你能复现该请求的话，又非常不想让别人复现，那么自行搭建一个后端服务封装是最好的手段。而在此基础上，你可以做一些限制，比如接口封装，调用收费等等。\n\n这里我就不细说太多了，但也不是说没有缺点，甚至可以说这个缺点不比桌面端应用好到哪里：\n\n- **部署后端服务**：由于搭建了一个后端服务，那么就需要将后端服务部署到服务器上，部署后端服务是小事（但其实也很麻烦，有些写协议复现也不一定会后端开发），但是需要考虑用户的访问量，可能并发量大，那么请求就可能会阻塞导致响应速度变慢。\n\n- **请求限制**：从上流程图也不难看出，由于后端应用是部署在自己的服务器上，同时需要承载多个接口请求，然后模拟的请求都是由**自己后端应用服务器发送**的，这和桌面端应用不同。桌面端模拟的请求发送是用户自己的电脑，即用户自己电脑的 ip 地址，而后端应用服务器是服务器的 ip。一旦发送的请求多了，必然是会限制请求的，说白了就是将 ip 黑了，无法访问。要解决的最有效的办法就是换 ip，使用一些 ip 代理服务商，在请求 xx 服务器的时候使用动态 ip 来请求，检测被黑 ip 之后就换另一个 ip 来请求，但是这样就需要额外支付一些 ip 的费用。\n\n如果你需要**跨平台**（web 端，桌面端，手机端）并且想要**保护好你的模拟请求的代码**，那么就要考虑选择后端应用开发方案。\n\n像我一开始所介绍的小区开门网页版就是属于这一范围，这里就不再赘述其实现过程了。\n\n### 前端应用开发/反向代理（可行）\n\n假设你手头已经有了某个网站的大部分协议复现的代码接口，但是**不想搭建一个后端应用，却想要在前端中使用**。有没有解决方案，这也是有的。\n\n一种就是通过浏览器插件来允许任何请求跨域，或者本地开启 http 响应替换，将允许跨域的协议头加到响应中。但这些手段都需要使用者有一定的开发能力，对于普通用户而言就无能为力。\n\n目前绝大多数的网站应该都属于前后端分离的形式，后端只提供服务与接口的，提供的接口一般都带有 `/api/` 或 `/v1/` 等请求前缀。那么就可以将前端的请求，通过反向代理，转发到原应用服务器。\n\n反向代理其实也需要服务器，但是和后端应用相比，只需要配置一个 nginx，例如\n\n```text\nlocation /api/ {\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass http://要转发的服务器域名/api/;\n    index index.html index.htm index.jsp;\n}\n```\n\n举个例子，原后端应用通过 `http://target.com/api/user/me` 来获取目标服务器用户信息，如果我的前端应用 `http://example.com` 想要请求该接口必然会有跨域限制。但是通过反向代理，我的前端应用可以请求 `http://example.com/api/user/methods`，nginx 会判断 `url` 是否为 `/api/` 前缀，将请求转发给 `http://target.com/API`。说白了请求 `http://example.com/api/user/me` 就是在请求 `http://target.com/api`，同时还不会触发跨域，反向代理也是解决跨域的常用方法之一。\n\n![](https://img.kuizuo.cn/image_PO82fF6A5E.png)\n\n由于请求还是通过服务器发送的，所以后端应用开发有的限制，在反向代理也同样是有的。还有就是对于限制设备请求的服务器，使用这种方案就不行。。。\n\n同时这种开发方案对于多域名的应用来说可能就不是那么友好，因为就需要配置比较多的反向代理，同时只是将接口转发，接口的定制化就不是那么好。**只不过你可以原封不动的将原有的请求迁移到前端**，假设有了某个网站的大部分协议复现的代码接口，那么这样迁移将会特别方便。\n\n:::info\n\n提一嘴，如果使用跨平台开发的，如使用前端技术栈去编写桌面端应用（electron），编写安卓，小程序（uniapp，taro）的话，**除了小程序外，其他都没有跨域限制的**（具体还要看相应跨平台技术的限制）。\n\n:::\n\n### 方案选择\n\n最终选择那种开发方式还是取决对应的应用场景，没有绝对的方案，具体考虑哪种方案是需要考虑用户，代码安全，请求量，是否维护来考量了。\n\n写到这，可能对大多数人而言还是不懂，也很正常，因为这些内容都不算属于传统开发的范畴，甚至可以说是做 hui 产的利。\n\n## SSR框架\n\n我非常希望使用到浏览器的跨平台性，即多端运行，用户的设备只需要有一个浏览器能打开网页就能体验到。（这其实也算是我为什么学 web 开发的初衷了）\n\n但是在一开始所介绍的小区开门应用中，这样的开发体验其实并不友好。因为我既要编写前端应用还要编写后端服务，相当于两个项目。同时部署应用和传统部署没有特别大的区别，都需要一台服务器，很多时候都是浪费在部署上。\n\n而 SSR 框架可以算是后端应用开发和前端应用开发结合。能很好的解决上述存在的问题，并且也易于部署，下面我会细细道来。\n\n这里我选用的 Nuxt3 框架，羊了个羊刷次数网页版就是基于 Nuxt3 框架来开发的，并且使用 vercel 来进行部署。我手头还写过一个项目 [api-service](https://github.com/kuizuo/api-service)。\n\n首先在 SSR 框架，是有对应的后端服务引擎。像 Nuxt3 使用的是 [Nitro](https://nitro.unjs.io/)，而 Next.js 使用的是 koa。都提供了后端服务 API 的解决方案，同时这些都是服务都算是 `serverless function`（无服务函数），所以在编写与调用非常方便。\n\n此外基于 [Netlify](https://www.netlify.com/) 和 [Vercel](https://vercel.com) 这些 `serverless development` 平台，可以非常方便的部署 SSR 框架。同时内置 CI/CD，只需要提交 git commit 就能实现自动构建自动部署。\n\n最主要是的我恰好使用 Node.js 来做爬虫与api接口，因此后端复现接口也使用 js 来实现。\n\n为此我特意编写了一个 [Protocol 协议复现模板](/protocol-template) ，这里我就不在过多介绍该模板。\n\n## 总结\n\n协议复现能写非常多的程序，因为协议复现的大多数案例都是基于已有的应用服务上去实现的，而很多人的日常生活都使用这些已有的服务上。有些已有的服务可能对于一些人而言，体验不好，或者是有其他限制。因此就有人对这些已有的服务来进行“扩展”，来实现自己所定制化的需求。\n\n:::danger\n\n这里我需要谨言慎行，因为大多数的协议复现所请求的站点都是他人的站点，如果你的程序或人为控制不当，导致他人服务器崩溃，又或者是非法访问本不属于你所该访问的数据。因此很有可能会触发相关的法律，这里我就不细说了。\n\n:::"
    },
    {
      "id": "github-student-certification",
      "metadata": {
        "permalink": "/github-student-certification",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/reference/记 Github 学生认证.md",
        "source": "@site/blog/reference/记 Github 学生认证.md",
        "title": "记 Github 学生认证",
        "description": "记录本人 Github 学生认证艰辛过程与经验分享。",
        "date": "2022-09-06T00:00:00.000Z",
        "formattedDate": "2022年9月6日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "github",
            "permalink": "/tags/github"
          }
        ],
        "readingTime": 5.743333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "github-student-certification",
          "title": "记 Github 学生认证",
          "date": "2022-09-06T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "github"
          ],
          "keywords": [
            "随笔",
            "github"
          ],
          "description": "记录本人 Github 学生认证艰辛过程与经验分享。",
          "image": "/img/blog/github-success.png",
          "sticky": 1
        },
        "prevItem": {
          "title": "模拟请求|协议复现方案",
          "permalink": "/request-protocol-scheme"
        },
        "nextItem": {
          "title": "Strapi 实现用户注册与登录",
          "permalink": "/strapi-user-register-and-login"
        }
      },
      "content": "![](https://img.kuizuo.cn/github_copilot_ready.jpg)\n\n我个人是非常讨厌这些认证提交手续的，例如疫情健康报告，请假申请表等等，当然也包括这次 Github 学生认证。\n\n这也就是我为什么迟迟不认证 Github 学生的原因，其实说白了就是没必要。但就在前段时间 [github copilot](https://github.com/features/copilot/ 'github copilot') 不是内测结束了，然后要开始收费了，收费标准 一个月 $10 / 一年 $100。这费用对于我本不富裕的生活雪上加霜。而 coplot 对教育认证有免费资格使用，于是乎就有了此次较为艰辛的 github 学生认证。\n\n<!-- truncate -->\n\n## 开始认证\n\n介绍完故事背景后，就要开始认证了。\n\n能看到这篇的估计也是想要学生认证的，这里就将我的认证过程总结出来。\n\n### 1、不要科学上网\n\n如果开启科学上网的话，提交时 github 会根据 ip 来判断所提交的学校位置和 ip 地址是否相近，如果差的很远的话是直接认证失败，并提示\n\n> You appear not to be near any campus location for the school you have selected. If you are a distance learner then your school-provided academic affiliation documentation must state so.\n\n大致意思：您没有出现在您所选择的学校的任何校园附近。如果你是远程学习者，那么你的学校提供的学术联系文件必须说明这一点。\n\n也就是这一点，让我放弃我在老家认证学生认证的想法，而到开学才重新认证\n\n但如果不开启科学上网就有可能获取不了 Google 地图与最终提交，我的做法是修改 host，然后需要 Google 地图的时候开启科学上网，然后获取定位信息后再关闭，最后提交的时候没开启科学上网。\n\n### 2、学生认证资料\n\n#### 教育邮箱\n\n有的大学是没有教育邮箱的，就比如我的大学。但不用教育邮箱也是能认证成功的。（当然有的话反而更好通过）\n\n#### 学生证\n\n学生证学生卡这些都可以作为学生 ID 来认证的，不过在拍学生证之前一定要保证照片清晰，看情况决定时间水印，因为有可能会提示如下信息\n\n> Your document does not appear to include a date demonstrating current academic affiliation. For countries utilizing non-standard calendars, you may need to capture the original document beside one with a converted date. You may include multiple documents in your image, so long as they are legible.\n\n大致意思就是提交的资料没有当前时间认证，所以加个时间水印主要是为了这个。\n\n但不过我有个同学是新号，5 月 github 注册的时候提示要他学生认证，然后他就随手拍了一下学生证的照片提交上去就认证通过了。据他回忆当时认证的信息填的很随意，然后第一次就通过了。而反倒是我提交了好多次学生证都失败了，怎么说呢，可能看账号吧。\n\n#### 学信网在线验证报告\n\n假设你拍照提交学生证一直失败（我就是这样），那么还可以通过 [学信网](https://account.chsi.com.cn/passport/login '学信网') 的学信档案 [申请教育部学籍在线验证报告](https://my.chsi.com.cn/archive/bab/xj/show.action '申请教育部学籍在线验证报告')\n\n这个报告默认是中文的，但是 github 不一定认中文的，所以会拒绝。这时候就需要翻译成英文，但是在学信网申请英文在线报告需要额外 30 元，有效期 1 年。当然如果不想花这些钱，就想着是学生认证白嫖的话，也可以使用网页在线翻译，将内容翻译成英文，就得到了一份英文版的在线验证报告。而这个份报告是能通过的，我就是这样操作的。\n\n每次提交的文件都要求不同，因为 github 后台会对文件做认证，所以就需要多拍照，多截图，做到图片相似，但不相同。\n\n### 3、修改 github 个人信息\n\n如果你按照上面的操作提交了，但还是不通过，并且只有下面一条提示信息的话\n\n> You are significantly more likely to be verified if you have completed your [GitHub user profile](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/customizing-your-profile/personalizing-your-profile 'GitHub user profile') with your full name and a short bio.\n\n大致意思是，完善你的 github 个人账号信息（头像，昵称，简介），像我做的就是把昵称改成了我的真实姓名，简介就写我来自什么学校，热爱开源。就差最后大招把头像改成我的自拍照，背景是学校门口。当然 github 还算仁慈，最终还是没让我放出“大招”。\n\n然后我修改了个人信息，并又提交了几次后，就终于成功了！\n\n所以只出现了上面的一条提示，那么说明已经快要成功了，只不过 github 还要考核你的坚持程度，看你会不会放弃（我猜的）\n\n## 我的认证过程\n\n按照以上的步骤，我将演示一遍我的认证过程。\n\n1、登录 [github education](https://education.github.com/benefits) ，选择学生那个按钮。\n\n![image-20221010134753749](https://img.kuizuo.cn/image-20221010134753749.png)\n\n2、首次表单填写邮箱，学校，以及使用Github的目的。**表单所提交内容全都要使用英文**\n\n![image-20221010134942952](https://img.kuizuo.cn/image-20221010134942952.png)\n\n3、再次填写一个表单，首先是照片证明，也就是学生认证资料。这里是使用的是**学信网的在线证明英文翻译**，Proof Type 选择 Other (Example: Screenshot of school portal)，备注内容填写证明来源，例如：**这份证明来自中国高等教育学生信息网（学信网），以下是在线证明地址。。。**\n\n![image-20221010135500357](https://img.kuizuo.cn/image-20221010135500357.png)\n\n其次第二个表单，根据你的学校信息填写即可。**切记到这一步的时候请不要使用科学上课，最好使用学校的网络来提交。**\n\n![image-20221010135949606](https://img.kuizuo.cn/image-20221010135949606.png)\n\n4、点击Process my application 提交，等待结果即可。\n\n最终 Github 在今早发送邮箱告知我认证成功了！\n\n![](https://img.kuizuo.cn/github_eduction_success.jpg)\n\n只要你提供的学生信息真实有效，不断提交最终肯定是会成功的。在这认证期间我一共提交了 11 次请求。\n\n![](https://img.kuizuo.cn/image_n3x8Cm8kMv.png)\n\n期间收到的 Gtihub Education 邮箱信息如下：\n\n![](https://img.kuizuo.cn/github_eduction_eamil.jpg)\n\n最终也不负众望，在收到 github 通知的时候的，我就立马编写了这篇文章，记录了自己 github 学生认证的过程。\n\n如果你有幸看到这篇文章，并想要认证 github 学生资格，希望这篇文章有帮到你。\n\n## 感谢\n\n最终也是要感谢 Github 为广大开发者提供平台，让一群志同道合的人在上面分享并创造想法，同时也感谢这些默默为开源做出贡献的前人，不断为这个世界增添一丝色彩。"
    },
    {
      "id": "strapi-user-register-and-login",
      "metadata": {
        "permalink": "/strapi-user-register-and-login",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Strapi 实现用户注册与登录.md",
        "source": "@site/blog/program/Strapi 实现用户注册与登录.md",
        "title": "Strapi 实现用户注册与登录",
        "description": "Strapi 实现用户注册与登录",
        "date": "2022-09-03T00:00:00.000Z",
        "formattedDate": "2022年9月3日",
        "tags": [
          {
            "label": "strapi",
            "permalink": "/tags/strapi"
          },
          {
            "label": "nuxt",
            "permalink": "/tags/nuxt"
          },
          {
            "label": "next",
            "permalink": "/tags/next"
          }
        ],
        "readingTime": 3.933333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "strapi-user-register-and-login",
          "title": "Strapi 实现用户注册与登录",
          "date": "2022-09-03T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "strapi",
            "nuxt",
            "next"
          ],
          "keywords": [
            "strapi",
            "nuxt",
            "next"
          ],
          "description": "Strapi 实现用户注册与登录"
        },
        "prevItem": {
          "title": "记 Github 学生认证",
          "permalink": "/github-student-certification"
        },
        "nextItem": {
          "title": "pnpm monorepo实践",
          "permalink": "/pnpm-monorepo-practice"
        }
      },
      "content": "在官方博客 [Registration and Login (Authentication) with Vue.js and Strapi](https://strapi.io/blog/registration-and-login-authentication-with-vue-js-and-strapi-1) 中演示如何实现注册与登录。实际重点部分是 Strapi 的[角色和权限插件](https://docs.strapi.io/developer-docs/latest/plugins/users-permissions.html)，可以说这个插件让开发者不用再为项目考虑的用户登录注册与鉴权相关。\n\n此外这里有个在线示例可供体验：[Vitesse Nuxt 3 Strapi](https://vitesse-nuxt3-strapi.vercel.app)\n\n<!-- truncate -->\n\n## 创建 Strapi 项目\n\n这里省略创建 strapi 项目创建过程，具体可到 [Quick Start Guide](https://docs.strapi.io/developer-docs/latest/getting-started/quick-start.html) 中查看。创建完项目，并注册管理员账号后，打开管理面板，根据自己需求创建数据。下面会介绍下管理面板的一些操作（以下针对中文面板）\n\n### 角色列表\n\n打开 **设置 => 用户及权限插件 => 角色列表**\n\n![image-20220825131929320](https://img.kuizuo.cn/image-20220825131929320.png)\n\n默认有两个角色 Authenticated 与 Pubilc，都不可删除，其中还有一个 Admin 是我自己创建的角色，用于分配管理员的权限。\n\nAuthenticated 对应的也就是登录后的角色，即携带 **Authorization** 协议头携带 jwt 的用户。\n\n另一个 Pubilc 则是未授权用户，默认权限如下\n\n![image-20220825132235027](https://img.kuizuo.cn/image-20220825132235027.png)\n\n### 权限分配\n\n双击角色可以到权限分配页面，比方说我想给 Authenticated 角色分配 Restaurant 表中查询数据，就可以按照如下选项中勾选，并且勾选其中一个权限（增删改查）可以在右侧看到对应的请求 api 接口（路由）\n\n![image-20220825132716257](https://img.kuizuo.cn/image-20220825132716257.png)\n\n### 默认角色\n\n可以在 **设置 => 用户及权限插件 => 高级设置** 中分配默认角色，此外这里还可以配置注册，重置密码等操作。对于这些功能而言，传统开发就需要编写相当多的代码了，而 Strapi 的 [角色和权限](https://docs.strapi.io/developer-docs/latest/plugins/users-permissions.html) 插件能省去开发这一部分功能的时间。\n\n![image-20220825132948740](https://img.kuizuo.cn/image-20220825132948740.png)\n\n### 管理员权限\n\n在 **设置 => 管理员权限** 也可以看到角色列表与用户列表，不过这个只针对登录 strapi 仪表盘的用户，与实际业务的用户毫不相干。通俗点说就是数据库系统的用户与后台管理系统用户的区别。\n\n一开始登录面板创建的用户在 **设置 => 管理员权限 => 用户列表** 中可以看到，而通过api http://localhost:1337/api/auth/local/register 注册的用户则是在 **内容管理 => User** 中查看。\n\n## 使用 HTTP 请求用户操作（通用）\n\n这里先给出官方提供的注册和登录地址，分别是：\n\n[http://localhost:1337/api/auth/local/register](http://localhost:1337/api/auth/local/register)\n\n[http://localhost:1337/api/auth/local](http://localhost:1337/api/auth/local)\n\n分别可在 [Login](https://docs.strapi.io/developer-docs/latest/plugins/users-permissions.html#login) 与 [Register](https://docs.strapi.io/developer-docs/latest/plugins/users-permissions.html#registration) 中查看官方演示例子，例如\n\nimport Tabs from '@theme/Tabs'; \nimport TabItem from '@theme/TabItem';\n\n```mdx-code-block\n<Tabs>\n<TabItem value=\"login\" label=\"登录\" default>\n```\n\n```js {4}\nimport axios from 'axios';\n\n// Request API.\naxios.post('http://localhost:1337/api/auth/local', {\n    identifier: 'user@strapi.io',\n    password: 'strapiPassword',\n  })\n  .then((response) => {\n    // Handle success.\n    console.log('Well done!');\n    console.log('User profile', response.data.user);\n    console.log('User token', response.data.jwt);\n  })\n  .catch((error) => {\n    // Handle error.\n    console.log('An error occurred:', error.response);\n  });\n```\n\n```mdx-code-block\n</TabItem>\n<TabItem value=\"register\" label=\"注册\">\n```\n\n```js {4}\nimport axios from 'axios';\n\n// Request API.\naxios.post('http://localhost:1337/api/auth/local/register', {\n    username: 'Strapi user',\n    email: 'user@strapi.io',\n    password: 'strapiPassword',\n  })\n  .then((response) => {\n    // Handle success.\n    console.log('Well done!');\n    console.log('User profile', response.data.user);\n    console.log('User token', response.data.jwt);\n  })\n  .catch((error) => {\n    // Handle error.\n    console.log('An error occurred:', error.response);\n  });\n```\n\n```mdx-code-block\n</TabItem>\n</Tabs>\n```\n\n除了登录外，还有几个api可能还会用到如获取个人信息，重置密码，修改密码，发送邮箱验证等等。更多可到 [Roles & Permissions](https://docs.strapi.io/developer-docs/latest/plugins/users-permissions.html#authentication) 中查看\n\n通过 HTTP 这种方案可以说是最通用的了，不过有些框架还提供相应的模块来调用 Strapi。\n\n## Nuxt\n\n官方 Nuxt3 提供了 hooks 方案使用 Strapi。具体可看 [Nuxt Strapi Module](https://strapi.nuxtjs.org/)。Nuxt2 可看[这里](https://strapi-v0.nuxtjs.org/hooks)\n\n通过相应的 hooks 就可以实现登录注册以及数据增删改查的功能，演示例子可看 [Usage](https://strapi.nuxtjs.org/usage)\n\n这里有一份我创建的预设模板 [kuizuo/vitesse-nuxt3-strapi](https://github.com/kuizuo/vitesse-nuxt3-strapi)，一开始的示例也是基于这个模板来搭建的。不过目前 Strapi 对 TypeScript 支持不是那么友好，尤其在 window 下会出现无法运行的情况，详看这个 [pr](https://github.com/strapi/strapi/pull/14088)。所以目前 backend 使用 js 创建，然后增加 ts 相关支持的，所以有些 ts 支持可能不是那么友好。\n\n:::note\n\n原本我考虑的是使用 starter 方式来创建nuxt3 strapi项目，但是就在我创建完 starter 与 template 准备使用 `yarn create strapi-starter strapi-nuxt3 https://github.com/kuizuo/strapi-starter-nuxt3` 下载模板时，不出意外又出意外的报错了，由于这个报错也不好排查就暂时放弃了。\n\n总之又是一趟白折腾的经过。\n\n:::\n\n\n## Next\n\nNext 我暂未找到相关库可以像 Nuxt 提供 Strapi 的服务。不过 Strapi 官方有提供 [sdk](https://github.com/strapi/strapi-sdk-javascript)的方案来调用 strapi 服务，而不用发送 http 请求的形式来调用，具体可以到官方提供的 [sdk](https://github.com/strapi/strapi-sdk-javascript) 查看如何使用，这里不做演示。有如下两个SDK可供选择：\n\n[strapi/strapi-sdk-javascript](https://github.com/strapi/strapi-sdk-javascript) 官网\n\n[Strapi SDK (strapi-sdk-js.netlify.app)](https://strapi-sdk-js.netlify.app/) 社区"
    },
    {
      "id": "pnpm-monorepo-practice",
      "metadata": {
        "permalink": "/pnpm-monorepo-practice",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/pnpm monorepo实践.md",
        "source": "@site/blog/develop/pnpm monorepo实践.md",
        "title": "pnpm monorepo实践",
        "description": "使用 pnpm monorepo 实践",
        "date": "2022-08-29T00:00:00.000Z",
        "formattedDate": "2022年8月29日",
        "tags": [
          {
            "label": "pnpm",
            "permalink": "/tags/pnpm"
          },
          {
            "label": "monorepo",
            "permalink": "/tags/monorepo"
          }
        ],
        "readingTime": 5.38,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "pnpm-monorepo-practice",
          "title": "pnpm monorepo实践",
          "date": "2022-08-29T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "pnpm",
            "monorepo"
          ],
          "keywords": [
            "pnpm",
            "monorepo"
          ],
          "description": "使用 pnpm monorepo 实践"
        },
        "prevItem": {
          "title": "Strapi 实现用户注册与登录",
          "permalink": "/strapi-user-register-and-login"
        },
        "nextItem": {
          "title": "正被消磨殆尽的耐心",
          "permalink": "/patience-wearing-out"
        }
      },
      "content": "老早老早之前就听过 monorepo（单一代码库） 这个名词，也大致了解其出现的意义与功能。但奈何自己的一些小项目中暂时还用不上多项目存储库，所以迟迟没有尝试使用。\n\n但随着越来越多的开源项目使用 monorepo，现在不实践到时候也肯定是要实践的，这次实践也算是为以后的技能先做个铺垫了。\n\n<!-- truncate -->\n\n## 介绍\n\n前言铺垫这么多，就举个例子介绍下 monorepo 的应用场景，比如现在有个 UI 组件库的开源项目。\n\n既然是组件库，首先肯定要有组件库的代码吧，此外可能还有脚手架（CLI）或是工具库（utils）或者是插件要作为 npm 包发布，等等。\n\n如果是传统的开发，每个项目都作为单独的 npm 项目来发布引用，就需要创建多个代码仓库，即**多代码库（multirepos）**。很显然这样在开发以及代码仓库的协同上肯定有弊端，而 monorepo 正是解决这种问题，**将所有的项目在一个代码仓库中，即单一代码库（monorepos）**。\n\n这只是 monorepo 的一个应用场景例子，这里有一个更好的例子 [前端工程化：如何使用 monorepo 进行多项目的高效管理](https://juejin.cn/post/7043990636751503390)，更多可以参考使用 monorepo 的开源项目来了解。在 [这里](https://pnpm.io/zh/workspaces#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B) 可查看使用了 pnpm 工作空间功能的最受欢迎的开源项目。\n\n有篇文章推荐阅读 [5 分钟搞懂 Monorepo - 简书 (jianshu.com)](https://www.jianshu.com/p/c10d0b8c5581)\n\n这里还有份手册可供阅读 [What is a Monorepo? | Turborepo](https://turborepo.org/docs/handbook/what-is-a-monorepo)\n\n## 上手实践\n\n你可以 clone [https://github.com/kuizuo/monorepo-demo](https://github.com/kuizuo/monorepo-demo) 来查看本文示例代码仓库\n\n这里使用 pnpm 的 [workspace](https://pnpm.io/zh/workspaces) 来创建 monorepo 代码仓库，此外目前主流的还有 yarn workspace + [lerna](https://lerna.js.org/)，[nx](https://nx.dev/)，[turborepo](https://turborepo.org/)等等。\n\n### 项目结构\n\npnpm 内置了对单一存储库（也称为多包存储库、多项目存储库或单体存储库）的支持， 你可以创建一个 workspace 以将多个项目合并到一个仓库中。\n\npnpm 要使用 monorepo 的话，需要创建 pnpm-workspace.yaml 文件，其内容如下\n\n```YAML\npackages:\n  - 'packages/*'\n```\n\n其中 packages 为多项目的存放路径（一般为公共代码），pnpm 将 packages 下的子目录都视为一个项目。此外如果项目还有文档或在线演示的项目（这些不作为核心库），放在 packages 有些许不妥，就可以像下面这样来配置 workspace\n\n```YAML\npackages:\n  - packages/*\n  - docs\n  - play\n```\n\n像一开始所举例的代码仓库的项目结构如下\n\n```bash\nmonorepo-demo\n├── package.json\n├── packages\n│   ├── components          # 组件库\n│   │   ├── index.js\n│   │   └── package.json\n│   ├── cli                 # CLI\n│   │   ├── index.js\n│   │   └── package.json\n│   ├── plugins             # 插件\n│   │   ├── index.js\n│   │   └── package.json\n│   ├── utils               # 工具\n│   │   ├── index.js\n│   │   └── package.json\n├── docs                    # 文档\n│   │   ├── index.js\n│   │   └── package.json\n├── play                    # 在线演示\n│   │   ├── index.js\n│   │   └── package.json\n├── pnpm-lock.yaml\n└── pnpm-workspace.yaml\n```\n\n其中 packages 下存放的就是多个项目代码库，假设项目就叫 demo（因为到时候这些包是有可能要发布的，而名字就要保证唯一），那么项目的 package.json 如下演示：\n\n```json\n{\n  \"name\": \"@demo/components\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"type\": \"module\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@packages/utils\": \"workspace:^1.0.0\"\n  }\n}\n```\n\n### 安装依赖\n\n执行`pnpm install` 会自动安装所有依赖（包括 packages 下），所以我们肯定不会傻傻 cd 到每个目录下，然后执行`pnpm install` 来一个个安装依赖。\n\n假设现在我要为某个项目添加依赖，例如为 utils 模块添加 lodash 的话，按之前可能会 cd 到 utils 目录执行`pnpm add loadsh` ，其实完全不用，pnpm 提供 `--filter` 选项来指定包安装依赖，命令如下\n\n```bash\npnpm --filter <package_selector> <command>\n```\n\n例如：\n\n```bash\npnpm -F @demo/utils add lodash\n```\n\n> `-F`等价于`--filter`\n\n假设现在写好了 utils 模块，`@demo/components`准备使用 utils 模块，可以按照如下操作\n\n```bash\npnpm -F @demo/components add @demo/utils@*\n```\n\n这个命令表示在`@demo/components`安装`@demo/utils`，其中的`@*`表示默认同步最新版本，省去每次都要同步最新版本的问题。\n\n### 启动项目\n\n使用**node packages/component** （默认执行 index.js 文件）\n\n```bash\nnode packages/components\n\n```\n\n更好的选择是编写 npm scripts 就像下面这样：\n\n```json\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"dev\": \"pnpm -C play dev\",\n    \"docs:dev\": \"pnpm run -C docs dev\",\n    \"docs:build\": \"pnpm run -C docs build\",\n    \"docs:serve\": \"pnpm run -C docs serve\",\n  },\n```\n\n其中[ -C \\<path\\>](https://pnpm.io/pnpm-cli#-c-path---dir-path) 表示 在 path 下运行 npm 脚本 而不是在当前工作路径下。例如根目录下执行 `npm run docs:dev` 便会执行 `docs/package.json` `dev`脚本，同理`build`和`serve`也是一样。\n\n此外更多的可能会在根目录下创建 script 脚本，然后编写（编译，发布）脚本。\n\n## Turborepo\n\n在上面只是介绍了使用 pnpm workspace 来搭建一个 monorepo 的仓库，但很多时候还需要搭配适当的工具来扩展 monorepo， Turborepo 就是其中之一，利用先进的构建技术和思想来加速开发，构建了无需配置复杂的工作。\n\n这里就不做介绍，这篇 [🚀Turborepo：发布当月就激增 3.8k Star，这款超神的新兴 Monorepo 方案，你不打算尝试下吗？ - 掘金 (juejin.cn)](https://juejin.cn/post/7129267782515949575) 就非常值得推荐阅读。\n\n## 总结\n\n搭建一个 monorepo 的仓库其实挺简单的，但也并不是什么项目使用 monorepo 就好，想想看，所有项目和依赖都堆积在一起，那么项目启动速度必然不如单项目启动来的快。就比如一个博客项目，就完全不至于将博客细分为文章/评论/搜索等等划分，还不如统一将代码都直接写到 src 目录下。\n\n可以说当使用 monorepo 作为项目管理时，每个模块就相当于按照一个 npm 包发布的方式创建，而不是像 src/utils 那么随便了，而开源项目大部分都是要作为 npm 包的方式发布的，使用 monorepo 来管理多个项目自然也就再合适不过了。\n\n## 相关文章\n\n[5 分钟搞懂 Monorepo - 简书 (jianshu.com)](https://www.jianshu.com/p/c10d0b8c5581)\n\n[前端工程化：如何使用 monorepo 进行多项目的高效管理](https://juejin.cn/post/7043990636751503390)\n\n[pnpm workspace](https://pnpm.io/zh/workspaces)\n\n[🚀Turborepo：发布当月就激增 3.8k Star，这款超神的新兴 Monorepo 方案，你不打算尝试下吗？ - 掘金 (juejin.cn)](https://juejin.cn/post/7129267782515949575)"
    },
    {
      "id": "patience-wearing-out",
      "metadata": {
        "permalink": "/patience-wearing-out",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/lifestyle/正被消磨殆尽的耐心.md",
        "source": "@site/blog/lifestyle/正被消磨殆尽的耐心.md",
        "title": "正被消磨殆尽的耐心",
        "description": "在以前，我可以花费 4，5 个小时的时间专注于一件事情上，并且丝毫没有不耐烦的意思。而且这种状态能持续个好几天。例如拼个积木，拼个拼图，写个代码等等。专注个半天根本不成问题。",
        "date": "2022-08-15T00:00:00.000Z",
        "formattedDate": "2022年8月15日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "杂谈",
            "permalink": "/tags/杂谈"
          },
          {
            "label": "感悟",
            "permalink": "/tags/感悟"
          }
        ],
        "readingTime": 6.06,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "patience-wearing-out",
          "title": "正被消磨殆尽的耐心",
          "date": "2022-08-15T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "杂谈",
            "感悟"
          ],
          "keywords": [
            "随笔",
            "杂谈",
            "感悟"
          ]
        },
        "prevItem": {
          "title": "pnpm monorepo实践",
          "permalink": "/pnpm-monorepo-practice"
        },
        "nextItem": {
          "title": "Vite使用WebWorker",
          "permalink": "/vite-webworker"
        }
      },
      "content": "在以前，我可以花费 4，5 个小时的时间专注于一件事情上，并且丝毫没有不耐烦的意思。而且这种状态能持续个好几天。例如拼个积木，拼个拼图，写个代码等等。专注个半天根本不成问题。\n\n当然有很大一部分是因为兴趣，要让我做一件乏味的事，别说坚持了，开始可能都成一个问题。但现在的我对很多东西都难以提起兴趣，要是放在以往，都能让我兴奋个数天。可现在，很难。\n\n<!-- truncate -->\n\n不知为何，感觉专注一件事变得特别困难，总沉不下心来。总感觉一切东西不咋那么美好，都很乏味，难以提起内心仅留的一丝兴趣，总感觉自我内心好像变了个特别无趣的人。这也间接导致我的耐心也不在像之前那样，现在的我遇到一些繁琐的事情，比如写报告，办手续，做核酸等等，我都会感到十分厌烦。\n\n像之前如果有人问我代码相关的问题，即便是我没接触过的知识方面，我都愿意去尝试了解学习为他解答。可现在，问我不知道的东西，我张口就是不知道。就算我知道，我的回复也往往是丢给他一个相关链接，让他自己研究琢磨，仿佛在告诉他我极不耐烦的样子（当然也有可能是这类问题问的太多了）。之前打车哪怕师傅晚个 10 分钟来接送我都能接受，现在 3 分钟我就已经有点坐立不安了。\n\n对于这种耐心的转变，我自己都认为有点不太思议。我不知道是不是由于之前太过于耐心，然后种种环境下不断磨练中，导致耐心值不断的下降，最终导致在很多事情都感觉不耐烦，难以平静。\n\n## **耐心值下降**\n\n自我分析了耐心值下降的可能原因：\n\n### **提不起兴趣**\n\n说到兴趣，这可就不得不提起 5 年级开始就接触[手部极限运动](https://baike.baidu.com/item/手部极限运动/2431307)中的转笔，那也算是我第一个对其感兴趣的东西。期间不断在尝试其他的手指极限运动并持续坚持了整整 8 年，直到高考结束便退坑了。至于为何不再坚持下去，有很大原因是因为 QQ 被永久冻结导致一些社交圈失联，再加上当时假期一直在学习编程。可以说没有这些意外，我依旧会坚持我这持续这份爱好，并且会将其爱好当做一个我的吃饭的本事。\n\n目前仅余的手指极限运动也就只有转手机了。同样的对于游戏也不再有新鲜感去尝试，偶尔还会下载英雄联盟玩上熟悉的英雄回忆当年的高(下)光(饭)时刻（当然游戏方面也和 QQ 冻结连同游戏账号一并冻结有关）。\n\n在回到目前主业的编程在我接触了进 3 年内，期间踩的无数的坑，做着重复的业务需求，尤其是所感兴趣，但到头来却又不可完成。渐渐地不再有当初以往的热情，不再乐此不疲。即便完成了一个自我认为成就感爆满的事情，也容易在接下来几天的时间内消磨下去。\n\n当所感兴趣的东西太多，对于新事物就不再容易提起兴趣。\n\n人的耐心都是被一些自己感兴趣，但是又不可能完成的事，一点一点消磨殆尽的。\n\n### **过快的生活节奏**\n\n现在技术发展是真的快，有很多新的突破和发现。生活质量也在不断变好，但这也间接导致生活节奏过快，社会更加内卷。变化太快。现在的生活总让我感觉一天好像什么事情都没干，一从座位起来就已经是第二天的凌晨。前一秒还在想着吃什么晚饭，后一秒就到了吃夜宵的时刻。看视频也不再是原速播放，而是更快的 1.5 倍，甚至 2 倍速。原本可能要 2 个小时完成的东西，硬是被压缩到 1 个小时内完成。\n\n在这样的快节奏生活工作下，耐心值怎能不下降？又怎能静的下心来去完成任务？\n\n### **走神**\n\n在写代码任务的时候，有时候一个准备实现的功能好像之前实现过，然后去翻看之前的代码，然后就发现写的还不够好，虽然能用，但总归少些什么，于是就开始重构，然后慢慢的就偏离原本的工作流，导致大部分的时间都在重构该功能，而不是在原本的任务。不过这样也确实完善了该部分的代码，至少不是一次无意义的重构。\n\n有时候看到一些推荐类的文章或者视频，可能看到中间有一个之前没遇到过的新鲜玩意，然后就开始打开官网，然后去看相关示例。刷着刷着浏览器网页打开多了，哪里还会在意每个标签页的标题，早都给慢慢的标签挤的只剩 logo 了，这时候我大概率是直接整个浏览器关闭，在打开新窗口，而一开始的所推荐的内容，可能早已忘得一干二净了。\n\n但这样也确实加深了我中途对这玩意的印象和认知，但却让我也忘了一开始的本意。不过一生中要接触许许多多的新的美食，普通人哪里有精力和时间去一遍遍的尝试，要做的只是将自己能够吃到吃进嘴里，体会其中的美味这就足够了。对于任何新鲜事物的尝试也应如此。（有点扯远了）\n\n所以久而久之，往往越想专注的时候，越容易被细微的东西吸引注意力。专注不下去了，耐心也随之消磨下去。\n\n## **消磨耐心**\n\n可能是因为经历太多耐心的过程，耐心在无形之间被不断磨灭，最终在不断消磨下导致原本不厌其烦🙂的样子变的极其厌烦😣。\n\n在这过程中，耐心也实实在在的告诉我正在成长，也在警示我不该松懈。即便内心再怎么烦躁，所表现的也应心照不宣。\n\n消磨耐心的过程不妨是在打磨工具，将一个钝器打磨成一个利器。绝大多数人一开始的耐心与容忍程度都是非常高的，但随之不断的经历。而多数人的耐心自然也在不断地下降，往往成长的也就越多。\n\n**慢慢磨练一个人的耐心，才更能考验一个人的心智。**"
    },
    {
      "id": "vite-webworker",
      "metadata": {
        "permalink": "/vite-webworker",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/Vite使用WebWorker.md",
        "source": "@site/blog/develop/Vite使用WebWorker.md",
        "title": "Vite使用WebWorker",
        "description": "准备给我的一个 Vite 项目进行重构，其中一个功能(函数)要花费 JS 主线程大量时间，会导致主线程画面卡死，无法正常点击，直到该功能(函数)执行完毕而言。这样的用户体验非常差，于是就准备使用 WebWorker 对该功能封装。",
        "date": "2022-07-26T00:00:00.000Z",
        "formattedDate": "2022年7月26日",
        "tags": [
          {
            "label": "vite",
            "permalink": "/tags/vite"
          },
          {
            "label": "webworker",
            "permalink": "/tags/webworker"
          }
        ],
        "readingTime": 2.3766666666666665,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "vite-webworker",
          "title": "Vite使用WebWorker",
          "date": "2022-07-26T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "vite",
            "webworker"
          ],
          "keywords": [
            "vite",
            "webworker"
          ]
        },
        "prevItem": {
          "title": "正被消磨殆尽的耐心",
          "permalink": "/patience-wearing-out"
        },
        "nextItem": {
          "title": "KZ-API接口服务",
          "permalink": "/use-nuxt3-build-api-server"
        }
      },
      "content": "准备给我的一个 Vite 项目进行重构，其中一个功能(函数)要花费 JS 主线程大量时间，会导致主线程画面卡死，无法正常点击，直到该功能(函数)执行完毕而言。这样的用户体验非常差，于是就准备使用 WebWorker 对该功能封装。\n\n<!-- truncate -->\n\n## WebWorker 限制\n\n（1）**同源限制**\n\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\n\n（2）**DOM 限制**\n\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象。\n\n（3）**通信联系**\n\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。\n\n（4）**脚本限制**\n\nWorker 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n\n（5）**文件限制**\n\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（`file://`），它所加载的脚本，必须来自网络。\n\n综合以上限制，我所要重构的功能面临以下问题\n\n- 一些 window 下的函数，或者主线程下全局数据函数，无法共同\n- 无法读取本地文件，需要创建网络文件（如 Blob 或 Vite 导入）\n- Worker 线程和主线程通信要使用`worker.postMessage`与`self.addEventListener`来发送与监听数据。\n\n**所以在考虑使用 Worker 的时候就要考虑这个功能是否值得使用 Worker，能否使用 Worker 实现**\n\n## Vite 中使用 WebWorker\n\n这里先给出我的最优解，在 Vite 中[静态资源处理 ](https://cn.vitejs.dev/guide/assets.html)，其中可以[导入脚本作为 Worker](https://cn.vitejs.dev/guide/assets.html#importing-script-as-a-worker)\n\n```javascript title=\"main.js\"\nimport Worker from './test.worker.js?worker'\nconst worker = new Worker()\n```\n\n这个 worker 就是所要的 Worker 对象，接着就可以对象的 postMessage 与 onmessage 来数据通信，如\n\n```javascript title=\"main.js\"\nworker.onmessage = (e) => {\n  console.log('main.js', e.data)\n}\n\nworker.postMessage('hello from main')\n```\n\n```javascript title=\"test.worker.js\"\nself.addEventListener(\n  'message',\n  function (e) {\n    console.log('test.worker.js', e.data)\n    self.postMessage('hello from worker')\n  },\n  false,\n)\n```\n\n不过 Vite 还有[其他方式](https://cn.vitejs.dev/guide/features.html#web-workers)导入 Worker\n\n```javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url))\n```\n\n这种方式相对更加标准，但是如果worker并不是一个js文件，而是ts文件，并且还夹杂一些第三方的包，这种方式是有可能会失败，本人测试是这样的，所以推荐一开始的方式，也就是带有查询后缀的导入。\n\n在打包的时候将其实所用到引入的依赖合并成一个文件，如果打开开发者工具，可以在源代码面板的右侧线程中看到主线程，以及worker线程。\n\n## 参考文章\n\n[使用 Web Workers - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)\n\n[Web Worker 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2018/07/web-worker.html)"
    },
    {
      "id": "use-nuxt3-build-api-server",
      "metadata": {
        "permalink": "/use-nuxt3-build-api-server",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/KZ-API接口服务.md",
        "source": "@site/blog/project/KZ-API接口服务.md",
        "title": "KZ-API接口服务",
        "description": "基于 Nuxt3 的 API 接口服务网站，易于封装，调用，部署。",
        "date": "2022-07-20T00:00:00.000Z",
        "formattedDate": "2022年7月20日",
        "tags": [
          {
            "label": "nuxt",
            "permalink": "/tags/nuxt"
          },
          {
            "label": "vite",
            "permalink": "/tags/vite"
          },
          {
            "label": "vue",
            "permalink": "/tags/vue"
          },
          {
            "label": "ssr",
            "permalink": "/tags/ssr"
          }
        ],
        "readingTime": 15.186666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "use-nuxt3-build-api-server",
          "title": "KZ-API接口服务",
          "date": "2022-07-20T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "nuxt",
            "vite",
            "vue",
            "ssr"
          ],
          "keywords": [
            "nuxt",
            "vite",
            "vue",
            "ssr"
          ],
          "description": "基于 Nuxt3 的 API 接口服务网站，易于封装，调用，部署。",
          "image": "/img/project/kz-api.png",
          "sticky": 2
        },
        "prevItem": {
          "title": "Vite使用WebWorker",
          "permalink": "/vite-webworker"
        },
        "nextItem": {
          "title": "Next.js项目搭建与部署",
          "permalink": "/next.js-build-and-deploy"
        }
      },
      "content": "挺早之前就想写个 api 接口服务，封装下自己收集的一些 api 接口，以便调用，正好最近在接触 SSR 框架，所以就使用 [Nuxt3](https://v3.nuxtjs.org/) 来编写该项目。\n\n在线地址: [KZ API](https://api.kuizuo.cn)\n\n开源地址: [kuizuo/api-service](https://github.com/kuizuo/api-service)\n\n![KZ API](https://img.kuizuo.cn/KZ%20API.png)\n\n<!-- truncate -->\n\n如果你已经了解过 Nuxt3 与运行过程，那么可以直接跳转至 [实战](#实战)\n\n[Quick Start](https://v3.nuxtjs.org/getting-started/quick-start#new-project)\n\n```\nnpx nuxi init nuxt3-app\n```\n\n可能会安装不上 会提示 `could not fetch remote https://github.com/nuxt/starter`，大概率就是本地电脑无法访问 github，这时候科学上网都不一定好使，这里建议尝试更换下网络或设置 host 文件。\n\n安装完毕后，根据提示安装依赖与启动项目\n\n![image-20220714005704602](https://img.kuizuo.cn/image-20220714005704602.png)\n\n初始的 nuxt3 项目及其简单，甚至没有 page、components、assets 等目录。\n\n![image-20220714003726413](https://img.kuizuo.cn/image-20220714003726413.png)\n\n关于 nuxt3 本文不做过多介绍，本文只对部分进行介绍。nuxt 已经发布快 1 年了，相信外面很多相关介绍文章。\n\n## Nuxt3 介绍\n\n[What is Nuxt? ](https://v3.nuxtjs.org/guide/concepts/introduction#why-nuxt)\n\n### 自动导入\n\nnuxt.js 与 next.js 极其相像，但 nuxt 却精简许多，这归功于 nuxt 的[自动导入](https://v3.nuxtjs.org/guide/concepts/auto-imports)，这可以让你无需导入像 vue 中的 ref 等等函数，导入组件等操作，不过前提是代码文件位置要符合 nuxt 规范。如果你尝试使用过 vite 的一些自动导入插件，其效果是一样的，只不过 nuxt 都已经配置好，开箱即用。\n\n### 文件路由\n\npages 为 nuxt 中页面所存放的位置，会将 pages 目录下的文件(`.vue`, `.js`, `.jsx`, `.ts` or `.tsx`) 与路由映射，像`pages/index.vue` 映射为 `/`，然后在 app.vue 中通过`<NuxtPage/>` 来展示 pages。\n\n要注意，**pages 下的文件一定要有根节点**，不然在路由切换的时候可能会出现问题（事实上建议所以的 vue 组件都有根节点，虽说 vue3 允许多个根节点，但或多或少存在一定问题）\n\n至于[动态路由与嵌套路由](https://v3.nuxtjs.org/guide/directory-structure/pages)，文档说明的比较详细了，这里就不费口舌了\n\n### 服务引擎\n\nNuxt3 中的的 api 接口服务引擎使用的是[⚗️ Nitro](https://nitro.unjs.io/) 的 JavaScript 服务，使用的是[h3](https://github.com/unjs/h3)的 http 框架（相当于 hook 版的 http 框架），不过文档不是特别详细，很多东西都要琢磨。（这个框架是真的相对冷门，之前都未曾听闻过）\n\n关于 Nuxt3 的服务具体可以看 [Nuxt 3 - Server Routes](https://v3.nuxtjs.org/guide/features/server-routes/)，这里演示部分代码\n\n创建一个服务，创建文件`server/api/hello.ts`\n\n```typescript title=\"server/api/helloWord.ts\"\nexport default defineEventHandler((event) => {\n  return 'hello nuxt'\n})\n```\n\n请求 http://localhost/api/hello 便可得到`hello nuxt`，在 event 可以得到 req 与 res 对象。不过在 req 身上是获取不到 query 和 body 的，这里需要使用 h3 提供的 hooks，如`useMethod()`,`useQuery()`,`useBody()`来获取，例如。\n\n```typescript\nexport default eventHandler(async (event) => {\n  const body = await useBody(event)\n\n  return `User updated!`\n})\n```\n\n这与传统的 node 的 http 框架不同点就是 query,body 这些参数不是从函数的上下文(context)取，而是通过 hook 来获取，所以这就是我为什么我说这相当于 hook 版的框架。关于这些 api，可以[点我查看](https://www.jsdocs.io/package/h3#package-functions)\n\n### 数据获取\n\n定义完了接口，那必然是要获取数据的，nuxt.js 有四种方式来获取数据，不过主要就二种`useFetch`与`useAsyncData`，另外两种是其懒加载形式。\n\n像上面定义了 helloworld 接口就可以像下面这样使用\n\n```vue\n<script setup>\nconst { data } = await useFetch('/api/hello')\nconsole.log(data) // hello nuxt\n</script>\n\n<template>\n  {{ data }}\n</template>\n```\n\nuseAsyncData\n\n```vue\n<script setup>\nconst { data } = await useAsyncData('hello', () => $fetch('/api/hello'))\nconsole.log(data) // hello nuxt\n</script>\n\n<template>\n  {{ data }}\n</template>\n```\n\n至于 useAsyncData 与 useFetch 有什么区别的话，如果请求的是 url 资源，那么建议使用 useFetch，如果请求的是其他来源的资源，就使用 useAsyncData。可以说在请求 url 资源时，两者是等价的，如下\n\n```\nuseFetch(url) <==> useAsyncData(url, () => $fetch(url))\n```\n\n那么如何 SSR(服务端渲染)呢？ `nuxt3` 默认是全 `SSR` 的渲染模式，也就是说在上面的数据请求后就是 SSR 渲染，客户端接受到的也就是带有数据页面。\n\n如果要使用传统的客户端渲染只需要填加一个 options 的 server 参数为 false 即可，如\n\n```typescript\nconst { data } = await useFetch('/api/hello', { server: false })\n```\n\n自己尝试下将 server 切换，然后打开控制台->网络中查看 Fetch/XHR 中是否有和数据相关的请求便可知道是在服务端发送的请求数据，还是客户端发送的数据。\n\n## 实战\n\n### 模板\n\n这个项目所使用的模板是 [Vitesse for Nuxt 3](https://github.com/antfu/vitesse-nuxt3)\n\n![vitesse-nuxt3](https://img.kuizuo.cn/vitesse-nuxt3.png)\n\n该模板中集成了一些 vue 生态的相关模块(vueuse, pinia, unocss)，开发者可以不必自行封装这些模块。\n\n### 页面设计\n\n页面设计的话其实没啥好说的，主要使用到了原子类的一个框架[unocss](https://github.com/unocss/unocss)。\n\n### 接口转发\n\n这里我会以通过[每日一言](https://v1.hitokoto.cn/)的 api 例子来给你演示其功能实现，请求该 api 可以得到\n\n```json\n{\n  \"id\": 5233,\n  \"uuid\": \"9504a2a2-bab7-4c7d-b643-a6642ed5c55e\",\n  \"hitokoto\": \"人间没有单纯的快乐，快乐总夹带着烦恼和忧虑。\",\n  \"type\": \"d\",\n  \"from\": \"杨绛\",\n  \"from_who\": \"我们仨\",\n  \"creator\": \"a632079\",\n  \"creator_uid\": 1044,\n  \"reviewer\": 4756,\n  \"commit_from\": \"web\",\n  \"created_at\": \"1583786494\",\n  \"length\": 22\n}\n```\n\n这里创建`server/api/one.ts`文件\n\n```typescript title=\"server/api/one.ts\"\nexport default defineEventHandler(async (event) => {\n  const { type = 'text' } = useQuery(event)\n\n  const data = await (await fetch('https://v1.hitokoto.cn/')).json()\n  if (type = 'json') {\n    return data\n  }\n  else {\n    event.res.setHeader('Content-Type', 'text/html;charset=utf-8')\n    return data.hitokoto\n  }\n}\n```\n\n这样，这个接口就已经定义完毕了，此时访问 [/api/one](http://localhost:3000/api/one) 所得到的就是一句短语。默认状态下返回文本，如需要 json 数据等额外信息，则可添加`type=json`。例请求`/api/one?type=json`，得到的完整数据如下\n\n```json\n{\n  \"id\": 7173,\n  \"uuid\": \"49eff9ca-7145-4c5f-8e62-d3dca63537fa\",\n  \"hitokoto\": \"即使人生是一场悲剧，也应该笑着把人生演完。\",\n  \"type\": \"k\",\n  \"from\": \"查拉图斯特如是说\",\n  \"from_who\": \"尼采\",\n  \"creator\": \"Kyanite\",\n  \"creator_uid\": 8042,\n  \"reviewer\": 1,\n  \"commit_from\": \"web\",\n  \"created_at\": \"1614946509\",\n  \"length\": 21\n}\n```\n\n而这整个过程也就是其实也就是接口转发，将访问 `/api/one` 的请求转发给目标 url https://v1.hitokoto.cn/ 的过程，然后对其数据进行抽取和封装，最终展示给调用方。\n\n然而这只是完成了接口的转发，那么接口的文档又该如何实现呢？\n\n### 接口文档\n\n要存储接口文档的数据，就需要使用 CMS(内容管理系统)或者 Database(数据库)，一开始我原本打算使用`strapi`来作为 CMS，毕竟没尝试过`strapi`，而且 SSR 框架也会搭配`strapi`来使用，不需再自建后端。但就在我刷[官方模块](https://modules.nuxtjs.org/?category=CMS&version=3.x)的时候，无意间发现个官方模块 [content](https://content.nuxtjs.org/)。简单了解了一下，发现这个模块有点意思，并且能很简单的满足我当下的需求，于是就选择使用它。也可以使用官方提供的[codesandbox](https://codesandbox.io/s/github/nuxt/starter/tree/content)来尝试\n\n不过`content`能实现的功能比较有限，没有`strapi`那么丰富，有多有限呢，基本的 CURD 只能实现查，无法增删改（至少官方文档是没有提供相应的函数）。不过`content`也不用像`strapi`那样自建一个服务，可以说是贼简洁了。\n\n这里省略模块的导入的步骤，在根目录下创建 content 目录，目录下的文件可以是`markdonw`，`json`，`yaml`，`csv`。和 pages 一样，这里的文件都会映射对应的路由，不过这里需要映射的路由前缀是`/api/_content/query/`。举个例子\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs>\n  <TabItem value=\"json\" label=\"content/hello.json\" default>\n\n```json\n{\n  \"title\": \"Hello Content v2!\",\n  \"description\": \"The writing experience for Nuxt 3\",\n  \"category\": \"announcement\"\n}\n```\n\n  </TabItem>\n  <TabItem value=\"output\" label=\"output\">\n\n```js\n{\n  _path: '/hello',\n  _draft: false,\n  _partial: false,\n  title: 'Hello Content v2!',\n  description: 'The writing experience for Nuxt 3',\n  category: 'announcement',\n  _id: 'content:hello.json',\n  _type: 'json',\n  _source: 'content',\n  _file: 'hello.json',\n  _extension: 'json'\n}\n\n```\n\n  </TabItem>\n\n</Tabs>\n\n访问`/api/_content/query/hello`所得到的就是 output 的内容。\n\n这里只演示 json 数据，是因为该项目主要用到 json 数据来渲染，如果是 markdown 的话，还有一些自带的组件 ContentDoc 来展示 markdown 数据。所提供的功能可以说非常适合用于文档类，或者博客类的站点。\n\n回到该实战本身，来说明实际数据及其如何请求，上面的例子所对应的 api 文档数据如下\n\n```json\n{\n  \"id\": \"one\",\n  \"name\": \"一言\",\n  \"desc\": \"一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子\",\n  \"path\": \"/api/one\",\n  \"method\": \"GET\",\n  \"params\": [\n    {\n      \"name\": \"type\",\n      \"value\": \"json\",\n      \"type\": \"string\",\n      \"desc\": \"数据格式(text,json,img)\",\n      \"required\": false\n    }\n  ],\n  \"dataType\": \"text\",\n  \"example\": \"/api/one\"\n}\n```\n\n然后这些数据通过 content 提供的[queryContent()](https://content.nuxtjs.org/api/composables/query-content)来获取，这里来看其渲染页面`pages/apidoc/[id].vue`的部分代码\n\n```vue title=\"pages/apidoc/[id].vue\"\n<script setup lang=\"ts\">\nconst { data } = await useAsyncData(id, () => queryContent(id).findOne())\nconst { name, desc, params, path, method, returnType, example } = data.value\n\n// ...\n</script>\n```\n\n获取到数据，然后渲染到 vue 上，这些就不过多叙述了。\n\n### 接口限流\n\n假设现在上线了这些接口，但是不做任何限制，那么调用方就可以无限次调用获取接口，这对服务器压力来说是十分巨大的，所以就需要对接口进行限流。\n\n一般要做限流操作都需要涉及到中间件，在 Nuxt 中有[路由中间件](https://v3.nuxtjs.org/guide/directory-structure/middleware)，和[服务中间件](https://v3.nuxtjs.org/guide/features/server-routes#server-middleware) ，这里由于是要处理后端接口的，所以就需要使用服务中间。\n\n创建`server/middleware/limit.ts` 文件\n\n```typescript title=\"server/middleware/limit.ts\"\nexport default defineEventHandler(async (event) => {\n  console.log(`limit`)\n})\n```\n\n这时候，只要是 Fetch 请求都将打印`limit`，既然请求能拦截到，那限流就简单了（其实并不简单，因为这个 h3 的文档与相关库实在是少的可怜）。\n\n不过由于没有使用到用户鉴权等功能（在这个项目中也没打算上），所以限流的操作只有从 IP 的手段下手。这里我选用的是[node-rate-limiter-flexible](https://github.com/animir/node-rate-limiter-flexible)这个库，下面是实现代码\n\n```typescript title=\"server/middleware/limit.ts\"\nimport { RLWrapperBlackAndWhite, RateLimiterMemory } from 'rate-limiter-flexible'\n\nconst rateLimiter = new RLWrapperBlackAndWhite({\n  limiter: new RateLimiterMemory({\n    points: 1,\n    duration: 1,\n  }),\n})\n\nfunction getIP(req) {\n  return (\n    (req.headers['x-forwarded-for'] as string) || (req.socket?.remoteAddress as string)\n  ).replace('::ffff:', '')\n}\n\nexport default defineEventHandler(async (event) => {\n  const { req, res } = event\n\n  if (/^\\/api\\/[A-Za-z0-9].*/.test(req.url || '')) {\n    const ip = getIP(req)\n\n    try {\n      await rateLimiter.consume(ip)\n    } catch (error) {\n      res.statusCode = 429\n      return { statusCode: 429, statusMessage: '请求太快了,请稍后再试' }\n    }\n  }\n})\n```\n\n自行阅读代码即可，设置的限制是 1 秒内只能请求 1 条接口。\n\n### 接口缓存\n\n除了接口限流外，对于实时性不高的接口可以开启缓存，这样可以防止过度调用导致接口匮乏。并且对于重复调用的接口响应速度更快，性能更佳。\n\n可 nuxt 的中间件好像只能拦截用户端发送的请求数据，而服务端发送的给用户端的数据貌似无法拦截，也就无法在中间件中获取到数据或者处理数据了？\n\n是的，nuxt 的服务层并不像[nest](https://nestjs.com/)有 Middleware(中间件),Guards(守卫),Interceptors(拦截器)，而这里所要拦截的部分也就是 nest 中的 Interceptors。\n\n![img](https://docs.nestjs.com/assets/Interceptors_1.png)\n\n不过 nuxt 只提供了中间件，这够实现接口缓存的功能了，不过需要一些“技巧”，关于这个技巧我写过的一篇文章 [JS 函数 hook](/js-function-hook) 比较详细的介绍该技巧，这里简单说下。\n\n假设有个 add 函数，我并不想破坏 add 的参数与内部代码结果，但是我又像在调用 add 函数时，查看传入的参数，以及计算的结果，那该如何做？来看下面代码\n\n```javascript\nfunction add(a, b) {\n  return a + b\n}\n\nlet original_add = add\nadd = function () {\n  console.log('arguments', arguments)\n  let result = original_add.apply(this, arguments)\n  console.log('result', result)\n  return result\n}\n```\n\n首先重新定义了与 add 相同作用的函数，名为 original_add，然后将 add 修改，同时修改像成上面的代码。这时尝试调用 add 就可以发现输出了传入的参数及计算后的结果。\n\n知道了这个修改 add 函数的技巧，要拦截 nuxt 的服务端数据也就不难了。只需要将这里的 add 函数替换成 http 框架的返回函数即可，也就是`res.end()`。大致逻辑如下\n\n```typescript title=\"server/middleware/cache.ts\"\nexport default defineEventHandler(async (event) => {\n  const { req, res } = event\n\n  const original_res_end = res.end\n  res.end = function (...args: any) {\n    // 这里的args的第一个参数就是 res.end 调用的参数，即返回给客户端的数据\n    console.log(args)\n\n    // 最后可别忘了调用原始的 res.end，不然客户端一直处于等待状态\n    return original_res_end.apply(this, args)\n  }\n})\n```\n\n这里所使用到的缓存库是[lru-cache](https://github.com/isaacs/node-lru-cache)，其实现代码如下\n\n```typescript title=\"server/middleware/cache.ts\"\nimport type { ServerResponse } from 'h3'\nimport { defaultContentType } from 'h3'\n\nimport LRU from 'lru-cache'\n\nconst options = {\n  max: 500,\n  ttl: 1000 * 60 * 1, // 缓存1min\n  allowStale: false,\n  updateAgeOnGet: false,\n  updateAgeOnHas: false,\n}\nconst cache = new LRU(options)\n\nexport default defineEventHandler(async (event) => {\n  defaultContentType(event, 'text/plain; charset=utf-8')\n\n  const { req, res } = event\n  if (/^\\/api\\/[A-Za-z0-9].*/.test(req.url || '')) {\n    const key = req.url\n    const cached = cache.get(key)\n    if (cached) return res.end(cached)\n\n    const original_res_end = res.end\n    res.end = function (...args: any): ServerResponse {\n      const data = args?.[0]\n      if (data) {\n        cache.set(key, data)\n      }\n\n      return original_res_end.apply(this, args)\n    }\n  }\n})\n```\n\n现在缓存是实现了，但所有的接口都被强行缓存 1 分钟，像有些接口（如随机图片）要是也这样设定，那就失去了这个接口的实时性了（我明明要随机，你却偏偏返回都是同一张图片）。所以就要对不同的接口进行不同的接口缓存处理，这里就可以使用到上下文 context。\n\n定义接口代码\n\n```typescript {2} title=\"server/api/test.ts\"\nexport default defineEventHandler(async (event) => {\n  event.context.cache = { ttl: 1000 * 5 } // 缓存5s\n\n  // ... 其他代码 ...\n})\n```\n\n定义缓存代码\n\n```typescript title=\"server/middleware/cache.ts\"\n// ... 其他代码 ...\nif (data) {\n  if (context.cache) {\n    const options = context.cache\n\n    cache.set(key, data, options)\n  } else {\n    cache.set(key, data)\n  }\n}\n```\n\n这样就可以为不同的接口，设置不同的缓存配置。（不过这样还是不够优雅，其实可以上装饰器的，但是想了想这也非 AOP 设计，于是就没尝试了）\n\n### 异常捕获\n\n这个功能主要用途是有些接口可能失效了，就需要捕获这些异常接口信息然后停止或者修改该接口。如果要在每个接口上都定义 try catch，接口数量一多将难以维护，所以需要一个服务端全局异常捕获。\n\n不过目前 Nuxt3 还不支持捕获服务端的异常，这里是[官网说明](https://v3.nuxtjs.org/guide/features/error-handling/#errors-during-api-or-nitro-server-lifecycle)。所以该功能暂时未实现，后续也有可能通过 Test 来测试接口可靠性，而不是全局捕获异常接口。\n\n不过 Nuxt3 对客户端的错误处理做得比较好，有个[演示示例](https://v3.nuxtjs.org/examples/app/error-handling#error-handling)。\n\n### 后续功能\n\n由于 content 模块，以及 Nuxt3 后端服务的一些限制，导致一些功能就暂未实现，后续再考虑引入其他方案来实现\n\n- [ ] 接口计次\n- [ ] 接口分类\n- [ ] 代码示例\n- [ ] ip 白名单\n### 收集接口\n\n就此整个项目的核心功能就已经实现完毕了，接下来要做的就是收集 api 接口，写 api 文档了。然而这部分也是最头疼的部分，因为在互联网上很难有免费的资源。\n\n像大部分的 api 接口，如果数据来源不是自己的，名义上“免费”的，那大概率就是有限制，例如一天只能 100 条，1 分钟只能请求几次等等，而且这类接口多半是需要填写一个 app_ey 的参数。而需要登录才能获取，当然，你可以选择加钱来增加限额，那么就不再是免费的了。总之就是各种不方便\n\n如果真想实现免费无限制，那么数据来源只能在自己身上，至于数据来源如何转化成自己的，懂得都懂好吧。\n\n所以在本项目仅可能的收集一手文档的资源接口或是自行封装的功能接口，但也会存在一些调用别人封装过的接口，服务端的接口信息可自行在`server/api`中查看，由于一些接口的安全性而言，线上的部分接口代码并未公布，这很正常，因为我并不想泄露一些关键数据。\n\n如果接口调用有涉及侵权相关的还请直接联系作者删除。\n\n## 部署项目\n\n本地打包\n\n```sh\nnpm run build\n```\n\n等待打包完毕，将打包后生成的.output 文件夹放到服务器上（依赖都无需安装，.output 文件里有 node_modules），执行\n\n```sh\nnode .output/server/index.mjs\n```\n\n即可运行项目，或者也可以使用 pm2，总之和常见的 node 部署没什么差异。\n\n此外也可部署到云提供商，像 AWS，Netlify，Vercel 等，所支持的[服务商](https://v3.nuxtjs.org/guide/deploy/presets#supported-hosting-providers)\n\n## 坑点\n\n### 打包失败\n\ncherrio中的parse5包无法打包至生成环境，提示如下\n\n```\nWARN  Could not resolve import \"parse5/lib/parser/index.js\" in ~\\.pnpm\\hast-util-raw@7.2.1\\node_modules\\hast-util-raw\\lib\\index.js using exports defined in ~\\parse5\\package.json.\n```\n\n我猜测是因为hast-util-raw包和cheerio的parse5冲突，而nuxt服务端的nitro在用rollup打包时没有将两者冲突部分合并，而是选择前者，这就导致生产环境下cheerio无法使用。我尝试搜索没有得到一个很好结果，而我的解决方案是降级cherrio版本至0.22.0，因为这个版本中没有引入parse5。\n\n### 版本切换\n\n在我最终准备上线的时候，发现nuxt又有新版本了，于是我将项目从rc.4升级到rc.6，然后再次测试的时候，发现在动态路由页面切换的时候，无法正常的向后端发送请求，甚至都监听不到路由变化，相当于页面被缓存了。\n\n其实这也侧面说明了，目前 Nuxt3 的兼容性是比较差的。\n\n实际上还有一些，不过解决相对比较迅速，就没写上。\n\n## 总结\n\n体验了一周的 Nuxt3，整个的开发过程不敢说特别顺利，因为存在一定的兼容和Bug。目前 Nuxt3 的目前还处于 rc 版，实际项目还得考虑上线。不过个人还是非常推荐 Nuxt 这个框架，在代码编写与开发体验上实在是太香了，不出意外后续的 web 项目都会采用 Nuxt3 来构建，期待正式版的发布。"
    },
    {
      "id": "next.js-build-and-deploy",
      "metadata": {
        "permalink": "/next.js-build-and-deploy",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Next.js项目搭建与部署.md",
        "source": "@site/blog/program/Next.js项目搭建与部署.md",
        "title": "Next.js项目搭建与部署",
        "description": "官方文档 Getting Started | Next.js (nextjs.org)",
        "date": "2022-07-13T00:00:00.000Z",
        "formattedDate": "2022年7月13日",
        "tags": [
          {
            "label": "next",
            "permalink": "/tags/next"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          },
          {
            "label": "ssr",
            "permalink": "/tags/ssr"
          },
          {
            "label": "vercel",
            "permalink": "/tags/vercel"
          }
        ],
        "readingTime": 7,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "next.js-build-and-deploy",
          "title": "Next.js项目搭建与部署",
          "date": "2022-07-13T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "next",
            "react",
            "ssr",
            "vercel"
          ],
          "keywords": [
            "next",
            "react",
            "ssr",
            "vercel"
          ]
        },
        "prevItem": {
          "title": "KZ-API接口服务",
          "permalink": "/use-nuxt3-build-api-server"
        },
        "nextItem": {
          "title": "写一个VSCode扩展",
          "permalink": "/vscode-extension"
        }
      },
      "content": "<!-- truncate -->\n\n官方文档 [Getting Started | Next.js (nextjs.org)](https://nextjs.org/docs/getting-started)\n\n## [安装](https://nextjs.org/docs/getting-started#automatic-setup)\n\n```sh\nnpx create-next-app@latest --ts\n# or\nyarn create next-app --typescript\n# or\npnpm create next-app --ts\n```\n\n运行\n\n```\nnpm run dev\n```\n\n访问 http://localhost:3000\n\n## 项目结构\n\n![image-20220712030637300](https://img.kuizuo.cn/image-20220712030637300.png)\n\n| 文件           | 内容                 |\n| -------------- | -------------------- |\n| pages          | 页面文件             |\n| pages/api      | api 数据接口         |\n| public         | 静态资源文件         |\n| styles         | 样式文件             |\n| next-env.d.ts  | 确保 typescript 支持 |\n| next.config.ts | next 配置文件        |\n\n## 路由\n\nnextjs 有一个基于页面概念的文件系统路由器，存放在 pages 下`.js`, `.jsx`, `.ts`, `.tsx` 文件都将作为组件，即**文件路径 → 页面路由**，例如这里的 index.tsx 映射为 index，`pages/about.js` 将映射为 `/about`。\n\n同时还支持动态路由，创建`pages/user/[id].tsx`文件，然后访问`user/1`，`user/2`\n\n```tsx title=\"[id].tsx\"\nimport { useRouter } from 'next/router'\n\nconst User = () => {\n  const router = useRouter()\n  const { id } = router.query\n\n  return <div>User id:{id} </div>\n}\n\nexport default User\n```\n\n此时访问 http://localhost:3000/user/1 便可得到 `User ID: 1`\n\n在 router 对象下没有 param 属性，都是存放在 query 参数中，例如访问 user/1?username=kuizuo，此时的 query 值为 `{username: 'kuizuo', id: '2'}`\n\n:::tip\n\n不过这里有个比较有意思的点，如果你在上方代码中使用 console.log 打印 query 的话，在 vscode 中会打印出空对象`{}`，而在浏览器中会打印一次空对象，一次真实的 query 对象（并且打印两遍）\n\n![image-20220712191356587](https://img.kuizuo.cn/image-20220712191356587.png)\n\n:::\n\n## 数据渲染\n\n如果你打开控制台，查看所返回的页面，你会发现响应中只有 User id:，这不就和 react 的 CSR(客户端)渲染没有区别吗，是的，确实是这样。因为上一部分的代码，并且从输出 query 也可以看的出来而不是 SSR(服务端)渲染。首先我要展示一下两者渲染的代码\n\n### CSR 客户端渲染\n\n```tsx title=\"[id].tsx\"\nimport { useEffect, useState } from 'react'\nimport { useRouter } from 'next/router'\n\nconst User = () => {\n  const router = useRouter()\n  const { id } = router.query\n\n  const [data, setData] = useState({\n    username: '',\n    email: '',\n  })\n\n  useEffect(() => {\n    fetch(`https://jsonplaceholder.typicode.com/users/${id}`)\n      .then((res) => res.json())\n      .then((data) => {\n        setData(data)\n      })\n      .catch((err) => {})\n  }, [id])\n\n  return (\n    <div>\n      <p>username:{data.username} </p>\n      <p>email:{data.email} </p>\n    </div>\n  )\n}\n\nexport default User\n```\n\n经常写 react 的肯定对上面的代码不陌生，前端向后端发送数据请求，接受到数据后赋值给 data，然后渲染出来。因为请求数据是需要耗时的，所以在页面显示完之后，会停顿一会在显示出数据（主要是我这边没写 loadding），并且由于 id 并不是第一时间获取到的（从上面的 id）。\n\n![image-20220712193009186](https://img.kuizuo.cn/image-20220712193009186.png)\n\n从这里来看，客户端渲染不仅要获取页面组件，还要请求数据，最终再通过 js 渲染出来\n\n### SSR 服务端渲染\n\nnext 中服务端渲染需要用到 getServerSideProps 函数，而后端的数据获取都是在该函数内来获取，并通过 prop 传入给前端组件中，来看实际代码\n\n```tsx title=\"[id].tsx\"\nconst User = ({ data }: { data: any }) => {\n  return (\n    <div>\n      <p>username:{data.username} </p>\n      <p>email:{data.email} </p>\n    </div>\n  )\n}\n\nexport default User\n\nexport async function getServerSideProps(context: { query: { id: any } }) {\n  const { id } = context.query // 这里context.param也能获取到id\n\n  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)\n\n  const data = await res.json()\n\n  return {\n    props: {\n      data,\n    },\n  }\n}\n```\n\n如果从页面显示来看，确实没什么区别，但如果打开控制台就能发现诸多不同。\n\n首先就是请求的页面，是直接包含数据，相当于返回你一个页面，而在客户端渲染则是返回一个组件，需要自己去请求数据来展示。\n\n![image-20220712192713634](https://img.kuizuo.cn/image-20220712192713634.png)\n\n同时查看控制台中的 Fetch/XHR 的是看不到请求的数据，因为这些数据并不是由前端发送的,而是由后端发送的（故不受跨域请求的限制）。\n\n从这就能看出客户端渲染与服务端渲染的的区别了。\n\n### SSG 静态生成\n\n不过还没完，还有一个静态生成，先来看看代码。\n\n```tsx title=\"[id].tsx\"\nconst User = ({ data }: { data: any }) => {\n  return (\n    <div>\n      <p>username:{data.username} </p>\n      <p>email:{data.email} </p>\n    </div>\n  )\n}\n\nexport default User\n\nexport async function getStaticProps(context: { params: { id: any } }) {\n  const { id } = context.params\n\n  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)\n\n  const data = await res.json()\n\n  return {\n    props: {\n      data,\n    },\n  }\n}\n\nexport async function getStaticPaths() {\n  return {\n    paths: new Array(20).fill(0).map((a, i) => ({ params: { id: String(i + 1) } })),\n    fallback: 'blocking',\n  }\n}\n```\n\n主要是 getServerSideProps 替换成 getStaticProps，同时增加了一个 getStaticPaths 用于生成静态页面的，而上面的 getStaticPaths 表示生成 id 1 到 20 的页面，那假设如果我访问 id 为 21 的 user 呢？由于这里设置`fallback: 'blocking'`，所以还是会走服务端渲染的那一部分。但如果设置`fallback: fasle`，访问 user/21 就会提示 404。\n\n通俗点来说就就是生成一系列静态页面，不需要服务端处理，所以返回的速度更快，其缺点其实也比较明显，数据的任何更改都需要在服务端重新构建，而服务端渲染则是可以动态处理数据，不需要完全重建。\n\n### ISR 增量式静态生成\n\n不做过多介绍，详看文档 [Data Fetching: Incremental Static Regeneration | Next.js (nextjs.org)](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration)\n\n## api 接口\n\n上面的数据都是调用 [JSONPlaceholder](http://jsonplaceholder.typicode.com/) 所提供的虚拟数据，在 next 中要提供数据接口的话，只需要在 pages/api 下编写即可，生成的路由规则和组件一样。例如 pages/api/hello.ts 映射为 api/hello，浏览器访问[http://localhost:3000/api/hello](http://localhost:3000/api/hello) 就可以得到`{\"name\": \"John Doe\"}`\n\n```tsx title=\"hello.ts\"\nimport type { NextApiRequest, NextApiResponse } from 'next'\n\ntype Data = {\n  name: string\n}\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse<Data>) {\n  res.status(200).json({ name: 'John Doe' })\n}\n```\n\n这里的 req、res 就是同大部分 node 后端框架一样，而这里的写法与 serverless 一致（这里应该就是 serverless）。\n\n上述是 get 请求，那 post 请求呢？无论什么 http 请求方法都将在 handler 处理，通过 req.method 来获取请求方法，要区分的话可以通过如下代码。\n\n```tsx\nexport default function handler(req, res) {\n  if (req.method === 'POST') {\n    // Process a POST request\n  } else {\n    // Handle any other HTTP method\n  }\n}\n```\n\n### 写一个简单的 CRUD\n\n既然知道了上述的一些作用，不妨来个熟悉的 CRUD。这里以文章 post 为例\n\n这里数据端使用的时 sqlite，配置不做展示，只展示主要核心功能\n\n```typescript title=\"api/post/index.ts\"\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport db from '../../../lib/db'\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    switch (req.method) {\n      case 'GET':\n        db.all(`select * from post`, (err, rows) => {\n          res.status(200).json(rows)\n        })\n        break\n      case 'POST':\n        const { title, content } = req.body\n\n        db.get(`insert into post(title, content) values(?, ?)`, [title, content], (err, rows) => {\n          res.status(200).json(rows)\n        })\n        break\n    }\n  } catch (error) {\n    res.status(500).end()\n  }\n}\n```\n\n```typescript title=\"api/post/[id].ts\"\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport db from '../../../lib/db'\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { id } = req.query\n  const { title, content } = req.body\n\n  try {\n    switch (req.method) {\n      case 'GET':\n        db.get(`select * from post where id=$id`, { $id: id }, (err, rows) => {\n          res.status(200).json(rows)\n        })\n        break\n      case 'Put':\n        db.get(`update post set title=?,content=? where id=?`, [title, content, id], (err, rows) => {\n          res.status(200).json(rows)\n        })\n      case 'DELETE':\n        db.get(`delete from post where id=$id`, { $id: id }, (err, rows) => {\n          res.status(200).json(rows)\n        })\n    }\n  } catch (error) {\n    res.status(500).end()\n  }\n}\n```\n\n这里为了符合 RESTFUL 风格，所以 post 下编写了两个文件，这时候请求[http://localhost:3000/api/post](http://localhost:3000/api/post/2) 就能获取到所有文章数据，基本的 CRUD 也就实现了。\n\n这里写 sql 是真滴繁琐，没使用 str 或是 typeorm 主要是不想把这个 demo 搞得太复杂，实际项目还是用上比较好。\n\n当然这里只是作为后端 api 接口的演示，至于前端的展示与编写就和普通前端开发没啥大的区别。基本后端框架能做的，next 能做后端很多事情，更多的使用还是作为接口转发，中间件等，毕竟 Next 主要的强项还是服务端渲染的能力。\n\n## 打包部署\n\n既然说到部署，那肯定离不开 nextjs 的母公司[Vercel](https://vercel.com)了，关于 Vercel 之前也写过相关文章，关于 Vercel 就不过多介绍。\n\nnextjs 部署到 vercel 实在简单，将项目推送到 github 仓库中，然后在 vercel 中 New Project，接着选择 nextjs 的仓库，点击 Deploy，静等部署即可。关于部署可以看这篇文章 [Vercel 部署个人博客](https://kuizuo.cn/develop/Vercel部署个人博客)\n\n现在你可以通过访问 [kz-next-app-demo.vercel.app](https://kz-next-app-demo.vercel.app/) 来访问该项目，并尝试访问`/api/post`，`user/1`来看看。\n\n只能说不愧是母公司。\n\n至于其他部署？既然都用 nextjs 了，还考虑自建服务器来部署吗？\n\n## 总结\n\n这次的整体过程比较简单，后续应该会使用 nextjs 编写一个完整的项目（~~也有可能是 nuxt.js~~)。"
    },
    {
      "id": "vscode-extension",
      "metadata": {
        "permalink": "/vscode-extension",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/写一个VSCode扩展.md",
        "source": "@site/blog/project/写一个VSCode扩展.md",
        "title": "写一个VSCode扩展",
        "description": "编写一个属于个人定制化的 VSCode 扩展，并将其发布到应用商店中",
        "date": "2022-07-11T00:00:00.000Z",
        "formattedDate": "2022年7月11日",
        "tags": [
          {
            "label": "vscode",
            "permalink": "/tags/vscode"
          },
          {
            "label": "plugin",
            "permalink": "/tags/plugin"
          },
          {
            "label": "extension",
            "permalink": "/tags/extension"
          },
          {
            "label": "develop",
            "permalink": "/tags/develop"
          }
        ],
        "readingTime": 19.28,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "vscode-extension",
          "title": "写一个VSCode扩展",
          "date": "2022-07-11T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "vscode",
            "plugin",
            "extension",
            "develop"
          ],
          "keywords": [
            "vscode",
            "plugin",
            "extension",
            "develop"
          ],
          "description": "编写一个属于个人定制化的 VSCode 扩展，并将其发布到应用商店中",
          "image": "/img/project/vscode-extension.png",
          "sticky": 4
        },
        "prevItem": {
          "title": "Next.js项目搭建与部署",
          "permalink": "/next.js-build-and-deploy"
        },
        "nextItem": {
          "title": "AutoHotkey键盘映射",
          "permalink": "/autohotkey"
        }
      },
      "content": "自从使用过 VSCode 后就再也离不开 VSCode，其轻量的代码编辑器与诸多插件让多数开发者爱不释手。同样我也不例外，一年前的我甚至还特意买本《Visual Studio Code 权威指南》的书籍，来更进一步了解与使用。\n\n在购买这本书时就想写一个 vscode 插件（扩展），奈何当时事务繁忙加之不知做何功能，就迟迟未能动手。如今有时间了，就顺带体验下 vscode 扩展开发，并记录整个开发过程。\n\n扩展地址：[VSCode-extension](https://marketplace.visualstudio.com/items?itemName=kuizuo.vscode-extension-sample 'VSCode-extension')\n\n开源地址：[kuizuo/vscode-extension (github.com)](https://github.com/kuizuo/vscode-extension)\n\n![vscode-extension](https://img.kuizuo.cn/image-20220711195038039.png)\n\n<!-- truncate -->\n\n## Vscode 相关\n\n[vscode 应用商店](https://marketplace.visualstudio.com/vscode 'vscode应用商店')\n\n[vscode 插件官方文档](https://code.visualstudio.com/api 'vscode插件官方文档')\n\n[vscode 官方插件例子](https://github.com/microsoft/vscode-extension-samples 'vscode 官方插件例子')\n\n关于 Vscode 及其插件就不过多介绍，相信这篇文章 [VSCode 插件开发全攻略（一）概览 - 我是小茗同学 - 博客园](https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html 'VSCode插件开发全攻略（一）概览 - 我是小茗同学 - 博客园')能告诉你 Vscode 插件的作用。\n\n## 工具准备\n\n:::tip\n\n**在开发前，建议关闭所有功能性扩展，以防止部分日志输出与调试效率**。\n\n:::\n\n### vscode 插件脚手架\n\nvscode 提供插件开发的脚手架 [vscode-generator-code](https://github.com/Microsoft/vscode-generator-code 'vscode-generator-code') 来生成项目结构，选择要生成的类型\n\n```shell\n? ==========================================================================\nWe're constantly looking for ways to make yo better!\nMay we anonymously report usage statistics to improve the tool over time?\nMore info: https://github.com/yeoman/insight & http://yeoman.io\n========================================================================== Yes\n\n     _-----_     ╭──────────────────────────╮\n    |       |    │   Welcome to the Visual  │\n    |--(o)--|    │   Studio Code Extension  │\n   `---------´   │        generator!        │\n    ( _´U`_ )    ╰──────────────────────────╯\n    /___A___\\   /\n     |  ~  |\n   __'.___.'__\n ´   `  |° ´ Y `\n\n? What type of extension do you want to create? (Use arrow keys)\n> New Extension (TypeScript)\n  New Extension (JavaScript)\n  New Color Theme\n  New Language Support\n  New Code Snippets\n  New Keymap\n  New Extension Pack\n  New Language Pack (Localization)\n  New Web Extension (TypeScript)\n  New Notebook Renderer (TypeScript)\n```\n\n根据指示一步步选择，这里省略勾选过程，最终生成的项目结果如下\n\n![](https://img.kuizuo.cn/image_StiMqQrFCi.png)\n\n### 运行 vscode 插件\n\n既然创建好了工程，那必然是要运行的。由于我这里选择的 ts ＋ webpack 进行开发（视情况勾选webpack），所以是需要打包，同时脚手架已经生成好了对应.vscode 的设置。只需要按下 F5 即可开始调试，这时会打开一个新的 vscode 窗口，`Ctrl+Shift+P`打开命令行，输入`Hello World`，右下角弹出提示框`Hello World from kuizuo-plugin!`\n\n:::danger\n\n注意: 由于是 webpack 开发，在调用堆栈中可以看到有两个进程，一个是 webpack，另一个是新开的插件窗口的，同时在该调试窗口也能查看调试输出信息。\n\n![](https://img.kuizuo.cn/image_Yv4X32qLE5.png)\n\n**切记一定要等到第二个调试进程加载完毕**（时间根据电脑性能而定），再打开命令行输入 Hello World 才会有命令，否则会提示 没有匹配命令。\n\n:::\n\n至此，一个 vscode 的开发环境就已经搭建完毕，接下来就是了解项目结构，以及 vscode 插件的 api 了。\n\n### 代码解读\n\n```typescript title=\"extension.ts\"\nimport * as vscode from 'vscode'\n\nexport function activate(context: vscode.ExtensionContext) {\n  let disposable = vscode.commands.registerCommand('kuizuo-plugin.helloWorld', () => {\n    vscode.window.showInformationMessage('Hello World from kuizuo-plugin!')\n  })\n\n  context.subscriptions.push(disposable)\n}\n\nexport function deactivate() {}\n```\n\n`vscode.commands.registerCommand`用于注册命令，`kuizuo-plugin.helloWorld` 为命令 ID，在后续`package.json`中要与之匹配。第二个参数为一个回调函数，当触发该命令时，弹出提示框。\n\n在 package.json 中关注 activationEvents 与 contributes\n\n```json title=\"package.json\"\n{\n  \"activationEvents\": [\"onCommand:kuizuo-plugin.helloWorld\"],\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"kuizuo-plugin.helloWorld\",\n        \"title\": \"Hello World\"\n      }\n    ]\n  }\n}\n```\n\nactivationEvents 激活事件，`onCommand:kuizuo-plugin.helloWorld`中`kuizuo-plugin`是插件 ID 要与 extension.ts 中的注册命令匹配，`helloWorld`则是命令标识，而 onCommand 则是监听的类型，此外还有`onView`、`onUri`、`onLanguage`等等。\n\ncontributes 则是配置那些地方来显示命令，像官方的例子中，就是在 Ctrl + Shift + P 命令行中输入 Hello World 来调用`kuizuo-plugin.helloWorld` 命令。此外还可以设置按键与菜单\n\n```json title=\"package.json\"\n\"keybindings\": [\n      {\n        \"command\": \"kuizuo-plugin.helloWorld\",\n        \"key\": \"ctrl+f10\",\n        \"mac\": \"cmd+f10\",\n        \"when\": \"editorTextFocus\"\n      }\n    ],\n    \"menus\": {\n      \"editor/context\": [\n        {\n          \"when\": \"editorFocus\",\n          \"command\": \"kuizuo-plugin.helloWorld\",\n          \"group\": \"navigation\"\n        }\n      ]\n    }\n```\n\n设置完毕后，可以按 Ctrl + Alt + O 或者命令行中键入 reload 来重启 vscode\n\n:::danger\n\n这里也要注意，如果重启后并无生效，请查看 package.json 是否配置正确（多一个逗号都不行），或者尝试重新调试。如果还不行，那么很有可能就是代码报错，但日志输出并没有，那么在弹出的新窗口中打开开发人员工具（Ctrl+Alt+I 或帮助 → 切换开发人员工具），这里有报错相关的提示信息。\n\n建议查看[VSCode 插件开发全攻略（六）开发调试技巧](https://www.cnblogs.com/liuxianan/p/vscode-plugin-develop-tips.html 'VSCode插件开发全攻略（六）开发调试技巧')\n\n:::\n\n## 功能\n\n### 首次启动弹窗与配置项\n\n先说首次启动弹窗的实现，要实现该功能，肯定要保证插件在 VSCode 一打开就运行，而这取决于 vscode 触发插件的时机，也就是 activationEvents，所以`activationEvents`需要设置成`onStartupFinished`。想要更高的优先级，可以选择 `*` （但官方不建议，除非其他事件无法实现的前提下），这里为了演示就使用`*`。\n\n其实现代码主要调用 `vscode.window.showInformationMessage` 函数如下\n\n```typescript title=\"extension.ts\"\nimport * as vscode from 'vscode'\nimport { exec } from 'child_process'\n\nexport function activate(context: vscode.ExtensionContext) {\n  vscode.window.showInformationMessage('是否要打开愧怍的小站？', '是', '否', '不再提示').then((result) => {\n    if (result === '是') {\n      exec(`start 'https://kuizuo.cn'`)\n    } else if (result === '不再提示') {\n      // 其他操作 后文会说\n    }\n  })\n}\n```\n\n此时重启窗口，就会有如下弹窗显示\n\n![](https://img.kuizuo.cn/image_9oqLzZl-wE.png)\n\n但如果你是 mac 用户的话，你会发现无法打开，其原因是 window 下打开链接的指令是 start，而 mac 则是 open，所以需要区分不同的系统。要区分系统就可以使用 node 中的 os 模块的 platform 方法获取系统，如下（省略部分代码）\n\n```typescript\nimport * as os from 'os'\n\nconst commandLine = os.platform() === 'win32' ? `start https://kuizuo.cn` : `open https://kuizuo.cn`\nexec(commandLine)\n```\n\n当然了，当用户选择不再提示的时候，下次再打开 vscode 就别提示了，不然大概率就是卸载插件了。这里就需要设置全局参数了，在 package.json 中 contributes 设置 configuration，具体如下，注意`kuizuoPlugin.showTip` 为全局参数之一\n\n```json title=\"package.json\"\n\"contributes\": {\n  \"configuration\": {\n    \"title\": \"kuizuo-plugin\",\n    \"properties\": {\n      \"kuizuoPlugin.showTip\": {\n        \"type\": \"boolean\",\n        \"default\": true,\n        \"description\": \"是否在每次启动时显示欢迎提示！\"\n      }\n    }\n  }\n}\n```\n\n该参数可以在设置 → 扩展中找到`kuizuo-plugin`插件来手动选择，也可以是通过 api 来修改\n\n![](https://img.kuizuo.cn/image_teNrxe9D9O.png)\n\n然后读取`vscode.workspace.getConfiguration().get(key)`和设置该参数`vscode.workspace.getConfiguration().update(key, value)`\n\n```typescript title=\"extension.ts\"\nexport async function activate(context: vscode.ExtensionContext) {\n  const key = 'kuizuoPlugin.showTip'\n  const showTip = vscode.workspace.getConfiguration().get(key)\n  if (showTip) {\n    const result = await vscode.window.showInformationMessage('是否要打开愧怍的小站？', '是', '否', '不再提示')\n    if (result === '是') {\n      const commandLine = os.platform() === 'win32' ? `start https://kuizuo.cn` : `open https://kuizuo.cn`\n      exec(commandLine)\n    } else if (result === '不再提示') {\n      //最后一个参数，为true时表示写入全局配置，为false或不传时则只写入工作区配置\n      await vscode.workspace.getConfiguration().update(key, false, true)\n    }\n  }\n}\n```\n\n即便是调试状态下，重启也不会影响全局参数。最终封装完整代码查看源码，这里不再做展示了。\n\n### 右键资源管理器（快捷键）新建测试文件\n\n我日常开发中写的最多的文件就是 js/ts 了，有时候就会在目录下创建 demo.js 来简单测试编写 js 代码，那么我就要点击资源管理器，然后右键新建文件，输入 demo.js。于是我想的是将该功能**封装成快捷键**的方式，当然右键也有**新建测试文件**这一选项。\n\n![](https://img.kuizuo.cn/image_3SRybBGaF1.png)\n\n功能其实挺鸡肋的，也挺高不了多少效率，这里可以说**为了演示和测试这个功能而实现**。\n\n总之前面这么多废话相当于铺垫了，具体还是看功能实现吧。\n\n首先就是注册命令，具体就不解读代码了，其逻辑就是获取调用`vscode.window.showQuickPick`弹出选择框选择 js 还是 ts 文件（自定义），接着获取到其目录，判断文件是否存在，创建文件等操作。\n\n```typescript title=\"extension.ts\"\nimport * as vscode from 'vscode'\nimport * as fs from 'fs'\n\nexport async function activate(context: vscode.ExtensionContext) {\n  let disposable = vscode.commands.registerCommand('kuizuo-plugin.newFile', (uri: vscode.Uri) => {\n    vscode.window.showQuickPick(['js', 'ts'], {}).then(async (item) => {\n      if (!uri?.fsPath) {\n        return\n      }\n\n      const filename = `${uri.fsPath}/demo.${item}`\n      if (fs.existsSync(filename)) {\n        vscode.window.showErrorMessage(`文件${filename}已存在`)\n        return\n      }\n\n      fs.writeFile(filename, '', () => {\n        vscode.window.showInformationMessage(`demo.${item}已创建`)\n        vscode.window.showTextDocument(vscode.Uri.file(filename), {\n          viewColumn: vscode.ViewColumn.Two, // 显示在第二个编辑器窗口\n        })\n      })\n    })\n  })\n\n  context.subscriptions.push(disposable)\n}\n\nexport function deactivate() {}\n```\n\n然后再 keybindins 中添加一条\n\n```json title=\"package.json\"\n\"keybindings\": [\n  {\n    \"command\": \"kuizuo-plugin.newFile\",\n    \"key\": \"shift+alt+n\",\n  }\n],\n```\n\n然后就当我实现完功能的时候，我在想**自带的新建文件是不是就是个 command？只是没有绑定快捷键？** 于是我到键盘快捷方式中找到答案\n\n![](https://img.kuizuo.cn/image_nQu3Y8DWSw.png)\n\n图中的`explorer.newFile`就是资源管理器右键新建文件的命令，只是没有键绑定。所以我只需要简单的加上`shift + alt + n`即可实现我一开始想要的快捷键功能，此时再次右键资源管理器新建文件右侧就有对应的快捷键。\n\n此时的我不知该哭该笑，折腾半天的功能其实只是设置个快捷键的事情。\n\n:::note\n\n这些命令在 vscode 中作为内置命令[Built-in Commands](https://code.visualstudio.com/api/references/commands 'Built-in Commands')。要查看 vscode 所有命令的话，也可以通过`vscode.commands.getCommands` 来获取所有命令 ID，要在插件中执行也只需要调用`vscode.commands.executeCommand(id)`&#x20;\n\n:::\n\n### 键盘快捷键（光标移动）\n\n接着我就在想，既然很多 vscode 功能都是命令的形式，那是不是在插件级别就能做键盘映射，而不用让用户在 vscode 设置，很显然是可以的。只需要在 package.json 中 contributes 的 keybindings 中设置，就可以实现组合键来进行光标的移动。下面是我给出的答案\n\n```json title=\"package.json\"\n\"keybindings\": [\n      {\n        \"command\": \"cursorUp\",\n        \"key\": \"shift+alt+i\",\n        \"when\": \"textInputFocus\"\n      },\n      {\n        \"command\": \"cursorDown\",\n        \"key\": \"shift+alt+k\",\n        \"when\": \"textInputFocus\"\n      },\n      {\n        \"command\": \"cursorLeft\",\n        \"key\": \"shift+alt+j\",\n        \"when\": \"textInputFocus\"\n      },\n      {\n        \"command\": \"cursorRight\",\n        \"key\": \"shift+alt+l\",\n        \"when\": \"textInputFocus\"\n      },\n      {\n        \"command\": \"cursorHome\",\n        \"key\": \"shift+alt+h\",\n        \"when\": \"textInputFocus\"\n      },\n      {\n        \"command\": \"cursorEnd\",\n        \"key\": \"shift+alt+;\",\n        \"when\": \"textInputFocus\"\n      }\n    ]\n```\n\n![](https://img.kuizuo.cn/image_SnnPUABJN5.png)\n\n仔细看右侧来源就可以知道是没问题的，第一个为我之前设置的，而扩展则是通过上面的方法。\n\n### 自定义扩展工作台\n\n在 vscode 中有几个地方可以用于扩展，具体可看[Extending Workbench | Visual Studio Code Extension API](https://code.visualstudio.com/api/extension-capabilities/extending-workbench#status-bar-item 'Extending Workbench | Visual Studio Code Extension API')\n\n![](https://code.visualstudio.com/assets/api/extension-capabilities/extending-workbench/workbench-contribution.png)\n\n- 左侧图标（活动栏）：主要有资源管理器、搜索、调试、源代码管理、插件\n\n- 编辑器右上角：代码分栏、code runner 的运行图标\n\n- 底部（状态栏）：git、消息、编码等等\n\n在 contributes 添加 viewsContainers 与 views，注意，views 的属性要与 viewsContainers 的 id 对应。\n\n```json title=\"package.json\"\n\"viewsContainers\": {\n  \"activitybar\": [\n    {\n      \"id\": \"demo\",\n      \"title\": \"愧怍\",\n      \"icon\": \"public/lollipop.svg\"\n    }\n  ]\n},\n\"views\": {\n  \"demo\": [\n    {\n      \"id\": \"view1\",\n      \"name\": \"视图1\"\n    },\n    {\n      \"id\": \"view2\",\n      \"name\": \"视图2\"\n    }\n  ]\n}\n```\n\n编辑器右上角是在 menus 中设置 editor/title，图标则是对应命令下设置，不然就是显示文字\n\n```json title=\"package.json\"\n\"commands\": [\n    {\n      \"command\": \"kuizuo-plugin.helloWorld\",\n      \"title\": \"Hello World\",\n      \"icon\": {\n        \"light\": \"public/lollipop.svg\",\n        \"dark\": \"public/lollipop.svg\"\n      }\n    }\n],\n\"menus\": {\n    \"editor/title\": [\n      {\n        \"when\": \"resourceLangId == javascript\",\n        \"command\": \"kuizuo-plugin.helloWorld\",\n        \"group\": \"navigation\"\n      }\n    ],\n}\n```\n\n至于底部状态栏，这里借用官方例子[vscode-extension-samples/statusbar-sample at main · microsoft/vscode-extension-samples (github.com)](https://github.com/microsoft/vscode-extension-samples/tree/main/statusbar-sample 'vscode-extension-samples/statusbar-sample at main · microsoft/vscode-extension-samples (github.com)')，最终效果如下\n\n![](https://img.kuizuo.cn/image_yQRsMkT6f5.png)\n\n那个 🍭 就是所添加的图标，不过并不实际功能，这里只是作为展示。\n\n### 自定义颜色、图标主题\n\n在 vscode 中分别有三部分的主题可以设置\n\n| 主题         | 范围                       | 推荐                                                                                                 |\n| ------------ | -------------------------- | ---------------------------------------------------------------------------------------------------- |\n| 文件图标主题 | 资源管理器内的文件前的图标 | [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme) |\n| 颜色主题     | 代码编辑器以及整体颜色主题 | [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)      |\n| 产品图标主题 | 左侧的图标                 | [Carbon Product Icons](https://marketplace.visualstudio.com/items?itemName=antfu.icons-carbon)       |\n\n不过关于主题美化就不做深入研究，上面所推荐的就已经足够好看，个人目前也在使用。\n\n### 代码片段\n\n代码片段，也叫`snippets`，相信大家都不陌生，就是输入一个很简单的单词然后一回车带出来很多代码。平时大家也可以直接在 vscode 中创建属于自己的`snippets`\n\n代码片段相对比较简单，这里就简单跳过了\n\n### xxx.log → console.log(xxx)包装\n\n功能描述：在一个变量后使用.log，即可转化为 console.log(变量)的形式就像 `xxx.log => console.log('xxx', xxx)` 有点像 idea 中的`.sout`\n\n这里我把 [jaluik/dot-log](https://github.com/jaluik/dot-log) 这个插件的实现逻辑给简化了，这里先给出基本雏形\n\n```typescript title=\"extension.ts\"\nimport * as vscode from 'vscode'\n\nclass MyCompletionItemProvider implements vscode.CompletionItemProvider {\n  constructor() {}\n\n  // 提供代码提示的候选项\n  public provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n    const snippetCompletion = new vscode.CompletionItem('log', vscode.CompletionItemKind.Operator)\n    snippetCompletion.documentation = new vscode.MarkdownString('quick console.log result')\n\n    return [snippetCompletion]\n  }\n\n  // 光标选中当前自动补全item时触发动作\n  public resolveCompletionItem(item: vscode.CompletionItem) {\n    return null\n  }\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n  const disposable = vscode.languages.registerCompletionItemProvider(\n    ['html', 'javascript', 'javascriptreact', 'typescript', 'typescriptreact', 'vue'],\n    new MyCompletionItemProvider(),\n    '.', // 注册代码建议提示，只有当按下“.”时才触发\n  )\n\n  context.subscriptions.push(disposable)\n}\n```\n\n在 vscode 插件中通过`vscode.languages.registerCompletionItemProvider`提供像补全，代码提示等功能，第一个参数为所支持的语言，第二个参数为提供的服务`vscode.CompletionItemProvider`\n这里只是封装成类的形式，目的是为了保存一些属性，例如光标位置 position，也可以传递对象形式\n`{ provideCompletionItems, resolveCompletionItem }` ，第三个参数则是触发的时机。\n\n`provideCompletionItems`\n需返回一个数组，成员类型为`vscode.CompletionItem`，可通过`new vscode.CompletionItem()`来创建。\n\n当你尝试运行上述代码时，会发现在任何值后面输入`.`都会有`log`提示。\n\n![](https://img.kuizuo.cn/image_-ZCy88xVyq.png)\n\n但是点击后只是满足了代码补全的功能，而选择 log 选项后所要执行的操作则是在 `resolveCompletionItem` 中实现，这里仅仅只是返回一个\nnull，即只有简单的补全功能，这里对整个过程进行描述（可以自行下个断点调试查看）：。\n\n1. 当输入`.`时，程序进入到`provideCompletionItems`\n   函数内，这里可以获取到当前正在编辑的代码文档（文件名，代码内容）对应第一个参数，以及光标所在位置也就是第二个参数。还有其他参数，但这里用不到。具体可看[CompletionItemProvider](https://code.visualstudio.com/api/references/vscode-api#CompletionItemProvider%3CT%3E 'CompletionItemProvider')\n\n2. 选择完毕后，便会进入到 resolveCompletionItem 里面，这里可以获取到用户所选的选项内容，然后执行一系列的操作。\n\n要做代码替换的话就需要注册文本编辑命令`vscode.commands.registerTextEditorCommand` ，内容如下\n\n```typescript title=\"extension.ts\"\nconst commandId = 'kuizuo-plugin.log'\nconst commandHandler = (editor: vscode.TextEditor, edit: vscode.TextEditorEdit, position: vscode.Position) => {\n  const lineText = editor.document.lineAt(position.line).text\n  // match case name.log etc.\n  const matchVarReg = new RegExp(`\\(\\[^\\\\s\\]*\\[^\\'\\\"\\`\\]\\).${'log'}$`)\n  // match case 'name'.log etc.  /(['\"`])([^'\"])\\1.log/\n  const matchStrReg = new RegExp(`\\(\\[\\'\\\"\\`\\]\\)\\(\\[^\\'\\\"\\`\\]*\\)\\\\1\\.${'log'}$`)\n  let matchFlag: 'var' | 'str' = 'var'\n  let text,\n    key,\n    quote = \"'\",\n    insertVal = ''\n  ;[text, key] = lineText.match(matchVarReg) || []\n  if (!key) {\n    ;[text, quote, key] = lineText.match(matchStrReg) || []\n    matchFlag = 'str'\n  }\n  // if matched\n  if (key) {\n    const index = lineText.indexOf(text)\n    edit.delete(new vscode.Range(position.with(undefined, index), position.with(undefined, index + text.length)))\n\n    if (matchFlag === 'var' && key.includes(\"'\")) {\n      quote = '\"'\n    }\n    // format like console.log(\"xxx\", xxx)\n    if (matchFlag === 'var') {\n      //  only console.log(xxx)\n      insertVal = `${'console.log'}(${key})`\n    }\n    // if key is string format like console.log(\"xxx\")\n    if (matchFlag === 'str') {\n      insertVal = `${'console.log'}(${quote}${key}${quote})`\n    }\n\n    edit.insert(position.with(undefined, index), insertVal)\n  }\n\n  return Promise.resolve([])\n}\ncontext.subscriptions.push(vscode.commands.registerTextEditorCommand(commandId, commandHandler))\n```\n\n`registerTextEditorCommand`不同于`registerCommand`，它只针对编辑器的命令，例如可以删除代码中的某个片段，增加代码等等。上面的代码就是为了找到.log\n前（包括.log）匹配的代码，进行正则提取，然后调用 edit.delete 删除指定范围，再调用 edit.insert\n来插入要替换的代码，以此达到替换的效果。\n\n命令注册完毕了就需要调用了，也就到了 resolveCompletionItem 的时机\n\n```typescript title=\"extension.ts\"\n  public resolveCompletionItem(item: vscode.CompletionItem) {\n    const label = item.label\n    if (this.position && typeof label === 'string') {\n      item.command = {\n        command: 'kuizuo-plugin.log',\n        title: 'refactor',\n        arguments: [this.position.translate(0, label.length + 1)], // 这里可以传递参数给该命令\n      }\n    }\n\n    return item\n  }\n```\n\n将命令赋值给 item.command，会自动调用其 command 命令，同时把 arguments 参数传入给 command。最终达到替换的效果。\n\n#### Position\n\n这里要说下 vscode 编辑器中的 Position，了解这个对代码替换、代码定位、代码高亮有很大帮助。\n\nposition 有两个属性`line`和`character`，对应的也就是行号和列号（后文以`line`和`character`\n为称），**\\*\\***和\\***\\*都是从 0 开始算起，而在 vscode 自带的状态栏提示中则是从 1 开始算起**，这两者可别混淆了。\n\n其中 position 有如下几个方法\n\n**position.translate**\n\n根据当前坐标计算，例如当前 position 的 line 0，character1。`position.translate(1, 1)` 得到 line\n1，character 2，这不会改变远 position，这很好理解。但如果计算后得到的 line 与 character 有一个为负数则直接报错。\n\n**position.with**\n\n从自身创建一个新的 postion 对象\n\n#### Range\n\n知道了坐标信息，那么就可以获取范围了。可以通过 new vscode.Range() 来截取两个 position 之间的内容，得到的是一个 对象，有\nstart 与 end 属性，分别是传入的两个 position。\n\n同样的 Range 和 Postion 方法都一致，这里就不多叙述了，可查看其声明文件。\n知道范围就可以通过 editor 来获取范围内的代码或是 edit 来删除代码等操作。\n\n知道了这些内容，再看上面的代码也不难理解了。\n\n### 选中变量并打印 console.log\n\n这里在补充一个功能：选中一个变量的时候，按下快捷键在下方添加`console.log(变量)`，相关插件 [Turbo Console Log](https://marketplace.visualstudio.com/items?itemName=ChakrounAnas.turbo-console-log 'Turbo Console Log')\n\n补：只有编辑器有光标的情况下会传入当前光标属性 position，选中状态下是不会传入 postion\n属性，而是要通过`editor.selection`来获取选中内容，是一个 Selection 对象。\n\n```typescript title=\"extension.ts\"\ncontext.subscriptions.push(\n  vscode.commands.registerTextEditorCommand(\n    'kuizuo-plugin.insertLog',\n    (editor: vscode.TextEditor, edit: vscode.TextEditorEdit) => {\n      // 获取选中代码 在其下方插入 console.log(xxx)\n      const { selection, selections } = editor\n      // 选中多个代码时\n      if (selections.length > 1) {\n        return\n      }\n\n      // 如果不是当行代码\n      if (!selection.isSingleLine) {\n        return\n      }\n\n      const value = editor.document.getText(selection)\n      const insertVal = `${os.EOL}${'console.log'}('${value}', ${value})`\n\n      edit.insert(editor.selection.end, insertVal)\n      editor.selection = new vscode.Selection(editor.selection.end, editor.selection.end) // 重置选中区域\n      return Promise.resolve([])\n    },\n  ),\n)\n```\n\n### 悬停提示\n\n这里也一笔带过，具体可看 hover.ts 中的代码。只要在 json 文件中，将鼠标悬停在`kuizuo`这个词中即可触发，试试看看。\n\n![](https://img.kuizuo.cn/image_RUIjdDI90l.png)\n\n### WebView\n\n使用 webView 可以在 vscode 内显示自定义的网页内容，丰富 vscode 功能，但所消耗的性能是肯定有的，就有可能影响 vscode\n的运行速度。官方给出的建议是：\n\n- 这个功能真的需要放在`VSCode`中吗？作为单独的应用程序或网站会不会更好呢？\n\n- webview 是实现这个功能的唯一方法吗？可以使用常规 VS Code API 吗？\n\n- 您的 webview 是否会带来足够的用户价值以证明其高资源成本？\n\n不过这里还只是作为一个演示，点击右上角的 logo 图标便可在 vscode 中打开网页。\n\n![](https://img.kuizuo.cn/image_nVO_YmRit4.png)\n\n不过要注意一点。新开的 webview 的背景是对应主题颜色的背景，如果网站有黑白模式的话，那么可能会导致颜色不对，故这里设置了 webview 的背景为白色。\n\n至于消息通信就不尝试了。\n\n## 发布\n\n大部分常用的 vscode 插件实现就此完毕，实际上有很多 api 还没尝试过，篇幅有限，就不一一列举了，后续若有开发实际作用插件再研究。具体可自行安装尝试一番，既然要让别人安装，这里就需要介绍发布了。\n\n这里在打包前重构下命令 ID，从 kuizuo-plugin → vscode-extension，同时把 package.json 的 name 改成了 vscode-extension-sample，因为发布的时候这个 id 必须唯一，不能与已有重名，到时候生成的为 kuizuo.vscode-extension-sample。（demo 给取了，不然我也不想起名为 sample）\n\n### 本地打包\n\n无论是本地打包还是发布到应用市场都需要借助`vsce`这个工具。\n\n安装\n\n```bash\nnpm i vsce -g\n```\n\n打包成`vsix`文件：\n\n```bash\nvsce package\n```\n\n:::danger\n\n如果使用pnpm的话，有可能会打包失败，提示：npm ERR! missing: xxxxxx\n\n:::\n\n在打包时会提示一些信息，例如修改 README.md ，添加 LICENSE 等等，根据提示来操作即可。\n\n生成好的 vsix 文件不能直接拖入安装，只能从扩展的右上角选择`Install from VSIX`安装：\n\n### 发布到应用市场\n\n**1、注册账号获取 token**\n\n因为 Visual Studio Code 使用 [Azure DevOps](https://azure.microsoft.com/services/devops/)作为其 Marketplace 服务。所以需要登录一下[Azure](https://dev.azure.com/ 'Azure')。登录后，如果之前没用过的话会要求创建一个组织，默认为邮箱前缀，这里如下点击\n\n![](https://img.kuizuo.cn/token1_JNXknLPQyJ.png)\n\n**2、新建一个 token**\n\n![image-20220831152146541](https://img.kuizuo.cn/image-20220831152146541.png)\n\n根据图片选择，注意其中 `Organization` 选择 `All aaccessible organizations`，`Scopes` 选择：`Full access`，否则登录会失败。生成后会得到一个 token，保存它，当你关闭时便不再显示。\n\n**3、创建一个发布者**\n\n先使用网页版创建发布账号：[https://marketplace.visualstudio.com/manage](https://marketplace.visualstudio.com/manage 'https://marketplace.visualstudio.com/manage')填写一些基本信息，然后在使用\n\n```bash\nvsce login <publisher name>\n```\n\n这里的 `publisher name` 根据 package.json 中的 `publisher`，会要求你输入 `Personal Access Token`，把刚刚创建的 `token` 的值粘贴过来即可\n\n提示\n`The Personal Access Token verification succeeded for the publisher 'kuizuo'.`\n就说明验证成功\n\n**4、发布应用**\n\n```bash\nvsce publish\n```\n\n:::warning\n这里要保证 package.json 的 name 在插件市场中唯一，否则会提示 The Extension Id already exist in the Marketplace. Please use the different Id。\n:::\n\n运行完毕后，最终提示`Published kuizuo.vscode-extension-sample v1.0.0.` 就说明发布完毕，发布和 npm 包一样，都无需审核，但要求包名唯一。\n\n可以在 [Manage Extensions | Visual Studio Marketplace](https://marketplace.visualstudio.com/manage/publishers/kuizuo 'Manage Extensions | Visual Studio Marketplace') 中管理已发布的插件\n\n![](https://img.kuizuo.cn/image_HssaMdar8f.png)\n\n这时在 vscode 扩展商店中搜索 `vscode-extension-sample`就能找到该插件[VSCode-extension](https://marketplace.visualstudio.com/items?itemName=kuizuo.vscode-extension-sample 'VSCode-extension')，也可以通过`publisher:\"kuizuo\"`来找到我的所有 vscode 插件。\n\n![vscode-extension](https://img.kuizuo.cn/image-20220711195038039.png)\n\n## 总结\n\n整个开发过程的体验还是非常不错的，调试和代码提示都做得特别到位。不过有一点体验不好的，是大部分的配置信息都要写在 package.json 中，而在这里就不像 ts 那样有没有很好的代码提示了。不过当你填错命令 id 的时，vscode 还会提示命令 id 不存在，而不是不知道报错点。\n\n浅浅吐槽下：说真的 vscode 插件开发相关的文章与教程少之又少，有时候一个功能的一个 api 实现只能去查阅文档，而不像 chrome 插件，通过搜索引擎就能很快得出结果，而 vscode 插件往往得到的是推荐...但这也说明 chrome 插件开发的人远多于 vscode 插件，或者说远多于 IDE 插件的开发，也很正常，大部分编程好用的功能，已有大牛实现了对应的插件，多数开发者没有一些特别的需求完全就没必要接触 vscode 插件开发。就如我一年前就想写 vscode 插件，但却迟迟拖到现在，其原因可能就这。\n\n不过这类应用本就如此，就是不断翻阅文档，阅读前人的代码实现，再结合自身思路以完成最终目标。\n\n## 参考文章\n\n[VSCode 插件开发全攻略（一）概览 - 我是小茗同学 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html 'VSCode插件开发全攻略（一）概览 - 我是小茗同学 - 博客园 (cnblogs.com)')\n\n[Extension API | Visual Studio Code Extension API](https://code.visualstudio.com/api)"
    },
    {
      "id": "autohotkey",
      "metadata": {
        "permalink": "/autohotkey",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/AutoHotkey键盘映射.md",
        "source": "@site/blog/develop/AutoHotkey键盘映射.md",
        "title": "AutoHotkey键盘映射",
        "description": "当我使用笔记本的时候，每次移动光标，都要大费周章，同时由于笔记本的缘故，导致键入Home与End都需要搭配Fn功能键来实现。所以我希望在任何情况下（敲代码，写文章）都可以将某些组合键绑定为上下左右键，在代码编辑器上有键盘映射可以设置，但脱离代码编辑器就不起作用了，在window下有个神器 AutoHotkey 可以实现我想要的功能。",
        "date": "2022-07-08T00:00:00.000Z",
        "formattedDate": "2022年7月8日",
        "tags": [
          {
            "label": "工具",
            "permalink": "/tags/工具"
          },
          {
            "label": "keyMap",
            "permalink": "/tags/key-map"
          }
        ],
        "readingTime": 1.64,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "autohotkey",
          "title": "AutoHotkey键盘映射",
          "date": "2022-07-08T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "工具",
            "keyMap"
          ],
          "keywords": [
            "工具",
            "keyMap"
          ]
        },
        "prevItem": {
          "title": "写一个VSCode扩展",
          "permalink": "/vscode-extension"
        },
        "nextItem": {
          "title": "记一次前端面试过程",
          "permalink": "/frontend-interview-experience"
        }
      },
      "content": "当我使用笔记本的时候，每次移动光标，都要大费周章，同时由于笔记本的缘故，导致键入Home与End都需要搭配Fn功能键来实现。所以我希望在任何情况下（敲代码，写文章）都可以将某些组合键绑定为上下左右键，在代码编辑器上有键盘映射可以设置，但脱离代码编辑器就不起作用了，在window下有个神器 [AutoHotkey](https://www.autohotkey.com/) 可以实现我想要的功能。\n\n<!-- truncate -->\n\n## 安装\n\n打开[官网](https://www.autohotkey.com/)，点击Download，安装即可。\n\n## 使用\n\n安装完成后，右键新建会AutoHotKey Srcipt后缀为ahk。例如创建demo.ahk，其内容如下\n\n```ahk\n<+<!I::Send {Up} \n<+<!K::Send {Down} \n<+<!J::Send {Left} \n<+<!L::Send {Right} \n<+<!H::Send {Home} \n<+<!;::Send {End} \n```\n\n然后保存双击该文件，即可运行autohotkey，此时打开任意文本，键入<kbd>Shift</kbd> + <kbd>Ctrl</kbd> + [HIJKL;] 就可以看到光标上下左右移动。\n\n这里对上面语法进行讲解\n\n| 键名  | 热键标识 |\n| ----- | -------- |\n| Ctrl  | ^        |\n| Shift | +        |\n| Alt   | !        |\n| Win   | #        |\n\n如果要针对左右Ctrl或Shfit只需要在前面添加`<` `>` 。`::`则作为映射关系，左边的按键作用于何种指令，而右侧则是左侧按键所对应的指令，这里的指令相对简单，只是发送键盘上下左右的关系，指令还可以实现信息框MsgBox 启动应用等等。具体还有更多键盘与鼠标热键详情可在AutoHotkey Help手册中查看，非常详细，不过是英文。\n\n具体要映射的快捷键可自行发挥，但要切记不建议与常用快捷键冲突，例如上面为何是IJKL而不是WASD，其原因会导致快捷键冲突。\n\n此外AutoHotkey不仅能做键盘映射，实现宏定义，一键启动任务也不成问题，篇幅有限，就不做过多演示，有兴趣可自行研究。"
    },
    {
      "id": "frontend-interview-experience",
      "metadata": {
        "permalink": "/frontend-interview-experience",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/reference/记一次前端面试过程.md",
        "source": "@site/blog/reference/记一次前端面试过程.md",
        "title": "记一次前端面试过程",
        "description": "记录一次前端面试过程",
        "date": "2022-06-25T00:00:00.000Z",
        "formattedDate": "2022年6月25日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "面试",
            "permalink": "/tags/面试"
          },
          {
            "label": "fontend",
            "permalink": "/tags/fontend"
          }
        ],
        "readingTime": 8.44,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "frontend-interview-experience",
          "title": "记一次前端面试过程",
          "date": "2022-06-25T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "面试",
            "fontend"
          ],
          "keywords": [
            "随笔",
            "面试",
            "fontend"
          ],
          "description": "记录一次前端面试过程",
          "draft": true
        },
        "prevItem": {
          "title": "AutoHotkey键盘映射",
          "permalink": "/autohotkey"
        },
        "nextItem": {
          "title": "浅谈个人学习方式",
          "permalink": "/learning-style"
        }
      },
      "content": "考试终于结束了，也将近一个月没怎么写代码和文章了，准备调整下自身状态，开始进一步的学习。然后在前段时间我的一个同校同学拿到了 xx 公司的 offer，然后该公司正好有招前端开发实习，就问我有没有兴趣尝试一下，但一开始我内心其实不是很想工作的，想着暑假去闭关学其他技术，同时加上我目前的身份**准大三(休学一年)**实习期可能也就 2 个月，毕竟这行业不同于打工，是需要长期工作和维护。不过一想毕竟没面试过，所以就蛮去尝试一下，至于最终的结果，阅读全文吧。\n\n<!-- truncate -->\n\n## 简历\n\n我的那位同学给我推了面试官的微信，于是加完微信，简单的几句招呼便直接开始找我要了一份**简历**，也就是整个面试过程中最重要的物件，即**面试的前提**。\n\n很显然我压根就没有准备过这玩意，然后面试官叫我去准备一下（期间聊天强调过几次有空准备下简历），于是就去网上搜寻了关于简历说明、编写建议与简历模板，也了解到简历对面试者的一个重要性。\n\n**简历是面试官了解面试者最快方式**，甚至可以说对于大部分人群是非要不可。于是我花费了一天的时间去准备了一份属于自己的简历，主要内容为个人的基本信息、技术特长、个人描述、教育背景、工作经验、项目经验等，其内容一定要真实，同时也要在精简的同时，让面试官一眼就能看到你的亮点，以及将来你到贵公司工作能为其提供的帮助，这些在外面的大部分简历编写建议中也有提及，这里我也仅是简单总结。\n\n关于我的简历就不展示了（毕竟暂时比较烂），不过关于简历模板的话，我倒是可以推荐下。我所使用的是 [木及简历](https://www.mujicv.com/)，此外还有 [Markdown 简历排版工具 (mdnice.com)](https://resume.mdnice.com/) 与 [简历自动生成 (sugarat.top)](https://resume.sugarat.top/) ，这些都是我在搜寻资料中认为不错的在线简历模板。\n\n最主要是丰富自身的阅历与技术，这样在简历编写时，其内容是一定能吸引到面试官的注意。要是什么技能都不会，什么项目都没有，一份不起眼的简历，作为面试官是很难给你一个面试的机会。\n\n如果你已经看到这里了，并且你未来有找工作的需求，那么现在就可以着笔简历，而不是等到要找工作的时候在准备。同时在日常开发与学习中，也可以不断去完善自身简历。**总之，越早写简历越好**。\n\n将简历提交给面试官后，如果叫你准备下面试，那么恭喜，已经进入第二步------**面试**\n\n## 面试\n\n这次预定为周六早上 10 点（即本文发布日期）**线上面试**（无屏幕共享，只单纯聊聊技术栈相关），正常来说知道自己要被面的话，应该来说会提前做些准备。然而我就不一样了，我**没刷过任何面试题**（八股文），所以我想看看我的知识储备能否回答出这些问题，结果也确实如此，这次面试大多数问题回答不出来或者回答的半知半解的。\n\n### 问技术\n\n关于所问的问题，和外面主流的前端面试大致，这些就是考验基本功的问题，例如 HTML5 的新特性，JS 的一些语法等等，这些在八股文在面试过程中是必须要背的，因为这些决定计算机的基本功。此外面试官在了解你的大致技术栈后，必然会针对你简历上的内容，提出一些针对性的问题。比方说我在简历上写了一个后台管理系统 [KzAdmin](https://admin.kuizuo.cn) 其中就有问到像 JWT，axios 封装，前端菜单展示等问题，然后和一个[JavaScript 的混淆与还原](https://deobfuscator.kuizuo.cn/)，就问这个主要功能，以及其中所涉及的一些技术栈相关的。\n\n至于整个面试所关于技术的问题与细节就不一一列举了，不过令我意外的是，所问题的竟然没有算法题，不过事后想想也对线上面试还无共享屏幕的前提下，咋可能问算法题呢，最多也就是问问你对你的技术栈的了解程度与理解情况，整个过程与我预期所想符合。\n\n### 闲谈\n\n最后就是表明他们的项目可能是需要长期的，然后我目前的情况又相对比较特殊，问我下学期课程的安排啥的。相对面试者比较在意的就是薪资，但在这次谈论期间是没有关于薪资的，我和面试官都没提，我自然是不敢提的，毕竟问题都回答的那么烂了，哪里还好意思提，同时这是实习岗位，自然薪资不会高到哪里去的。\n\n当然了，整个面试过程最后一句话是**回去等通知**\n\n### 等待面试结果\n\n通常面试都有以下三种结果。\n\n第一、现场录用。第二、当场拒用。第三、回去等通知\n\n大多数面试结果都是第三条，我自然不例外。至于有没有二面啥的，自我感觉有个 7 成左右。为何不敢说百分百呢？从整个面试的过程来看，其实我准备时间是充分的，但根本没怎么准备，甚至可以说全程是种摆烂的态度。再从回答问题上来看，我整个回答情况就表明告诉面试官我没准备好这次面试，加上一开始没准备好简历，就相当于我就是来面着玩的 😂。\n\n公司面对这类面试者（求职意向不是很明确，情况特殊），大概率就是直接刷掉了。当然，这只是我的个人对此次面试的看法，如果有二面的话，我一定好好刷面试题，顺带锻炼下表达能力（现在在回想整个回答过程，我甚至都不好意思说我是学前端的了）。如果没有的话，算了不去想了。\n\n## 面试结果\n\n承接上文，直到考试结束任然没收到任何通知，即挂了。其原因其实我也在上文中说到，我的面试态度相对比较差，加上实习期限的原因。不过后话来说，即便我收到了这份offer我也不一定会去，当然这里说这种话确实有那么一点不好，但首先我是工作过（虽然不算一个体系的公司，只能算作工作室），而且给我分配的时间充裕，而且薪资还不低，并且当时涉及的业务还是我相对比较强项的协议复现和逆向（虽然我已经快半年没碰，而且大概率会在持续半年的时间不接触逆向相关的）。但每天的任务就是等待产品经理的需求，这时就需要停下手头的事情，来完成任务，大部分的时间都是在测试和维护。虽说和与搬砖打工有点区别，但本质无异，都是枯燥任务。同时我本身是挺反感重复任务与中断的，所以上一份的工作给我的感受就是（时间）充实但又夹杂着（任务）枯燥，但很多时候就不得不妥协，因为生活所迫，这里就不做感慨了。\n\n总之，这次的面试结果也并不让我意外，甚至可以说是情理之中。\n\n## 总结与建议\n\n对整个面试的过程对我而言就是要锻炼自身表达能力，在除了没刷八股文外，像一些问题，我很难用口语去告诉面试官我的意思，但使用屏幕共享加代码展示就不一样，但当时的面试官没提加上我也没主动申请，这是我认为整个过程比较可惜的一点。不过整个过程下来，我认为面试也没什么的，无非就是问问题，平常多刷面试题。\n\n关于一些建议的话：\n\n首先就是个人简历非常重要，最好添写个人[Github](https://github.com/)与[博客](https://kuizuo.cn)，绝对是面试的加分项。尤其是博客，在上面所分享的内容，也可能会吸引到一些需要招聘你的 HR。至少告诉面试官你有在学习，并且懂得记录。其次就是简历上一定要有能亮眼的地方同时自己又很掌握的项目经验，这样面试官针对性的问题，对自身也有很好的作答。如果自己掌握程度不是很大的情况下，还是不建议编写，即便学过，但忘了，那就是不会（说的不就是我吗）。\n\n一个好的简历谁都会写，但面试不是一纸千金，工作更不是纸上谈兵。简历是了解一个人的基本资料，而面试主要是考察一个人的工作能力与综合素质，即便你工作能力再强大，但你工作态度属于摸鱼的状态，同样是无法胜任此工作的。所以既然选择要工作，那就应该做足准备，拿出最好的工作态度给面试官。\n\n所以我一开始的目的到底是什么呢？准备实习工作呢？还是闭关学习呢？又或者是..."
    },
    {
      "id": "learning-style",
      "metadata": {
        "permalink": "/learning-style",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/lifestyle/浅谈个人学习方式.md",
        "source": "@site/blog/lifestyle/浅谈个人学习方式.md",
        "title": "浅谈个人学习方式",
        "description": "临近考试周，又要开始准备复习，顺带总结下自己平常的学习方式与一些感慨。",
        "date": "2022-06-10T00:00:00.000Z",
        "formattedDate": "2022年6月10日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "杂谈",
            "permalink": "/tags/杂谈"
          }
        ],
        "readingTime": 5.076666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "learning-style",
          "title": "浅谈个人学习方式",
          "date": "2022-06-10T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "杂谈"
          ],
          "keywords": [
            "随笔",
            "杂谈"
          ]
        },
        "prevItem": {
          "title": "记一次前端面试过程",
          "permalink": "/frontend-interview-experience"
        },
        "nextItem": {
          "title": "Vercel部署Serverless",
          "permalink": "/vercel-deploy-serverless"
        }
      },
      "content": "临近考试周，又要开始准备复习，顺带总结下自己平常的学习方式与一些感慨。\n\n<!-- truncate -->\n\n我个人主要的两种学习方式，**主动学习**与**被动学习**\n\n## 主动学习 ✍\n\n通常来说，主动学习往往是一件痛苦的事情。就如考试周，平常的课该去在课堂上睡觉，该不去的在宿舍睡觉，到考试周，一学期的课没听，但一想到不复习就有可能面临挂科，或多或少都会复习。考试摆烂，挂科惨淡。\n\n除了上面是会导致坏结果而去学习，那么还有一种则是与之相反，也就是所需，所感兴趣的去学习。\n\n例如我想要实现一个酷炫功能，或者是一个需求时，而其中需要的知识点便会去了解与学习。\n\n对于前者而言，其过程并不舒服，甚至可以说是逼自己学习不喜欢的东西，通常我是不如不学的，即便学了在以后也难以记起，除非不学的结果比较严重（如挂科）。而后者情况便不同，兴趣是最好的老师，甚至都不需要借助外界因素去激励，便能有一个很好的学习成果。\n\n如果没有兴趣或需求的情况下，那么主动学习一定要定制一系列的目标，如果没有明确的目标，学习将会显得十分迷茫。我有很多时候便是这样，想去主动去学习诸多技术栈，不知从何下手。\n\n## 被动学习 📘\n\n其实可以说是利用业余时间学习的一个方式，首先我会想我一天主要做的事情（通常是与学习无关），比如刷各个平台（b 站，抖音）的视频，刷知乎，qq 群闲聊等等，这里只是以我一天的大部分日常举例。\n\n此事不妨关注一些与学习类的账号，包括但不限于加入一些技术交流群， up 主，公众号，博主等等，当你每次刷这类平台时，系统很自然就会给你推送相关内容，比方说 b 站，我日常会在上面刷一些鬼畜视频，生活娱乐视频，但也会关注一些技术类的账号，在娱乐的同时，还能不经意间刷到一些编程知识（知乎，微信公众号同理），这送上门的知识不香吗？\n\n再比如 watch 一些开源项目，订阅一些博客文章，定时推送Hacker News周刊等等，在他们发布一些重要内容的时候能及时通知到你。虽然这样每天邮箱时常处于未读状态，但如果打开某一条邮箱查看其中的内容，说不定又是一次不错的收获。\n\n当然，这样学习肯定有一定弊端。首先所摄取的知识过于笼统，一般都是由别人推荐的，甚至有可能会浪费你人生中的几分钟，因为这些知识点可能你已经掌握了，或者这些知识确实没什么干货。其次所获取到的知识往往是整个知识面的冰上一角，或者是某些新型技术，但想要深入去学习还是得按上面的主动学习。\n\n被动学习主要的作用能让你在不学习的状态下，还能获取相对应的知识。听起来可能觉得很卷，无时无刻的在学习，但我认为在娱乐中学习往往不会显得像主动学习那般有种疲惫感。\n\n我在被动学习中就间接了解到许多的前沿的技术栈，以及了解到许多之前没使用过的语言、框架特性，而这些都是直接送上门的知识点，而我要做的只是关注一些账号，订阅一些文章或站点，而不用自己去茫茫知识海洋中去寻求。\n\n## 两者的权衡\n\n我时常处于这类被动学习状态，因为我对很多技术点都很感兴趣，但又不知道从何下手，而当我刷到我所感兴趣的东西时，我才会开始转为主动学习。之所以会出现这样的学习状态转型，有很大一部分是因为**兴趣感已经没有一开始所学的那么强烈，甚至可以说有些许乏味**。\n\n在一开始接触时，我是抱着强烈的兴趣感去学的，处于一种非常积极的主动学习状态，当时所获取的知识是无法用现在同等时间所堪比。然而在兴趣感消散，这种状态都为浮云。主动学习的频率减弱，每天都在做着与学习无关的事情，这期间与知识没有任何的往来。\n\n直到将每天所要做的事情，间接的转为被动学习的方式，至少有在学习，而不是在停步，即便是行走 1 厘米，那也是米。\n\n## 总结\n\n最好是对感兴趣的方面学习，这样即有动力去学习，有不会感到厌烦，并且兴趣是能陪伴很久的，也往往能坚持下去。\n\n无论是任何事情在任何时候下都应该保持的是一种不断坚持的状态，打游戏也好，学习也好。\n\n一段时间不打游戏，手感生疏，再次接触就没状态。\n一段时间不学知识，容易忘记，再次使用就没印象。\n\n大部分人都是如此，可谁又不希望保持一种不断坚持的状态。毕竟不是每个人都有充裕的个人资源与时间资源，很多时候这些资源并不是由自己分配的，有可能是亲朋好友，也有可能是上司老板，最有可能是生活所迫。。。\n\n**唯愿此生，岁月静好**"
    },
    {
      "id": "vercel-deploy-serverless",
      "metadata": {
        "permalink": "/vercel-deploy-serverless",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Vercel部署Serverless.md",
        "source": "@site/blog/program/Vercel部署Serverless.md",
        "title": "Vercel部署Serverless",
        "description": "使用 Vercel 部署 serverless 过程记录",
        "date": "2022-05-12T00:00:00.000Z",
        "formattedDate": "2022年5月12日",
        "tags": [
          {
            "label": "vercel",
            "permalink": "/tags/vercel"
          },
          {
            "label": "serverless",
            "permalink": "/tags/serverless"
          }
        ],
        "readingTime": 2.8466666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "vercel-deploy-serverless",
          "title": "Vercel部署Serverless",
          "date": "2022-05-12T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "vercel",
            "serverless"
          ],
          "keywords": [
            "vercel",
            "serverless"
          ],
          "description": "使用 Vercel 部署 serverless 过程记录"
        },
        "prevItem": {
          "title": "浅谈个人学习方式",
          "permalink": "/learning-style"
        },
        "nextItem": {
          "title": "使用Github Action自动化部署",
          "permalink": "/use-github-action-to-auto-deploy"
        }
      },
      "content": "Vercel 除了能部署静态站点外，还能运行 Serverless Functions，也是本次的主题\n\n<!-- truncate -->\n\n## 创建接口\n\n> To deploy Serverless Functions without any additional configuration, you can put files with extensions matching [supported languages](https://vercel.com/docs/concepts/functions/supported-languages) and exported functions in the `/api` directory at your project's root.\n\nvercel 约定在目录下 api 下创建接口路径，这里创建 api/hello.js 文件，当然也支持 ts 以及 ESmodule 写法\n\n```javascript title='api/hello.js'\nexport default function handler(request, response) {\n  const { name } = request.query\n  response.status(200).send(`Hello ${name}!`)\n}\n```\n\n此时通过`vc --prod`生产环境部署后，在浏览器请求 vercel 提供的二级域名/api/hello?name=vercel 便可得到文本`Hello vercel`，而其函数写法与 express 类似\n\n接口信息可以在 Functions 中查看\n\n![image-20220512155341109](https://img.kuizuo.cn/image-20220512155341109.png)\n\n### 使用 typescript\n\n不过上面是使用 js 写法，vercel 更推荐[使用 TypeScript](https://vercel.com/docs/concepts/functions/serverless-functions/supported-languages#using-typescript)\n\n安装 `@vercel/node`\n\n```\nnpm i -D @vercel/node\n```\n\n将上面的 hello.js 改为 hello.ts，内容为\n\n```typescript title='api/hello.ts'\nimport type { VercelRequest, VercelResponse } from '@vercel/node'\n\nexport default (request: VercelRequest, response: VercelResponse) => {\n  const { name } = request.query\n  response.status(200).send(`Hello ${name}!`)\n}\n```\n\n此外还可以使用其他语言，这里为 Vercel 所支持的[语言](https://vercel.com/docs/concepts/functions/serverless-functions/supported-languages#supported-languages:)\n\n### 开发环境\n\n上面创建的例子是在生产环境下进行的，vercel 官方非常贴心的提供了 vercel dev 来用于开发环境（本地调试）。\n\n```\nvercel dev\n```\n\n执行后，将会默认开启 3000 端口来启动服务，此时访问 http://localhost:3000/api/hello 就可调用该接口\n\n## vercel.json\n\n在根目录创建[vercel.json](https://vercel.com/docs/project-configuration)，用于设置 Vercel 项目配置 ，其配置结构与 Nextjs 的 next.config.js 大体一致。\n\n### headers\n\nvercel 允许响应携带自定义的协议头，例如设置允许跨域的协议头。\n\n```json title='vercel.json'\n{\n  \"headers\": [\n    {\n      \"source\": \"/(.*)\",\n      \"headers\": [\n        {\n          \"key\": \"Access-Control-Allow-Origin\",\n          \"value\": \"*\"\n        },\n        {\n          \"key\": \"Access-Control-Allow-Headers\",\n          \"value\": \"content-type\"\n        },\n        {\n          \"key\": \"Access-Control-Allow-Methods\",\n          \"value\": \"DELETE,PUT,POST,GET,OPTIONS\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### rewrites\n\nVercel 支持路由重写功能，因此我们可以实现反向代理。\n\n例如将前缀为/proxy 的所有请求都代理到 http://127.0.0.1:5000，其写法如下\n\n```json title='vercel.json'\n{\n  \"rewrites\": [{ \"source\": \"/proxy/:match*\", \"destination\": \"http://127.0.0.1:5000/:match*\" }]\n}\n```\n\n请求`/proxy/hello` 将会请求到 `http://127.0.0.1:5000/hello`（不带有`/proxy`）\n\n:::caution\n\n注意无法代理前缀为/api 的接口，即使设置了也无效。\n\n:::\n\n#### redirects 和 rewrites 区别\n\n除了 rewrites 还有一个 redirects，也就是重定向，response 返回 3xx 的状态码和 location 头信息。\n\n而 rewrites 重写内部转发了请求，地址栏不会发生改变，并且状态码由转发的请求决定。\n\n并且 redirects 是先被调用的，而 rewrites 是后被调用的。\n\n### functions\n\n可以设置指定接口分配的内存以及最大执行时间。默认下\n\n- Memory: 1024 MB (1 GB)\n- Maximum Execution Duration: 5s (Hobby), 15s (Pro), or 30s (Enterprise)\n\n个人用户接口超时时间最长为 5 秒。\n\n## 部署 Node 项目\n\n可以使用 vercel.json 配置来覆盖 vercel 默认行为，也就能使用 Vercel 部署 Node 项目。\n\n假设要部署一个 Express 项目，则配置如下\n\n```json title='vercel.json'\n{\n  \"builds\": [\n    {\n      \"src\": \"app.js\",\n      \"use\": \"@vercel/node\"\n    }\n  ]\n}\n```\n\n安装 `@vercel/node`包\n\n```shell\nnpm i @vercel/node -D\n```\n\n然后运行 vercel，而不是~~vercel --prod~~\n\n### 部署 Nest.js\n\n这里有个部署 Nest.js 项目的教程 [基于 Vercel+Github Action 部署 Nest.js 项目 - 掘金 (juejin.cn)](https://juejin.cn/post/7023690214803505166)\n\n其 vercel.json 如下\n\n```json title='vercel.json'\n{\n  \"builds\": [\n    {\n      \"src\": \"dist/main.js\",\n      \"use\": \"@vercel/node\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"dist/main.js\"\n    }\n  ]\n}\n```\n\n然后执行 vercel --prod（因为 nest 项目需要 build 打包）\n\n## 最后\n\nVercel 十分良心，为个人用户提供了免费的爱好者计划，每个月提供 100G 流量，构建时间是 100 小时，50 个根域名绑定。"
    },
    {
      "id": "use-github-action-to-auto-deploy",
      "metadata": {
        "permalink": "/use-github-action-to-auto-deploy",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/使用Github Action自动化部署.md",
        "source": "@site/blog/develop/使用Github Action自动化部署.md",
        "title": "使用Github Action自动化部署",
        "description": "如果有写过项目的经历，就免不了将代码上传到服务器上，安装依赖，然后输入启动命令的步骤。但是有的项目往往需要经常性的改动，如果还是照着上面的方式进行部署的话。先不说这样操作的效率，操作个几次就想罢工了。并且上面这样操作的往往容易误操作。而 Github Actions 正是该问题的良药。",
        "date": "2022-05-11T00:00:00.000Z",
        "formattedDate": "2022年5月11日",
        "tags": [
          {
            "label": "github",
            "permalink": "/tags/github"
          },
          {
            "label": "git",
            "permalink": "/tags/git"
          }
        ],
        "readingTime": 4.7,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "use-github-action-to-auto-deploy",
          "title": "使用Github Action自动化部署",
          "date": "2022-05-11T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "github",
            "git"
          ],
          "keywords": [
            "github",
            "git"
          ]
        },
        "prevItem": {
          "title": "Vercel部署Serverless",
          "permalink": "/vercel-deploy-serverless"
        },
        "nextItem": {
          "title": "Vercel部署个人博客",
          "permalink": "/vercel-deploy-blog"
        }
      },
      "content": "如果有写过项目的经历，就免不了将代码上传到服务器上，安装依赖，然后输入启动命令的步骤。但是有的项目往往需要经常性的改动，如果还是照着上面的方式进行部署的话。先不说这样操作的效率，操作个几次就想罢工了。并且上面这样操作的往往容易误操作。而 Github Actions 正是该问题的良药。\n\n<!-- truncate -->\n\n## 介绍\n\nGithub Actions 是 Github 提供的免费自动化构建实现，特别适用于持续集成和持续交付的场景，它具备自动化完成许多不同任务的能力，例如构建、测试和部署等等。\n\n## 概念\n\n在进行操作前，先对 Github Actions 基础知识进行补充，具体可查看 [GitHub Actions 入门教程 阮一峰](https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)\n\n可以在 [GitHub Marketplace · Actions to improve your workflow](https://github.com/marketplace?type=actions) 中找到所有的 Actions。\n\n## 实例：将 VIte 项目发布到 GitHub Pages\n\n第一步：创建一个 Vite 工程，可在[官网](https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project)中查看如何安装\n\n```\npnpm create vite\n```\n\n选择对应的项目名（vite-project）与模板（vue-ts）\n\n第二步：打开`package.json`文件，加一个`homepage`字段，表示该应用发布后的根目录（参见[官方文档](https://create-react-app.dev/docs/deployment#building-for-relative-paths)）。\n\n```\n\"homepage\": \"https://[username].github.io/vite-project\",\n```\n\n上面代码中，将`[username]`替换成你的 GitHub 用户名。\n\n第三步：在这个仓库的`.github/workflows`目录，生成一个 workflow 文件，名字可以随便取，这个示例是`ci.yml`。\n\nworkflow 文件如下\n\n```yml\nname: Build and Deploy\non:\n  push:\n    branches:\n      - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Install and Build\n        run: |\n          yarn install\n          yarn run build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          personal_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_dir: ./dist\n```\n\n上面这个 workflow 文件的要点如下\n\n1. 整个流程在`master`分支发生`push`事件时触发。\n2. 只有一个`job`，运行在虚拟机环境`ubuntu-latest`。\n3. 第一步是获取源码，使用的 action 是`actions/checkout`。\n4. 第二步是安装依赖与构建，`yarn install`和`yarn run build`\n5. 第三步是部署到 Github Page 上，使用的 action 是 [peaceiris/actions-gh-pages@v3](https://github.com/marketplace/actions/github-pages-action)。其中需要设置 secrets.ACCESS_TOKEN\n\n第四步：将项目上传置 Github 仓库中，\n\n该 peaceiris/actions-gh-pages 支持三种 Token，这里使用 personal_token，其生成教程在[官方文档](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)中有详细图文，这里就不贴其生成的图了。**不过记得权限过期以及勾选上 workflow**\n\n:::tip Tip\n\ntoken 只会在生成的时候显示一次，如需要再次显示，则可以点击，但使用此令牌的任何脚本或应用程序都需要更新！\n\n:::\n\n然后在**Settings -> Secrets -> Actions 中 New repository secret**中便可添加 secret。\n\n![image-20220511122017247](https://img.kuizuo.cn/image-20220511122017247.png)\n\n这时候只要一调用 git push，就会触发对应的 workflows 文件配置。点击 Actions 便可看到 jobs 工作。\n\n![image-20220511122420135](https://img.kuizuo.cn/image-20220511122420135.png)\n\n此时访问https://kuizuo.github.io/vite-project就可呈现vite项目（不过我已经把仓库给关闭了），但进入会白屏，控制台提示\n\n![image-20220511122914534](https://img.kuizuo.cn/image-20220511122914534.png)\n\n很显然，需要静态资源请求的路径错了，正确的应该是https://kuizuo.github.io/vite-project/assets/index.2435d274.js，根据Vite中的[构建生产版本](https://www.vitejs.net/guide/build.html#public-base-path) 通过命令行参数 `--base=/vite-project/`\n\n稍加操作在 Install and Build 加上 base 参数\n\n```\n      - name: Install and Build\n        run: |\n          yarn install\n          yarn run build --base=/vite-project/\n```\n\ngit push 后，稍等片刻再次访问便可得到如下页面\n\n![image-20220511125536189](https://img.kuizuo.cn/image-20220511125536189.png)\n\n## FTP发布到自有服务器上\n\n那么现在在 Github Page 上搭建好了，但还要将编译后的文件还可以通过 FTP 协议添加自己的服务器上，这里我就以我的博客为例。\n\n在服务器中开启 FTP，并添加一个用户名,密码以及根目录(这里我问选择为项目目录)\n\nworkflow 要做的就是新建一个 steps，这里选用 [FTP-Deploy-Action](https://github.com/SamKirkland/FTP-Deploy-Action)，以下是我的完整配置内容\n\n```yml\nname: FTP Deploy\n\non: [push]\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Use Node.js 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16.x'\n\n      - name: Build Project\n        run: |\n          yarn install\n          yarn run build\n\n      - name: FTP Deploy\n        uses: SamKirkland/FTP-Deploy-Action@4.0.0\n        with:\n          server: ${{ secrets.ftp_server }}\n          username: ${{ secrets.ftp_user }}\n          password: ${{ secrets.ftp_pwd }}\n          local-dir: ./build/\n          server-dir: ./\n```\n\n相信第一个实例中的 workflow 应该已经明白了，其中 ftp_server，ftp_user，ftp_pwd 都是私密信息，所以需要 New repository secret 设置这三个变量。\n\n但由于 build 下存在大量文件夹与文件，所以 FTP 速度上传速度堪忧，最终耗时 17 minutes 38.4 seconds。这里只是作为 FTP 演示。\n\n## SCP发布到自有服务器上\n\nFTP 传输文件着实过慢，所以可以通过 SCP 的方式来传输文件，这里用到了[ssh deploy · Actions](https://github.com/marketplace/actions/ssh-deploy)，以下是示例\n\n```yaml\nname: ci\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Use Node.js 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16.x'\n\n      - name: Build Project\n        run: |\n          yarn install\n          yarn run build\n\n      - name: SSH Deploy\n        uses: easingthemes/ssh-deploy@v2.2.11\n        env:\n          SSH_PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}\n          ARGS: '-avzr --delete'\n          SOURCE: 'build'\n          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}\n          REMOTE_USER: 'root'\n          TARGET: '/www/wwwroot/blog'\n```\n\n其中 **PRIVATE_KEY** 为服务器SSH登录的私钥，**REMOTE_HOST** 就是服务器的ip地址。当然，这些参数也都作为私密信息，也是要通过New repository secret来设置的。\n\n## 总结\n\n从上面的演示便可看出 Github Actions 的强大，但其实我挺早之前就了解到它能做这些事情，但迟迟没有动手尝试一番，因为这些自动化操作用人工也是能完成的。也许当时的我认为，用人工所花费的时间远比自动化操作的学习时间来的长，可又随着自己的个人应用增加，每次都需要手动发布，而此时前者的时间已远远大于后者，所以才会想去学习。\n\n明知该技术是一定会接触的，为何不趁现在去了解学习呢？"
    },
    {
      "id": "vercel-deploy-blog",
      "metadata": {
        "permalink": "/vercel-deploy-blog",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Vercel部署个人博客.md",
        "source": "@site/blog/program/Vercel部署个人博客.md",
        "title": "Vercel部署个人博客",
        "description": "使用 Vercel 部署个人博客过程记录，简单方便、访问快、免费部署。",
        "date": "2022-05-11T00:00:00.000Z",
        "formattedDate": "2022年5月11日",
        "tags": [
          {
            "label": "vercel",
            "permalink": "/tags/vercel"
          },
          {
            "label": "blog",
            "permalink": "/tags/blog"
          }
        ],
        "readingTime": 4.07,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "vercel-deploy-blog",
          "title": "Vercel部署个人博客",
          "date": "2022-05-11T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "vercel",
            "blog"
          ],
          "keywords": [
            "vercel",
            "blog"
          ],
          "description": "使用 Vercel 部署个人博客过程记录，简单方便、访问快、免费部署。",
          "image": "https://img.kuizuo.cn/image-20220511170700075.png"
        },
        "prevItem": {
          "title": "使用Github Action自动化部署",
          "permalink": "/use-github-action-to-auto-deploy"
        },
        "nextItem": {
          "title": "kz-admin后台管理系统",
          "permalink": "/kz-admin"
        }
      },
      "content": "![image-20220511170700075](https://img.kuizuo.cn/image-20220511170700075.png)\n\n:::tip 观前提醒\n\n[Vercel](https://vercel.com/) 部署静态资源网站极其**简单方便**，并且有可观的**访问速度**，最主要的是**免费部署**。\n\n如果你还没有尝试的话，强烈建议去使用一下。\n\n:::\n\n[vercel 介绍](https://zhuanlan.zhihu.com/p/452654619)\n\n与之相似的产品 [Netfily](https://netlify.com)，如果你想部署私有化，推荐 [Coolify](https://coolify.io)\n\n如果你想搭建一个类似这样的站点，不妨参考我的 [Docusaurus 主题魔改](/docs/docusaurus-guides)\n\n:::danger DNS 污染\n\n由于某些原因，vercel.app 被 DNS 污染（即被墙），目前在国内已经无法打开，除非你有自己的域名，通过 CNAME 解析访问你的域名。\n\n**因此想要在国内访问，建议不要使用 Vercel 部署了，最好选用 Netlify。**\n\n:::\n\n<!-- truncate -->\n\n## 注册账号\n\n进入 [Vercel](https://vercel.com) 官网，先去注册一个账号，建议注册一个 [Github](https://github.com/) 账号后，使用 Github 账号来登录 Vercel。\n\n## 部署网站\n\n进入 [Dashboard](https://vercel.com/dashboard)\n\n![image-20220511170233559](https://img.kuizuo.cn/image-20220511170233559.png)\n\n点击 [New Project](https://vercel.com/new)\n\n![image-20220511165902993](https://img.kuizuo.cn/image-20220511165902993.png)\n\n这里可以从已有的 git repository 中导入，也可以选择一个模板。\n\n这里登录我的 Github 账号选择仓库，然后点击 blog 仓库旁的 Import 即可。当然，你也可以直接拉取我的仓库，仓库地址：[kuizuo/blog](https://github.com/kuizuo/blog)\n\n![image-20220511165513526](https://img.kuizuo.cn/image-20220511165513526.png)\n\n点击 Deploy，然后静等网站安装依赖以及部署，稍后将会出现下方页面。\n\n![image-20220511170700075](https://img.kuizuo.cn/image-20220511170700075.png)\n\n此时网站已经成功搭建完毕了，点击图片即可跳转到 vercel 所提供的二级域名访问。\n\n是不是极其简单？**甚至不需要你输入任何命令，便可访问构建好的网站。**\n\n## 自定义域名\n\n如果有自己的域名，还可以在 vercel 中进行设置。\n\n首先进入 blog 的控制台，在 Settings -> Domains 添加域名。\n\n![image-20220511171144240](https://img.kuizuo.cn/image-20220511171144240.png)\n\n接着提示域名需要 DNS 解析到 vercel 提供的记录值\n\n![image-20220511171359148](https://img.kuizuo.cn/image-20220511171359148.png)\n\n登录所在的域名服务商，根据 Vercel 提供的记录值 cname.vercel-dns.com，添加两条记录\n\n![image-20220511172741663](https://img.kuizuo.cn/image-20220511172741663.png)\n\n此时回到 Vercel，可以看到记录值成功生效。\n\n![image-20220511172027570](https://img.kuizuo.cn/image-20220511172027570.png)\n\n此时访问自己的域名，同样也能访问到页面，同时还有可观的访问速度。\n\n### 自动颁发 SSL 证书\n\n默认状态下，Vercel 将会颁发并自动更新 SSL 证书。（着实方便，不用自己手动去申请证书，配置证书）\n\n![image-20220511172240999](https://img.kuizuo.cn/image-20220511172240999.png)\n\n## 持续集成（CI）/持续部署（CD）\n\n> To update your Production Deployment, push to the \"main\" branch.\n\n当主分支有代码被推送，Vercel 将会重新拉取代码，并重新构建进行单元测试与部署（构建速度可观）\n\n![image-20220511173442694](https://img.kuizuo.cn/image-20220511173442694.png)\n\n## Serverless\n\n同时 vercel 还支持 serverless，也就是说，不仅能部署静态站点，还能部署后端服务，不过肯定有一定的限制。\n\n[Vercel 部署 Serverless](/vercel-deploy-serverless)\n\n## Edge Functions\n\n翻译过来叫边缘函数，你可以理解为在 Vercel 的 CDN 上运行的函数，可以在 Vercel 的 CDN 上运行代码，而不需要在服务器上运行。\n\n由于这类函数和静态资源一样，都通过 CDN 分发，因此它们的执行速度非常快。\n\n官网介绍：[Edge Functions](https://vercel.com/docs/concepts/functions/edge-functions)\n\n## Vercel CLI\n\n有时候并不想登录网页，然后新建项目，选择仓库，拉取部署，而是希望直接在项目下输入命令来完成部署。vercel 自然肯定提供相对应的脚手架 **[CLI](https://vercel.com/docs/cli)** 供开发者使用。\n\n安装\n\n```\nnpm i -g vercel\n```\n\n在项目根目录中输入\n\n```\nvercel --prod\n```\n\n第一次将进行登录授权，选择对应平台，将会自动打开浏览器完成授权，接着将会确认一些信息，一般默认回车即可，下为执行结果\n\n```\nVercel CLI 24.2.1\n? Set up and deploy “F:\\Project\\React\\online-tools”? [Y/n] y\n? Which scope do you want to deploy to? kuizuo\n? Link to existing project? [y/N] n\n? What’s your project’s name? online-tools\n? In which directory is your code located? ./\nAuto-detected Project Settings (Create React App):\n- Build Command: react-scripts build\n- Output Directory: build\n- Development Command: react-scripts start\n? Want to override the settings? [y/N] n\n🔗  Linked to kuizuo12/online-tools (created .vercel and added it to .gitignore)\n🔍  Inspect: https://vercel.com/kuizuo12/online-tools/6t8Vt8rG3waGVHTKU7ZzJuGc6Hoq [2s]\n✅  Production: https://online-tools-phi.vercel.app [copied to clipboard] [2m]\n📝  Deployed to production. Run `vercel --prod` to overwrite later (https://vercel.link/2F).\n💡  To change the domain or build command, go to https://vercel.com/kuizuo12/online-tools/settings\n```\n\n执行完毕后，将会在根目录创建.vercel 文件夹，其中 project.json 中存放 orgId 和 projectId，下面将会用到。此时在[dashboard](https://vercel.com/dashboard)中也能看到该项目被部署了。\n\n不过这样部署上去的代码，并不会连接 git 仓库，需要到控制台中选择仓库即可。\n\n如果想在 github actions 中使用，则新建一个 steps，设置好对应的变量。\n\n```\n\t- name: Deploy to Vercel\n        run: npx vercel --token ${{VERCEL_TOKEN}} --prod\n        env:\n            VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}\n            VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}\n            VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}\n```\n\n还有一个 VERCEL_TOKEN 需要到 [Vercel Settings Tokens](https://vercel.com/account/tokens) 新建一个 Token。\n\n## 总结\n\n没什么好总结，直接上手使用，相信你会爱上 Vercel，以及他旗下的产品，[Next.js](https://github.com/vercel/next.js) 和 [Turbo](https://github.com/vercel/turbo) 等等。"
    },
    {
      "id": "kz-admin",
      "metadata": {
        "permalink": "/kz-admin",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/kz-admin后台管理系统.md",
        "source": "@site/blog/project/kz-admin后台管理系统.md",
        "title": "kz-admin后台管理系统",
        "description": "基于 NestJs + TypeScript + TypeORM + Redis + MySql + Vben Admin 编写的一款前后端分离的权限管理系统",
        "date": "2022-05-08T00:00:00.000Z",
        "formattedDate": "2022年5月8日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "admin",
            "permalink": "/tags/admin"
          },
          {
            "label": "vue",
            "permalink": "/tags/vue"
          },
          {
            "label": "nest",
            "permalink": "/tags/nest"
          }
        ],
        "readingTime": 8.586666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "kz-admin",
          "title": "kz-admin后台管理系统",
          "date": "2022-05-08T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "admin",
            "vue",
            "nest"
          ],
          "keywords": [
            "project",
            "admin",
            "vue",
            "nest"
          ],
          "description": "基于 NestJs + TypeScript + TypeORM + Redis + MySql + Vben Admin 编写的一款前后端分离的权限管理系统",
          "image": "/img/project/kz-admin.png"
        },
        "prevItem": {
          "title": "Vercel部署个人博客",
          "permalink": "/vercel-deploy-blog"
        },
        "nextItem": {
          "title": "关于开源许可证",
          "permalink": "/about-open-source-license"
        }
      },
      "content": "当时初学 Web 开发的时候，除了写一个网页博客外，第二个选择无非就是一个后台管理系统，可以应用于多种需要数据管理类项目中。\n\n基于**NestJs + TypeScript + TypeORM + Redis + MySql + Vben Admin**编写的一款前后端分离的权限管理系统\n\n演示地址：[KzAdmin](https://admin.kuizuo.cn) 管理员账号：admin 密码：123456\n\n<!-- truncate -->\n\n![image-20220505171231754](https://img.kuizuo.cn/image-20220505171231754.png)\n\n## 前端\n\n**基于[Vben Admin](https://vvbin.cn/doc-next/)开发，使用 Vue3、Vite、TypeScript 等最新技术栈，内置常用功能组件、权限验证、动态路由。**\n\n仓库地址：https://github.com/kuizuo/kz-vue-admin\n\n### [项目结构](https://vvbin.cn/doc-next/guide/#%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E)\n\n```bash\n├── build # 打包脚本相关\n│   ├── config # 配置文件\n│   ├── generate # 生成器\n│   ├── script # 脚本\n│   └── vite # vite配置\n├── mock # mock文件夹\n├── public # 公共静态资源目录\n├── src # 主目录\n│   ├── api # 接口文件\n│   ├── assets # 资源文件\n│   │   ├── icons # icon sprite 图标文件夹\n│   │   ├── images # 项目存放图片的文件夹\n│   │   └── svg # 项目存放svg图片的文件夹\n│   ├── components # 公共组件\n│   ├── design # 样式文件\n│   ├── directives # 指令\n│   ├── enums # 枚举/常量\n│   ├── hooks # hook\n│   │   ├── component # 组件相关hook\n│   │   ├── core # 基础hook\n│   │   ├── event # 事件相关hook\n│   │   ├── setting # 配置相关hook\n│   │   └── web # web相关hook\n│   ├── layouts # 布局文件\n│   │   ├── default # 默认布局\n│   │   ├── iframe # iframe布局\n│   │   └── page # 页面布局\n│   ├── locales # 多语言\n│   ├── logics # 逻辑\n│   ├── main.ts # 主入口\n│   ├── router # 路由配置\n│   ├── settings # 项目配置\n│   │   ├── componentSetting.ts # 组件配置\n│   │   ├── designSetting.ts # 样式配置\n│   │   ├── encryptionSetting.ts # 加密配置\n│   │   ├── localeSetting.ts # 多语言配置\n│   │   ├── projectSetting.ts # 项目配置\n│   │   └── siteSetting.ts # 站点配置\n│   ├── store # 数据仓库\n│   ├── utils # 工具类\n│   └── views # 页面\n├── test # 测试\n│   └── server # 测试用到的服务\n│       ├── api # 测试服务器\n│       ├── upload # 测试上传服务器\n│       └── websocket # 测试ws服务器\n├── types # 类型文件\n├── vite.config.ts # vite配置文件\n└── windi.config.ts # windcss配置文件\n```\n\n### 启动项目\n\n建议使用 pnpm 包管理器来管理 node 项目，使用`npm install -g pnpm`即可安装。\n\n```bash\npnpm install\n\npnpm run dev\n```\n\n运行结果\n\n```bash\n  vite v2.9.5 dev server running at:\n\n  > Network:  https://192.168.184.1:3100/\n  > Local:    https://localhost:3100/\n\n  ready in 5057ms.\n```\n\n> 注: 开发环境下首次载入项目会稍慢(Vite 在动态解析依赖)\n\n更多关于前端项目规范可直接参考 [Vben Admin 文档 ](https://vvbin.cn/doc-next/guide/introduction.html)，非常详细了。\n\n## 后端\n\n**基于 NestJs + TypeScript + TypeORM + Redis + MySql 编写的前后端分离权限管理系统**\n\n仓库地址：https://github.com/kuizuo/kz-nest-admin\n\n### [项目结构](https://blog.si-yee.com/sf-admin-cli/nest/usage.html#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E)\n\n```bash\n|─setup-swagger.ts # Swaager文档配置\n|─main.ts # 主入口\n|─config # 配置文件\n|─shared\n| |─redis # redisModule\n| | |─redis.module.ts\n| | |─redis.interface.ts\n| | |─redis.constants.ts\n| |─shared.module.ts\n| |─services # 全局通用Provider\n|─app.module.ts\n|─mission\n| |─mission.module.ts\n| |─mission.decorator.ts # 任务装饰器，所有任务都需要定义该装饰器，否则无法运行\n| |─jobs # 后台定时任务定义\n|─common # 系统通用定义\n| |─dto # 通用DTO定义\n| |─contants\n| | |─error-code.contants.ts # 系统错误码定义\n| | |─decorator.contants.ts # 装饰器常量\n| |─filters # 通用过滤器定义\n| |─interceptors # 通用拦截器定义\n| |─decorators # 通用装饰器定义\n| |─exceptions # 系统内置通用异常定义\n| |─class # Class Model 不使用Interface定义，使用Interface无法让Swagger识别\n|─modules\n| |─admin\n| | |─core # 核心功能\n| | | |─interceptors # 后台管理拦截器定义\n| | | |─decorators # 后台管理注解定义\n| | | |─provider # 后台管理提供者定义\n| | | |─guards # 后台管理守卫定义\n| | |─system # 系统模块定义\n| | |─account # 用户账户模块定义\n| | |─login # 登录模块定义\n| | |─admin.module.ts # 后台管理模块\n| | |─admin.constants.ts # 后台管理模块通用常量\n| | |─admin.interface.ts # Admin通用interface定义\n| |─ws # Socket模块\n|─entities # TypeORM 实体文件定义\n```\n\n### 启动项目\n\n依赖安装与执行打包命令前端与后端一致，但需要提前修改.env.development 中数据库相关配置，并执行 sql/init.sql 来初始化数据。\n\n### 实现\n\n项目中大部分的目录结构设计参照与[sf-nest-admin](https://github.com/hackycy/sf-nest-admin)，但主要为了贴合自我的代码风格修改部分数据字段名，接口方法，接口响应格式等等。\n\n同时对于大部分这类后台管理的 demo，通常都会定义用户，角色，菜单，部门。而我将部门相关代码删除，因为对于我后续项目大概率用不上这些部分，然后删了一些不相关的模块，主要写的这套模板还是用作自己后续的管理类项目。\n\n#### 用户-角色-权限\n\n这套系统中最为重要的一部分便是权限管理，不过在这套后台管理系统中这里的权限与菜单共用，前端路由渲染菜单，后端鉴权。后文的菜单表也就作为权限表而言。\n\n在这三张表中关系如下（这里使用外键与数据库模型为例，实际项目并未用到外键，也不推荐使用）\n\n![image-20220508235534026](https://img.kuizuo.cn/image-20220508235534026.png)\n\n用户-角色 与 角色-权限都采用的多对多的关系，即新创建一个表用于映射两表关系。这些都属于 mysql 基础，不做过多赘述。\n\n在权限管理中，最为重要的便是权限表了，由于这套后台管理系统中还涉及到前端的左侧菜单，所以将这里的 permission 表替换为 menu 表，字段 permission 表示权限值。数据库中的 menu 表如下\n\n![image-20220508234343594](https://img.kuizuo.cn/image-20220508234343594.png)\n\n对于主要字段介绍：\n\n- **parent**：对于有父子关系的表，会创建一个 parent_id(这里为 parent)字段用于表示父节点，无则为顶级节点。\n\n- **permission**：权限标识，根据后端接口而定，比如新增用户的 url 为`sys/user/add`，那么权限标识通常将/替换成:，也就是`sys:user:add`（主要防止和接口的 url 混淆）。\n- **type**：0 目录 1 菜单(前端组件) 2 权限，由于是菜单与权限混用，所以用 type 来区分。\n- **icon**：左侧菜单图标\n- **order_no**：左侧菜单排序\n- **component**：组件，目录为 LAYOUT，菜单则为对应组件，权限则无\n\n有了这些数据，要做的是将他们拼接为**前端菜单管理**，**根据角色获取所有菜单**，**根据用户的所有权限**的树结构数据。\n\n##### 前端菜单管理\n\n获取所有的菜单列表数据，通过递归生成对应的菜单树结构，具体递归代码在`src/modules/core/permission/index.ts`中的`generatorMenu`方法中。\n\n具体拼接数据过多，可自行打开控制台(F12)->网络 到菜单管理页中获取数据可得，这里便不做展示（后文拼接数据同理）。\n\n##### 根据角色获取所有菜单\n\n首先根据用户 id 找到该用户的所有角色 id，然后通过联表找到角色 id 所对应的菜单数据。\n\n```typescript\n  /**\n   * 根据角色获取所有菜单\n   */\n  async getMenus(uid: number): Promise<string[]> {\n    const roleIds = await this.roleService.getRoleIdByUser(uid);\n    let menus: SysMenu[] = [];\n    if (includes(roleIds, this.rootRoleId)) {\n      menus = await this.menuRepository.find({ order: { orderNo: 'ASC' } });\n    } else {\n      menus = await this.menuRepository\n        .createQueryBuilder('menu')\n        .innerJoinAndSelect('sys_role_menu', 'role_menu', 'menu.id = role_menu.menu_id')\n        .andWhere('role_menu.role_id IN (:...roldIds)', { roldIds: roleIds })\n        .orderBy('menu.order_no', 'ASC')\n        .getMany();\n    }\n\n    const menuList = generatorRouters(menus);\n    return menuList;\n  }\n```\n\n同样`generatorRouters`函数也在`src/modules/core/permission/index.ts`中。\n\n##### 根据用户的所有权限\n\n与上例一样，不过这里主要获取的是 permission 字段，所以在条件上添加了`menu.type = 2`与`menu.permission IS NOT NULL`，将 permission 拼接为一个数组。\n\n```typescript\n  /**\n   * 获取当前用户的所有权限\n   */\n  async getPerms(uid: number): Promise<string[]> {\n    const roleIds = await this.roleService.getRoleIdByUser(uid);\n    let permission: any[] = [];\n    let result: any = null;\n    if (includes(roleIds, this.rootRoleId)) {\n      result = await this.menuRepository.find({\n        permission: Not(IsNull()),\n        type: 2,\n      });\n    } else {\n      result = await this.menuRepository\n        .createQueryBuilder('menu')\n        .innerJoinAndSelect('sys_role_menu', 'role_menu', 'menu.id = role_menu.menu_id')\n        .andWhere('role_menu.role_id IN (:...roldIds)', { roldIds: roleIds })\n        .andWhere('menu.type = 2')\n        .andWhere('menu.permission IS NOT NULL')\n        .getMany();\n    }\n    if (!isEmpty(result)) {\n      result.forEach((e) => {\n        permission = concat(permission, e.permission.split(','));\n      });\n      permission = uniq(permission);\n    }\n    return permission;\n  }\n```\n\npermission 的值如\n\n```json\n[\"sys:user:add\", \"sys:user:delete\", \"sys:user:update\", \"sys:user:list\", \"sys:user:info\"]\n```\n\n然后在 auth.guard.ts 守卫中获取 permission，然后每次请求需要鉴权的接口时，将权限标识转为接口 url，判断是否包含该 url，不包含则无访问权限。\n\n在[菜单管理页](https://admin.kuizuo.cn/#/system/menu)中可操作菜单，具体可自测。\n\n至此，菜单表的数据被拆分为这 3 部分数据，以实现权限管理，动态路由的目的。\n\n#### 其他文档\n\n你可以访问 [https://admin.kuizuo.cn/swagger-ui](https://admin.kuizuo.cn/swagger-ui \"https://admin.kuizuo.cn/swagger-ui\") 来查看kz-admin的Swagger文档\n\njson格式为 [https://admin.kuizuo.cn/swagger-ui/json](https://admin.kuizuo.cn/swagger-ui/json \"https://admin.kuizuo.cn/swagger-ui/json\")，用于导入ApiFox中。\n\nApiFox在线链接: [https://www.apifox.cn/apidoc/shared-7a07def2-5b82-4c71-bf57-915514f61f25](https://www.apifox.cn/apidoc/shared-7a07def2-5b82-4c71-bf57-915514f61f25 \"https://www.apifox.cn/apidoc/shared-7a07def2-5b82-4c71-bf57-915514f61f25\") 访问密码: kz-admin\n\n## 写后感\n\n其实一年多前我就想写一套相对完善的后台管理系统的模板，供自己后续的一些项目中使用。然而迟迟没有动手写套模板，而是不断根据业务需求，修修改改写了一套乱七八糟的代码，以至于维护的时候究极痛苦。就在不久前正好也用到，然而也是把之前写的屎山一样的代码拿来修改。\n\n**我所遇到的问题：项目结构乱，代码风格乱，维护代码极其折磨**\n\n所以今年寒假于是准备完善这套模板，然而当时只是创建完工程结构，到现在才正式把功能实现以及测试相关，部署搞定。说真的，非常拖延，甚至都快让我放弃写这个模板的打算。但拖也对我有一定的好处，为什么这么说？因为当时有这个想法时，市面上关于这套技术栈的实现还很少，而等我寒假再去搜索相关实现的时候，却有相关开源的代码，而这便可供我学习，使项目更加完善。\n\n回顾整体项目的编写过程，所花费的时间可能一个月不到，甚至更少，但往往就是各种各样的拖延导致项目逾期，或者是学习某个技术栈。难以将精力集中起来完成任务，至于原因，也许是目标过于庞大，或许是日常生活中的各种琐事，不过我想多半是自我的懒惰。"
    },
    {
      "id": "about-open-source-license",
      "metadata": {
        "permalink": "/about-open-source-license",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/开源许可证.md",
        "source": "@site/blog/advice/开源许可证.md",
        "title": "关于开源许可证",
        "description": "虽然知道开源有个许可证 LICENSE，但一直没给自己写的一些开源项目选择开源许可证。于是准备系统了解一下开源许可证，以及如何为 Github 项目添加 LICENSE。",
        "date": "2022-05-05T00:00:00.000Z",
        "formattedDate": "2022年5月5日",
        "tags": [
          {
            "label": "open-source",
            "permalink": "/tags/open-source"
          },
          {
            "label": "git",
            "permalink": "/tags/git"
          }
        ],
        "readingTime": 4.126666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "about-open-source-license",
          "title": "关于开源许可证",
          "date": "2022-05-05T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "open-source",
            "git"
          ],
          "keywords": [
            "open-source",
            "git"
          ]
        },
        "prevItem": {
          "title": "kz-admin后台管理系统",
          "permalink": "/kz-admin"
        },
        "nextItem": {
          "title": "代码备份方案",
          "permalink": "/code-backup"
        }
      },
      "content": "虽然知道开源有个许可证 LICENSE，但一直没给自己写的一些开源项目选择开源许可证。于是准备系统了解一下开源许可证，以及如何为 Github 项目添加 LICENSE。\n\n<!-- truncate -->\n\n### OSI(Open Source Initiative)\n\n即开发源代码组织，是一个旨在推动开源软件发展的非盈利组织。可以在 [Open Source Initiative](https://opensource.org/licenses/alphabetical) 中查看所有的开源协议。\n\n## 开源许可证\n\n关于开源许可证的简单区别\n\n![img](https://www.ruanyifeng.com/blogimg/asset/201105/bg2011050101.png)\n\n至于如何选择，下图更加通俗易懂\n\n![快速选择协议](https://img.kuizuo.cn/2019-04-29-072557.png)\n\n其中开源许可证可分为两大类\n\n### 宽松式（permissive）许可证\n\n宽松式许可证（permissive license）是最基本的类型，对用户几乎没有限制。用户可以修改代码后闭源。\n\n它有三个基本特点。\n\n**（1）没有使用限制**\n\n用户可以使用代码，做任何想做的事情。\n\n**（2）没有担保**\n\n不保证代码质量，用户自担风险。\n\n**（3）披露要求（notice requirement）**\n\n用户必须披露原始作者。\n\n#### 常见许可证\n\n常见的宽松式许可证有四种。它们都允许用户任意使用代码，区别在于要求用户遵守的条件不同。\n\n**（1）BSD（二条款版）**\n\n分发软件时，必须保留原始的许可证声明。\n\n**（2） BSD（三条款版）**\n\n分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。\n\n**（3）MIT**\n\n分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。\n\n**（4）Apache 2**\n\n分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。\n\n不难看出这类许可证要求相对宽松，市面上大部分的开源项目主要以 MIT 和 Apache 两者为主。使用 MIT 协议开源项目如 vue，react，bootstrap，vscode，electron，axios，terminal 等等，作为大多数开发者而言，MIT 无法是最好的选择。\n\n### Copyleft 许可证\n\nCopyleft 是[理查德·斯托曼](https://www.ruanyifeng.com/blog/2005/03/post_112.html)发明的一个词，作为 Copyright （版权）的反义词。\n\nCopyright 直译是\"复制权\"，这是版权制度的核心，意为不经许可，用户无权复制。作为反义词，Copyleft 的含义是不经许可，用户可以随意复制。\n\n但是，它带有前提条件，比宽松式许可证的限制要多。\n\n> - 如果分发二进制格式，必须提供源码\n> - 修改后的源码，必须与修改前保持许可证一致\n> - 不得在原始许可证以外，附加其他限制\n\n上面三个条件的核心就是：修改后的 Copyleft 代码不得闭源。\n\n#### 常见许可证\n\n常见的 Copyleft 许可证也有四种（对用户的限制从最强到最弱排序）。\n\n**（1）Affero GPL (AGPL)**\n\n如果云服务（即 SAAS）用到的代码是该许可证，那么云服务的代码也必须开源。\n\n**（2）GPL**\n\n如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。\n\n**（3）LGPL**\n\n如果项目采用动态链接调用该许可证的库，项目可以不用开源。\n\n**（4）Mozilla（MPL）**\n\n只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。\n\n> 参考文章\n>\n> [开源许可证教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html)\n>\n> [如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n>\n> [五分钟看懂开源协议](https://juejin.cn/post/6844903925863153672)\n\n## Github 项目添加 LICENSE\n\nGithub 官方专门制作了一个网站 [Choose a License](https://choosealicense.com/) 帮助大家选择合适的开源，License。中文版也有 [选择一个开源许可证](https://choosealicense.rustwiki.org/)。不过我更推荐下面在 Github 仓库页中来新增 LICENSE。\n\n在仓库页中，Add file-> Create new file\n\n![image-20220505190634653](https://img.kuizuo.cn/image-20220505190634653.png)\n\n输入 LICENSE（建议大写），右侧将会弹出 Choose a license template，这里我选择 MIT 协议\n\n![image-20220505190758791](https://img.kuizuo.cn/image-20220505190758791.png)\n\n![image-20220505191409696](https://img.kuizuo.cn/image-20220505191409696.png)\n\n点击 Review and submit，此时就会回到添加文件的地方，并且自动为你填写好 Message，接着点击 Commit new file 即可\n\n![image-20220505200951047](https://img.kuizuo.cn/image-20220505200951047.png)\n\n整个许可证内容如下\n\n```\nMIT License\n\nCopyright (c) 2022 kuizuo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n再次刷新便可看到效果\n\n![image-20220505201138476](https://img.kuizuo.cn/image-20220505201138476.png)"
    },
    {
      "id": "code-backup",
      "metadata": {
        "permalink": "/code-backup",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/代码备份方案.md",
        "source": "@site/blog/advice/代码备份方案.md",
        "title": "代码备份方案",
        "description": "前段时间因为笔记本不在身边，导致一些本地磁盘代码数据没法直接同步过来。于是就准备把这些年写的代码重新整理一下，谈谈常用备份手段以及我的最佳手段",
        "date": "2022-05-02T00:00:00.000Z",
        "formattedDate": "2022年5月2日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "code",
            "permalink": "/tags/code"
          }
        ],
        "readingTime": 4.963333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "code-backup",
          "title": "代码备份方案",
          "date": "2022-05-02T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "code"
          ],
          "keywords": [
            "随笔",
            "code"
          ]
        },
        "prevItem": {
          "title": "关于开源许可证",
          "permalink": "/about-open-source-license"
        },
        "nextItem": {
          "title": "搭建GitLab代码管理仓库",
          "permalink": "/gitlab-code-management-environment"
        }
      },
      "content": "前段时间因为笔记本不在身边，导致一些本地磁盘代码数据没法直接同步过来。于是就准备把这些年写的代码重新整理一下，谈谈常用备份手段以及我的[最佳手段](#最佳实现)\n\n<!-- truncate -->\n\n## 备份手段\n\n### 本地硬盘\n\n大多数代码的存储方式，方便存取，我通常会新建一个驱动器 **代码 (F:)** 来将所有代码放在此处，可能还会自备一个移动硬盘来存储代码。\n\n#### 优点\n\n无需网络，保存时间久，**读写数据快**。\n\n#### 缺点\n\n数据同步不方便，难以做到跨端跨设备共享。万一硬盘出了点问题，代码将难以恢复。\n\n### 网盘\n\n例如某度网盘，Onedrive 等等，这类备份通常有一定的限制，例如下载限速严重，空间限制，保存期限等等，具体以实际使用网盘为例。\n\n在某度网盘中，选择你的想备份的文件夹，是可以做到文件夹自动备份，但对于你项目中的依赖文件（例如 Node 的 node_module）那不小的空间也将备份，但有文件夹数量以及大小限制，如下图，这里只是简单一提，不作为备用手段。\n\n![image-20220502153823417](https://img.kuizuo.cn/image-20220502153823417.png)\n\n#### 优点\n\n相比本地硬盘而已，**网盘更易分享**，在其他设备中只需要登录网盘账号或访问网盘所分享的链接。\n\n#### 缺点\n\n有些免费的网盘，必然有一定的限制，例如空间限制，下载限制，远不如本地硬盘。如果不付费的话，体验效果堪忧。\n\n### 代码托管平台\n\n代码托管平台有很多，例如 Github、Gitee 等等，甚至可以自建一个像 GItLab 的代码托管平台。\n\n#### 优点\n\n**代码实时性强**，并且基于 Git 版本管理工具可以很方便查看代码的历史操作，对于项目类的而言非常方便。\n\n#### 缺点\n\n对于一些公有项目而言，一些私密信息（密码）不易于上传，在其他设备拉取代码就不存在这部分数据。同时**对于大量代码就束手无策**。\n\n## 最佳实现\n\n介绍完上面的几种代码备份手段，各自都有优缺点，至于如何选择就因人而异，这里就说说我是如何备份代码的。\n\n### 全部代码\n\n对于全部代码而言，肯定是多备份远优于不备份的。所以我通常会在本地电脑硬盘中备份两份代码，一份就正常放在固态硬盘上，另一份则放在机械硬盘，同时再备份一份代码在网盘上。\n\n但机械硬盘与网盘的备份时间一致，都是定期或阶段性的备份（甚至可能会忘记备份），所以这种对代码的实时性要求不高，通常这类代码为学习代码以及工具类相关代码。\n\n### 项目代码\n\n对于项目代码而言，我是毫不犹豫的选择代码托管平台，使用到版本管理工具 Git，可以很好的查看代码的全部历史记录以及修改追踪能力。易于维护的同时，代码分享与同步也比网盘来的高效。设置好.gitignore 也不会将非必要的文件（依赖文件，打包后的文件，生产环境下的配置文件）上传上去。而 Github 便是我最好的选择，里面存放了或多或少的开源与私有项目，每次在其他设备上只需要登录 github，然后 clone 项目，便可开始 coding。\n\n**通常来说备份项目代码就已经足够了，毕竟这类代码往往会有一定的价值性。**\n\n:::caution\n\n但这还不够，因为放在别人的网站上的代码，万一人家网站停用，或者是你的代码有点风险给你代码仓库封了，那么这时候你想找回代码都无法找回！所以为了做好备份代码的万全准备，一般是推荐搭建私有 git 服务，然后自动同步 github 的账号下的所有仓库。\n\n:::\n\n### 文章笔记备份\n\n除了代码备份外，此外笔记也十分重要，毕竟有时候自己写的代码，自己甚至都不一定明白。对于文章数据以及笔记，我通常会使用云端协作平台，这类产品有 wolai，notion，语雀等等，不过我个人还是相对倾向于使用 [wolai](https://www.wolai.com/)。可多端设备查看，实时编辑等等，体验还算 ok。\n\n此外一些博客文章，就会同步在[个人博客](https://kuizuo.cn/)以及[掘金](https://juejin.im/user/1565318510545901/activities)上，当然博客的静态站点的代码仓库也是存放在[Github](https://github.com/kuizuo/blog)上。\n\n### 不必要的代码不要备份\n\n其实对于很多代码都没备份的必要，例如我在安卓学习的时候，涉及到的刷机包（少说 2 个 g），以及各种 apk。完全可以直接备份其下载地址，而不是选择备份。\n\n像临时用脚手架创建的工程文件或是下载别人的代码，这类通常就临时使用（甚至不会再打开第二次），完全没有必要备份理由。\n\n### 请压缩后在备份\n\n如果不压缩文件夹，备份时将逐个读取文件特别耗时，同时压缩完代码还可以节省一定的空间。也许在一开始备份时会相对麻烦，但在上传与下载以及多次备份时就一举两便。\n\n## 最后\n\n**永远不要嫌备份麻烦，当你辛辛苦苦写的代码丢失时，那才是真正的麻烦。**\n\n**养成定期备份代码的习惯，因为你永远不知道什么突发情况会导致代码丢失。**"
    },
    {
      "id": "gitlab-code-management-environment",
      "metadata": {
        "permalink": "/gitlab-code-management-environment",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/搭建GitLab代码管理仓库.md",
        "source": "@site/blog/program/搭建GitLab代码管理仓库.md",
        "title": "搭建GitLab代码管理仓库",
        "description": "image-20220414235645607",
        "date": "2022-04-15T00:00:00.000Z",
        "formattedDate": "2022年4月15日",
        "tags": [
          {
            "label": "git",
            "permalink": "/tags/git"
          },
          {
            "label": "gitlab",
            "permalink": "/tags/gitlab"
          }
        ],
        "readingTime": 5.13,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "gitlab-code-management-environment",
          "title": "搭建GitLab代码管理仓库",
          "date": "2022-04-15T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "git",
            "gitlab"
          ],
          "keywords": [
            "git",
            "gitlab"
          ]
        },
        "prevItem": {
          "title": "代码备份方案",
          "permalink": "/code-backup"
        },
        "nextItem": {
          "title": "题小侠",
          "permalink": "/question-man"
        }
      },
      "content": "![image-20220414235645607](https://img.kuizuo.cn/image-20220414235645607.png)\n\n我只要有代码的项目，都会放到 Github 上，无论公开还是私有项目。一是相当于在云端备份了一份代码，二是可以很方便的分享给别人。但对于私有项目而言存放在别人那总归不好，而且Github 时常会出现无法访问的情况（即使搭了梯子）。所以就打算搭建一个私有的仓库，基于[GitLab](https://gitlab.com/)。\n\n可以访问 [kuizuo · GitLab](https://gitlab.kuizuo.cn/kuizuo) 来查看搭建效果。\n\n<!-- truncate -->\n\n## 页面概览\n\n![image-20220415013028002](https://img.kuizuo.cn/image-20220415013028002.png)\n\n## 前提\n\n一台服务器，系统 Linux，内存 >=4g\n\n我的轻量应用服务器配置如下\n\n![image-20220414210129510](https://img.kuizuo.cn/image-20220414210129510.png)\n\n## 搭建\n\n服务器我选择安装[宝塔面板](https://www.bt.cn/new/index.html)，对于个人项目，还是很推荐安装的，集成了一些软件商店，包括本次的主角，同时提供可视化页面操作，能省下很多敲命令的时间，~~同时也会增加忘记命令的记忆~~。\n\n### 安装 GitLab\n\n进入宝塔面板，点击软件商店，找到**GitLab 最新社区版**，点击安装\n\n![image-20220414204808143](https://img.kuizuo.cn/image-20220414204808143.png)\n\n实测等了 8 分钟，安装完毕即可查看 GitLab 的访问地址，账号密码。默认端口号 8099，记得在防火墙开放下该端口\n\n![image-20220414213002293](https://img.kuizuo.cn/image-20220414213002293.png)\n\n进入访问地址就可以看到 GitLab 的登录页面了。\n\n### 修改密码\n\n[Reset a user's password | GitLab](https://docs.gitlab.com/ee/security/reset_user_password.html#reset-the-root-password)\n\n进入控制台（进入要稍等一段时间）\n\n```sh\nsudo gitlab-rails console\n```\n\n显示页面如下\n\n```\n[root@VM-4-5-centos ~]# sudo gitlab-rails console\n--------------------------------------------------------------------------------\n Ruby:         ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [x86_64-linux]\n GitLab:       14.9.3 (ec11aba56f1) FOSS\n GitLab Shell: 13.24.0\n PostgreSQL:   12.7\n------------------------------------------------------------[ booted in 29.71s ]\nLoading production environment (Rails 6.1.4.6)\nirb(main):001:0>\n```\n\n输入如下代码\n\n```sh\nu=User.find(1)\nu.password='a12345678'\nu.password_confirmation = 'a12345678'\nu.save!\n```\n\n输出结果\n\n```sh\nirb(main):001:0> u=User.find(1)\n=> #<User id:1 @root>\nirb(main):002:0> u.password='a12345678'\n=> \"a12345678\"\nirb(main):003:0> u.password_confirmation = 'a12345678'\n=> \"a12345678\"\nirb(main):004:0> u.save!\n=> true\nirb(main):005:0>\n```\n\n最后输入`exit`退出控制台，然后输入下方代码重启 gitlab，密码就设置完毕了\n\n```sh\ngitlab-ctl restart\n```\n\n:::info\n\n若重启或修改端口等操作后出现 502 错误，您可能需要等待 3-5 分钟才能正常访问 GitLab\n\n:::\n\n### 修改语言\n\n点击右上角的头像->Preferences 进入到设置，找到语言设置为简体中文，然后点击左小角的 Save changes。刷新网页语言就设置完毕了\n\n![image-20220414215528543](https://img.kuizuo.cn/image-20220414215528543.png)\n\n### 配置HTTPS\n\ngitlab内部集成了letsencrypt，因此，这里只需要启用letsencrypt，并进行一些必要的配置\n\n打开/opt/gitlab/etc/gitlab.rb.template，修改以下内容\n\n1. 在32行左右，将external_url前面的#删掉，并在单引号中填写gitlab服务器的https地址，例如[https://gitlab.kuizuo.cn](https://gitlab.kuizuo.cn)\n\n   ```\n    external_url 'https://gitlab.kuizuo.cn'\n   ```\n\n2. gitlab默认占用nginx80端口，所以需要更改下\n\n   ```\n   nginx['listen_port'] = 8100\n   ```\n\n3. 在2434行左右（可通过搜索letsencrypt定位），修改下面几项\n\n   ```\n   letsencrypt['enable'] = true #删除前面的#号，并将值修改为true\n   letsencrypt['contact_emails'] = ['kuizuo12@gmail.com'] #删除前面的#号,修改为自己的邮箱\n   letsencrypt['auto_renew'] = true #删除前面的#号  自动更新\n   ```\n\n然后重载配置（需要一点时间）\n\n```\ngitlab-ctl reconfigure\n```\n\n然后重启gitlab使配置生效\n\n```\ngitlab-ctl restart\n```\n\ngitlab就会通过letsencrypt自动签发免费的HTTPS证书，等证书签发成功，就可以通过上面指定的域名访问代码仓库了。\n\n**其实也可以在nginx创建一个站点，然后该站点配置ssl，通过反向代理到127.0.0.1:8099 也是能实现配置HTTPS的。（推荐）**\n\n:::danger\n\n如果上面的操作的话，可能会导致gitlab的nginx无法启动（原因应该是修改了gitlab自带的nginx服务，或者与自带的冲突）。修改`/opt/gitlab/sv/nginx/run`\n\n```sh\nexec chpst -P /opt/gitlab/embedded/sbin/nginx -p /var/opt/gitlab/nginx\n# 改为\nexec chpst -P /opt/gitlab/embedded/sbin/gitlab-web -p /var/opt/gitlab/nginx\n```\n\n重启gitlab\n\n```sh\ngitlab-ctl start\n```\n\n:::\n\n## 管理中心\n\n点击左上角的菜单选择管理员，可在管理中心设置GitLab的相关设置。例如\n\n### 禁止注册\n\n在设置->通用->注册限制，取消勾选 **已启动注册功能**，这样就可以禁止注册（页面无注册按钮）。当然也可以允许，然后需要批准以及确认邮箱。\n\n![image-20220415004207174](https://img.kuizuo.cn/image-20220415004207174.png)\n\n在概览->用户中可以查看相关用户信息。\n\n![image-20220415012817311](https://img.kuizuo.cn/image-20220415012817311.png)\n\n至于其他设置自行研究了。\n\n## 创建项目\n\n点击新建项目，这里就导入我的 blog 项目。\n\n![image-20220414220221480](https://img.kuizuo.cn/image-20220414220221480.png)\n\n选择 Github 后，会提示使用 GitHub 身份验证，这里需要拿到 Github 的[Token](https://github.com/settings/tokens)\n\n![image-20220414220333437](https://img.kuizuo.cn/image-20220414220333437.png)\n\n访问https://github.com/settings/tokens，新建一个Token，选择token有效期，以及相关权限（我这边选择全选，token不过期）\n\n![image-20220414220507016](https://img.kuizuo.cn/image-20220414220507016.png)\n\n![image-20220414220738714](https://img.kuizuo.cn/image-20220414220738714.png)\n\n生成完毕后复制该 Token 到 GitLab 上，就可以看到该 Github 账号下的所有仓库了，这里我选择 blog 进行导入（导入需要一点时间）。\n\n![image-20220414220858379](https://img.kuizuo.cn/image-20220414220858379.png)\n\n导入完毕后与原仓库无特别区别\n\n![image-20220414224639573](https://img.kuizuo.cn/image-20220414224639573.png)\n\n### 自动同步项目\n\n点击项目中设置->仓库，找到镜像仓库。在 Git 仓库 URL 中填写格式如下\n\n```js\n// 原仓库git\nhttps://github.com/kuizuo/blog\n// 在https://后加上username@\nhttps://kuizuo@github.com/kuizuo/blog\n```\n\n密码为上面的 Token（如果忘记的话，可以在 Github 的 Token 页中 Regenerate token），如下图所示\n\n![image-20220414232028397](https://img.kuizuo.cn/image-20220414232028397.png)\n\n------\n\n基本上github能实现的操作gitlab也都能实现。\n\n## 其他功能\n\n### Web IDE（在线编辑代码）\n\n![image-20220415001914123](https://img.kuizuo.cn/image-20220415001914123.png)\n\n\n\n## 运行状态\n\n放几张图\n\n![image-20220414233435739](https://img.kuizuo.cn/image-20220414233435739.png)\n\n输入 top 命令，按 M 按内存排序。\n\n![image-20220414233416223](https://img.kuizuo.cn/image-20220414233416223.png)\n\n还是挺吃内存的，毕竟安装的时候就要求 4g 内存以上。\n\n有个轻量级的项目管理器 [gitea](https://github.com/go-gitea/gitea) 不妨也是一种选择，但功能上没有Gitlab这么丰富。\n\n对于自建git服务的选择，这里有篇文章推荐阅读 [自建 Git 服务器：Gitea 与 Gitlab 部署踩坑经历与对比总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/486410391)\n\n## 总结\n\n其实回到一开始的问题，既然Github有可能访问不了，为啥不要迁移到国内的[Gitee](https://gitee.com/)上。\n\n~~除了瞎玩瞎折腾外~~，对于一些公司而言，他们不一定会使用这类开源的代码托管平台，而是自建一个像GitLab这样的代码仓库管理系统。此外别人的东西，多半都会有一定的限制，例如项目成员数量等等，所以才会有这次的尝试，整体体验感觉可玩性很大。"
    },
    {
      "id": "question-man",
      "metadata": {
        "permalink": "/question-man",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/题小侠.md",
        "source": "@site/blog/project/题小侠.md",
        "title": "题小侠",
        "description": "很早就了解与学习过微信小程序开发相关的技术栈与框架，小程序的账号也都已经申请过。但写过的 demo 项目也迟迟没有发布到小程序上。这主要的原因还是觉得不值得发布，加上各种审核相关的。而这次准备写一个搜题相关的小程序，也是时候实战发布一下，顺带记录下整个开发与发布过程。",
        "date": "2022-04-06T00:00:00.000Z",
        "formattedDate": "2022年4月6日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "vue",
            "permalink": "/tags/vue"
          },
          {
            "label": "miniprogram",
            "permalink": "/tags/miniprogram"
          }
        ],
        "readingTime": 11.383333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "question-man",
          "title": "题小侠",
          "date": "2022-04-06T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "vue",
            "miniprogram"
          ],
          "keywords": [
            "project",
            "vue",
            "miniprogram"
          ],
          "image": "/img/project/question-man.png",
          "draft": true
        },
        "prevItem": {
          "title": "搭建GitLab代码管理仓库",
          "permalink": "/gitlab-code-management-environment"
        },
        "nextItem": {
          "title": "vite+vue3搭建uniapp开发环境",
          "permalink": "/vite-vue3-build-uniapp-environment"
        }
      },
      "content": "很早就了解与学习过微信小程序开发相关的技术栈与框架，小程序的账号也都已经申请过。但写过的 demo 项目也迟迟没有发布到小程序上。这主要的原因还是觉得不值得发布，加上各种审核相关的。而这次准备写一个搜题相关的小程序，也是时候实战发布一下，顺带记录下整个开发与发布过程。\n\n在线体验：扫下图小程序二维码\n\n![itopic](https://img.kuizuo.cn/itopic.jpg)\n\n小程序的源码地址：[https://github.com/kuizuo/question-man](https://github.com/kuizuo/question-man)\n\n<!-- truncate -->\n\n## 技术栈\n\n小程序所采用的是 Taro + Vue3 + NutUI，之所以选这套技术栈，主要是想上 Vue3，而 uniapp 对 Vue3 的支持并不友好，在我的上篇文章中也有说明到，同时支持 uniapp 的 vue3 屈指可数。所以便选用了这套技术栈来进行开发。\n\n## 页面设计\n\n![image-20220405213930313](https://img.kuizuo.cn/image-20220405213930313.png)\n\n## 项目配置\n\n### 项目搭建\n\n[安装及使用 | Taro 文档 (jd.com)](https://taro-docs.jd.com/taro/docs/GETTING-STARTED)\n\n```\ntaro init myApp\n```\n\n配置如下\n\n![image-20220405214126617](https://img.kuizuo.cn/image-20220405214126617.png)\n\n安装完依赖，使用`npm run dev:weapp`，在打开微信开发者工具，导入项目即可。\n\n### axios 封装\n\nweb 端 http 请求使用最多的库就是 axios 了，但是在小程序中使用 axios 会提示 adapter 未定义，原因是小程序不能解析 package.json 中的 browser module 等字段。\n\n要使用 axios 的话可以安装 axios-miniprogram 或者 taro-axios 库（我选择后者，但前者稍小 5kb），也就是会适配小程序的 axios 的 adapter，引入和使用与 axios 并不特别大的差异。以下是我封装后的代码\n\n```typescript title=“utils/http.ts”\nimport axios from 'taro-axios'\nimport Taro from '@tarojs/taro'\nimport { useAuthStore } from '@/stores/modules/auth'\n\nconst showErrorToast = (msg) => {\n  Taro.showToast({\n    title: msg,\n    icon: 'none',\n  })\n}\n\nconst instance = axios.create({\n  baseURL: process.env.BASE_URL,\n})\n\ninstance.interceptors.request.use(\n  (config) => {\n    Taro.showLoading({\n      title: '加载中',\n      mask: true,\n    })\n    let token = Taro.getStorageSync('token')\n    if (typeof token == 'undefined') {\n      token = ''\n    }\n    config.headers = {\n      'Content-Type': 'application/json;charset=utf-8',\n      Authorization: token,\n    }\n    return config\n  },\n  (error) => {\n    console.log(error)\n    return Promise.reject(error)\n  },\n)\n\n// respone拦截器\ninstance.interceptors.response.use(\n  (response: any) => {\n    Taro.hideLoading()\n    if (response.data.isError) {\n      showErrorToast(response.data.error.message)\n    } else {\n      return response\n    }\n  },\n  (error) => {\n    if (error.response) {\n      Taro.hideLoading()\n      console.log('err', error)\n\n      let res = error.response.data\n      switch (res.code) {\n        case 400:\n          showErrorToast(res.message || '非法请求')\n          break\n        case 401:\n          const authStore = useAuthStore()\n          authStore.login()\n          // showErrorToast(res.message || '当前登录已过期，请重新登录')\n          // Taro.navigateTo({\n          //   url: '/pages/login/index'\n          // })\n          break\n        case 403:\n          showErrorToast(res.message || '非法请求')\n          break\n        case 404:\n          showErrorToast(res.message || '请求资源不存在')\n          break\n        case 500:\n        case 502:\n          showErrorToast(res.message || '服务器开小差啦')\n          break\n        default:\n          showErrorToast(res.message || res.statusText)\n      }\n    } else {\n      console.log(error)\n      showErrorToast('请检查网络连接状态')\n    }\n\n    return Promise.reject(error)\n  },\n)\n\nexport default instance\n```\n\n没什么好说的，和网页端基本一致。主要是加了个 wx 的 Loading 与 Toast。然后在 token 失效的时候，应该是要跳转到登录页面，但我并没有编写登录页面，而是重新调用一遍 login，达到静默登录的效果。\n\n### 获取用户唯一标识（openid）\n\n借助微信小程序能十分方便的获取到微信用户。在微信中，为了识别用户，每个用户针对每个公众号或小程序等应用会产生一个安全的 openid，开发者可以通过这个标识识别出用户。\n\n要获取 openid 有以下几种方法(这里以 Taro 为例子，而为 wx 官方文档)，具体代码可在官方文档中查看到。\n\n[Taro.login(option) | Taro 文档 (jd.com)](https://taro-docs.jd.com/taro/docs/apis/open-api/login/)\n\n首先调用`Taro.login()` 获取 5 分钟时长的 code，然向 api.weixin.qq.com 获取 openid 代码如下\n\n```javascript\nTaro.login({\n  success(res) {\n    let code = res.code\n    let appId = '小程序->开发管理->开发设置->开发者ID获取'\n    let appSecret = '小程序->开发管理->开发设置->开发者ID获取'\n    Taro.request({\n      url: 'https://api.weixin.qq.com/sns/jscode2session',\n      data: {\n        appid: appId,\n        secret: appSecret,\n        js_code: res.code,\n        grant_type: 'authorization_code',\n      },\n      method: 'GET',\n      success(res) {\n        console.log('openid', res.data.openid) // 得到openid\n        console.log('session_key', res.data.session_key) // 得到 session_key\n      },\n    })\n  },\n})\n```\n\n但现在小程序是无法添加 api.weixin.qq.com 域名，所以上面的方案在小程序端失效，只能转到后端上。小程序官方有张实践图\n\n![img](https://mmbiz.qpic.cn/mmbiz_jpg/JpltBJ31poWJDK7SWLI8Y52j3eL3jVicRyXKjo60OsUwcHb3BGm2YKvOF45TC4yVIWMT28pJO3YBvsiaGkGdEJDQ/640?wx_fmt=jpeg)\n\n整个步骤\n\n1、调用**wx.login 获取 code**，此时也可调用 wx.getUserInfo 来获取用户数据（昵称，头像）\n\n2、由于**小程序后台授权域名无法授权微信的域名**，所以需要**将 code 与用户数据传入到自己的服务器**上。\n\n3、服务器后台接收到 code，**后台将 appid+appsecret+code 向微信 api 服务获取用户的登录态信息（openid 与 session_key）**，服务器对这些登录态信息进行封装，如 session 或者 jwt 的 token 都可以（这里以 token 为例），返回给小程序端\n\n4、小程序接收到 token 时，将其保存到本地存储上（wx.setStorage），每次携带该 token 请求向服务器发送请求。\n\n不过如果使用云开发可以免去很多鉴权相关的，但由于数据库存储相关的，所以我是采用自建后台服务器，而后端暂不考虑开源，故具体逻辑代码就不演示了（考虑安全为主），自行编写后端 login 接口。\n\n### 获取手机号\n\n**注意：只有企业小程序才可以获取用户手机号，个人小程序没有办法获取的。**\n\n在这篇文章中有说明到如何获取 [5 行代码获取小程序用户手机号 | 微信开放社区 (qq.com)](https://developers.weixin.qq.com/community/develop/article/doc/000c462925c610ecc899b11d751013)\n\n[获取手机号 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html)\n\n所以就没有然后了（因为我肯定是个人账号）。\n\n### 获取用户信息\n\n要获取用户信息的需要调用 getUserProfile，演示代码如下\n\n```javascript\nTaro.getUserProfile({\n    desc: '获取用户个人信息',\n    success: function(res) {\n    const userInfo = res.userInfo\n    console.log(res.userInfo)\n    }\n}\n```\n\n要注意的是 getUserProfile 必须通过按钮来触发，而不能通过生命周期的形式，弹出授权窗口，用户可接受与拒绝。说白了就是开发者无法在用户不知情的情况下获取到用户信息（考虑到用户隐私相关的）\n\n同时有一个小坑，getUserInfo 获取到微信用户与灰色头像\n\n由于小程序官方调整了接口，导致 getUserInfo 无法获取正确的用户信息。详情可看 [小程序登录、用户信息相关接口调整说明 | 微信开放社区 (qq.com)](https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801?highLine=login)\n\n一个正常的登录流程:\n\n按理来说一般是要提供一个专门的登录页面，哪怕登录页面只有一个按钮，按钮名为一键登录。然后用户点击触发 getUserProfile 获取用户信息，如果用户拒绝则不允许使用软件，允许则进入主页，然后将用户信息保存置服务器上，以便下次用户访问时无需再次调用 getUserProfile 接口，直接从服务器上取。\n\n而我的做法相对比较粗略，我是直接允许用户进入首页，但当他**使用搜索功能时**，则判断服务器是否存有该用户的信息，如果没有，调用 getUserProfile，弹出授权框给用户选择。同时在首页的时候通过 checkSession 来判断 session 是否过期，过期则调用 wx.login 静默登录，更新登录态。（不过如果后端不判断该用户信息是否完善的话，那么是有办法直接绕过这种方式来进行调用接口了）。\n\n### 数据库搭建\n\n实际上这个小程序最主要的依赖就是数据库了，而这个数据库与传统的关系型（Mysql）和文档型（MongoDB）不同，要做到搜索引擎式的搜索。举个例子，搜索“李白”，能得到 【李白的诗风是】【李白的称呼】有关李白的字样，并且要求返回的速度快。像上面举到的两种数据库实现起来不方便，如果涉及到千万级别的数据库，将是按秒，甚至数十秒的响应速度。\n\n而我所选择的数据库是[Elasticsearch](https://www.elastic.co/cn/elasticsearch/)，能很轻松的实现上面的效果，并且有个很客观的响应速度。（具体实现自行了解，后端代码暂不考虑开源）\n\n## 上传发布\n\n当本地开发完毕时，点击右上角的上传，填写版本号相关以及项目备注，然后上传成功如下图\n\n![image-20220403125339679](https://img.kuizuo.cn/image-20220403125339679.png)\n\n在版本管理中的开发版本可以看到刚刚上传的代码\n\n![image-20220403133323838](https://img.kuizuo.cn/image-20220403133323838.png)\n\n点击提交审核后，会提示确保项目不是测试版与 Demo（否则将受到相应处罚）如下图\n\n![image-20220403133707429](https://img.kuizuo.cn/image-20220403133707429.png)\n\n### 测试版\n\n或者选择体验版（只有管理员与体验者的账号才可以访问），扫描体验版的二维码，即可使用微信访问项目。\n\n### 审核版本\n\n如果是要发布正式版的话，还需要填写如下表格，接着静等 1-7 天即可（可选择加急，一年一次）\n\n![image-20220406003544712](https://img.kuizuo.cn/image-20220406003544712.png)\n\n等待审核完毕，实测一天内，审核版本如下\n\n![image-20220406123345533](https://img.kuizuo.cn/image-20220406123345533.png)\n\n### 线上版本\n\n最终提交发布，线上版本如下\n\n![image-20220406125311142](https://img.kuizuo.cn/image-20220406125311142.png)\n\n至此，用户即可打开微信，通过小程序访问到该应用。\n\n### 关于改名\n\n可能有些人（这个人就是我）会担心自己上线小程序后，期间能否改名，有何影响。\n\n首先是可以改名的，小程序的标识是 APPID，而不是一个名称。但**改名会直接影响到用户对小程序的认知，从而影响小程序用户流失**。同时改名要求很苛刻，会检索是否有相似同名小程序，以及是否有商标证明等等，并且一年只能修改两次名字，所以起名与改名都要慎重。\n\n## 一些开发时的注意事项（坑）\n\n### request:fail url not in domain list（跨域）\n\n浏览器最烦躁之一跨域，在小程序上也不一意外，但小程序更加苛刻，即便后端允许跨域，小程序请求也会提示标题所示错误。这时候一般就如下几种做法。\n\n[网络 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)\n\n首先要确保是 https，同时开发时为了方便调试，一般会在本地设置中勾选，不效验合法域名选项，如下\n\n![image-20220403012958069](https://img.kuizuo.cn/image-20220403012958069.png)\n\n这时候开发环境下就能正常发送请求相关了（我这里后端是直接允许跨域了，不然需要在 config/index.js 中设置 devServer.proxy 的反向代理）。\n\n但在生成环境下就需要在[小程序](https://mp.weixin.qq.com)中的开发管理中配置服务器域名了\n\n![image-20220403013733314](https://img.kuizuo.cn/image-20220403013733314.png)\n\n点击开始配置会提示身份认证相关，扫完码后将会到如下配置\n\n![image-20220403013828824](https://img.kuizuo.cn/image-20220403013828824.png)\n\n这里就是填写生产环境下要请求资源的域名了，并且是需要开启 https 的。\n\n设置完毕，重启微信开发者工具或刷新项目配置，这里需使用小程序账号的 AppID 进行登录，测试号无效，然后项目配置就会设置好 request 合法域名，再次请求便能正常响应。\n\n![image-20220403014345645](https://img.kuizuo.cn/image-20220403014345645.png)\n\n### pinia 持久化\n\npinia 有个插件`pinia-plugin-persist`，可以对 store 状态进行持久化操作，在小程序中引入时则会提示 sessionStorage is not defined，原因是小程序中并无 sessionStorage 与 localStorag。所以还是得使用原生的数据缓存方法（getStorage，setStorage）来解决，或者将数据存至后端。\n\n### 第三方组件修改样式\n\n在 vue3 中要修改第三方组件库中的组件样式的话，需要使用 `:deep(css选择器)`，同时一般会在 style 加上 scoped，但如果在小程序中使用会发现子组件并不生效，而编译成 h5 却生效。我在这个 issues [taro 3.0 + Vue 中 scoped 在 h5 下生效，在微信小程序中无效](https://github.com/NervJS/taro/issues/6662) 下找到了解决问题\n\n在 h5 模式下 scoped 会生成**[data-v-xxx]** 的属性，但是在小程序下则不会有，所以使用 scopd 在小程序中是无用的。就可以使用 cssModules，前提是需要在 config/index.js 中添加 cssModules 的支持，在上面 issues 中提到过，具体也就这样。\n\n然后在 style 中添加 module 即可生效，都不用使用`:deep` 。\n\n### invalid code, rid: 6249d588-48af462b-xxxxxxx\n\n服务器将 wx.login 获取到的 code 向小程序 API 获取 openid 的时候，如果提示该错误，那么大概率是 APPID 有问题，使用了测试号或者填写了错误 APPID。\n\n## 总结\n\n由于小程序(h5 手机端)应用写的少，所以在页面布局方便写的相对简陋，但本质与前端开发无特别大致区别，无非就是自定义了些相关的标签与 api，遇到时在查阅即可。\n\n但相比传统 Web 开发而言，网站是无需审核只需要有个公网服务器就能访问，而小程序必须要经过审核才可发布，同时对小程序名称有严格的审核。主要方便在于微信用户的获取，同时提供完备的开发以及部署环境（开发者工具，云开发），加上用户数据分析等等。\n\n在我发布完以及写完本文章后，我的建议是：\n\n> 如非必要，不建议上传小程序供他人访问，尤其对于个人开发者而言，网页版也许是个更好的选择。\n\n在回到开发者的角度，Taro 对 Vue3 的体验远比 Uniapp 来的好（至少目前是这样的，个人感受），Uniapp 太依赖于自家的 Hbuilder，但目前 Taro 的 Vue3 无法编译成安卓（React Native），所以如果考虑安卓端与小程序的话，还是 Uniapp 略胜一筹，H5 两者区别不大。但如果只是写小程序，我还是会毫不犹豫使用的使用 Taro。"
    },
    {
      "id": "vite-vue3-build-uniapp-environment",
      "metadata": {
        "permalink": "/vite-vue3-build-uniapp-environment",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/vite+vue3搭建uniapp开发环境.md",
        "source": "@site/blog/program/vite+vue3搭建uniapp开发环境.md",
        "title": "vite+vue3搭建uniapp开发环境",
        "description": "使用 vite vue3 搭建 uniapp 开发环境",
        "date": "2022-03-27T00:00:00.000Z",
        "formattedDate": "2022年3月27日",
        "tags": [
          {
            "label": "vue",
            "permalink": "/tags/vue"
          },
          {
            "label": "vite",
            "permalink": "/tags/vite"
          },
          {
            "label": "uniapp",
            "permalink": "/tags/uniapp"
          },
          {
            "label": "develop",
            "permalink": "/tags/develop"
          }
        ],
        "readingTime": 6.423333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "vite-vue3-build-uniapp-environment",
          "title": "vite+vue3搭建uniapp开发环境",
          "date": "2022-03-27T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "vue",
            "vite",
            "uniapp",
            "develop"
          ],
          "keywords": [
            "vue",
            "vite",
            "uniapp",
            "develop"
          ],
          "description": "使用 vite vue3 搭建 uniapp 开发环境"
        },
        "prevItem": {
          "title": "题小侠",
          "permalink": "/question-man"
        },
        "nextItem": {
          "title": "去除typescript代码类型",
          "permalink": "/remove-ts-code-type"
        }
      },
      "content": "![uniapp](https://img.kuizuo.cn/uniapp.png)\n\n最近想搞个移动端或小程序的 Vue3 项目，所以选择跨端开发平台就显得十分重要。在业内主要有两个跨端开发平台，Taro 与 uniapp，但 uniapp 貌似对 vue3 的支持不是特别友好。所以让我在 Taro 和 uniapp 之间抉择了一段时间，最终还是尝试选择相对熟悉的 uniapp 来进行开发。\n\n:::caution 前排提醒\n\n目前 uniapp 对 Vue3 的支持还处于 alpha 版，即开发阶段，大概率是会遇到很多问题的。\n\n:::\n\n<!-- truncate -->\n\n## 开发环境搭建\n\n建议安装 HBuilderX，主要是 uni cli 在 APP 平台仅支持生成离线打包的 wgt 资源包，不支持云端打包生成 apk/ipa，并且也不便配置一些打包后的参数。\n\n这里建议安装 Alpha 版，后文会说明缘由。\n\n:::caution 注意\n\n在 HBuilderX 正式版中是无法直接创建 Vue3 项目的，而 Alpha 版有 Vue2 和 3 可供选择，但创建的自带的模板大部分的写法还是 vue2 的写法（无 setup 语法糖），所以这时候要么改代码自建，要么使用官方所提供的 [Vue3 模板](https://uniapp.dcloud.io/worktile/CLI.html#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B)\n\n![image-20220327000608783](https://img.kuizuo.cn/image-20220327000608783.png)\n\n:::\n\n```sh\n# 创建以 javascript 开发的工程\nnpx degit dcloudio/uni-preset-vue#vite my-vue3-project\n\n# 创建以 typescript 开发的工程\nnpx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project\n```\n\n当然，有可能会下载失败，可以直接访问 [gitee](https://gitee.com/dcloud/uni-preset-vue/repository/archive/vite-ts.zip)下载模板。\n\n## 项目结构\n\n```\n|-- src\n\t|-- App.vue\n\t|-- env.d.ts\n \t|-- main.ts\n \t|-- manifest.json\n  \t|-- pages.json\n \t|-- uni.scss\n \t|-- pages\n \t|   |-- index\n \t|       |-- index.vue\n  \t|-- static\n \t\t|-- logo.png\n|-- index.html\n|-- package-lock.json\n|-- package.json\n|-- postcss.config.js\n|-- tsconfig.json\n|-- vite.config.ts\n```\n\n下载完毕，开始安装依赖，接着就可以开始测试了。\n\n## 运行编译\n\n在运行之前，首先将**vuex**包给移除，不然将会有如下提示，总之就是不推荐使用的意思，而且要使用状态管理也推荐使用 pinia。所以执行 `yarn remove vuex` 吧\n\n```\n(node:26968) [DEP0148] DeprecationWarning: Use of deprecated folder mapping \"./\" in the \"exports\" field module resolution of the package at F:\\Uniapp\\my-vue3-project1\\node_modules\\vuex\\package.json.\nUpdate this package.json to use a subpath pattern like \"./*\".\n```\n\n### H5\n\n运行编译都正常\n\n### APP\n\n使用`npm run dev:app`后就会发现，终端一直卡在如下界面无法继续。（后面测试发现，除了 H5 能正常运行，其他都会卡住）\n\n```\n编译器版本：3.4.3（vue3）\n请注意运行模式下，因日志输出、sourcemap 以及未压缩源码等原因，性能和包体积，均不及发行模式\n。\n正在编译中...\nvite v2.8.6 building for development...\nDONE  Build complete. Watching for changes...\nready in 1554ms.\n```\n\n然后呢？？？\n\n算了，就用 HBuilderX 的 cli 先运行到手机或模拟器，然后后打开 app 的时候提示如下错误，点击忽略后发现应用无法正常运行。\n\n![image-20220326224649953](https://img.kuizuo.cn/image-20220326224649953.png)\n\n查看了下我本地的 HBuilderX 版本是正式版 v3.3.13，而该 Vue3 的模板的 Alpha 版 v3.4.3\n\n![image-20220326225748608](https://img.kuizuo.cn/image-20220326225748608.png)\n\n好家伙，官方提供的模板都直接使用 Alpha 版，无奈只好点击 [查看详情](https://ask.dcloud.net.cn/article/35627) 后问题解决办法。最终测试后，建议是使用最新版，即 Alpha 版本，于是替换了本地正式版的 HbuilderX，应用便能正常运行了。\n\n既然开发环境下能正常运行，那就试下打包。由于 uniapp 打包安卓应用只能打包成 APP 资源，要打包成 apk，要么创建一个 Android Studio 工程，然后将 APP 资源放入并打包成 apk，要么使用云打包（而云打包又是只有 HBuilder 才有的功能）。如果本地没有 Android Studio 相关环境，建议还是使用云打包（简单方便），这里就不演示下打包过程了。\n\n### 小程序\n\n这里只测试了微信小程序，在上面 app 的处理完之后，微信小程序也是正常运行，不过至于与上面 Vue3 模板和 HbuilderX 正式版有无关系我就不得而知了，也懒得重装测试了。不过猜测应该与上面无关，毕竟是与手机的 SDK 有关。\n\n## 组件库\n\nuniapp 官方中提供了一个 uni-ui 的组件库，但有一个 uniapp 相对知名的组件库 uview，并且相对前者来说更易上手实用，但当我尝试用 HBuilderX 导入时，却出现下方提示。\n\n![image-20220327002827115](https://img.kuizuo.cn/image-20220327002827115.png)\n\n很显然，uview 并不支持 vue3，但在社区中找到了份同时支持 Vue3.0 和 Vue2.0 的[uView](https://ext.dcloud.net.cn/plugin?name=vk-uview-ui)，但测试后最终已失败告终。\n\n在社区中也搜到了 [ThorUI 组件库](https://ext.dcloud.net.cn/plugin?id=556) 但貌似需要会员收费，果断放弃且没有测试。\n\n然后想到 Taro 中还有 nutui，于是我便开始尝试了一下，不出所料，支持 Vue3 组件库，肯定是支持的。演示如下\n\n![image-20220327005629618](https://img.kuizuo.cn/image-20220327005629618.png)\n\n但很遗憾，这里的支持也只是局限于 h5 开发。官方也有声明只能开发 h5\n\n> @nutui/nutui@next 基于 Vue3 视觉风格 JD APP 10.0 规范 ，只能开发 h5\n> @nutui/nutui-taro 基于 Vue3 视觉风格 JD APP 10.0 规范 ，必须基于 taro + vue3 框架 进行开发多端（多端指一套代码 部署多端环境 微信小程序 h5、等第三方小程序）\n\n而且想要多端开发，也必须基于 taro + vue3 框架，所以在 uniapp 上的 app 与小程序上自然无法运行（已测试）\n\n所以说一开始在 uniapp 和 taro 中的选择中，为啥不使用 Taro 呢？而且还支持 Vue3（相比 uniapp 而言）？\n\n最终组件库的选择是 uniapp 官方的 uni-ui。\n\n## 使用 VSCode 开发\n\nHBuilder 给我代码编写体验并不友好，所以将 uniapp 的项目转 vscode 进行开发，并且使用到 npm 包。\n\n首先创建一个 vite+vue3 项目（或者使用一开始介绍的官方提供的 Vue3 模板，主要是有 cli，需要自行在安装），然后将原 src 目录给删除，替换成 uniapp 创建的项目根目录。但还需要做以下操作\n\n### 安装 sass\n\nvite 要支持 sass 只需要安装 sass 的依赖即可\n\n```sh\nnpm install sass\n```\n\n### 允许 js 文件\n\n由于使用了 ts，如果项目中存在 js 文件，将会警告，可以在 tsconfig.json 中添加`\"allowJs\": true`即可\n\n### 组件语法提示\n\n```sh\nnpm i @dcloudio/uni-helper-json @types/uni-app @types/html5plus -D\n```\n\n但发现对于 uni-ui 组件库的代码提示并不友好，大概率是需要局部引用组件，我这里并未使用[npm 包](https://www.npmjs.com/package/@dcloudio/uni-ui)的方式导入，而是采用官方的 uni_modules，不过组件库的代码提示的问题不是很大，查阅文档即可解决。\n\n### 导入代码块\n\n[uni-app 代码块（vscode） (github.com)](https://github.com/zhetengbiji/uniapp-snippets-vscode)\n\n### 找不到模块“./App.vue”或其相应的类型声明\n\n在 src 目录下创建`env.d.ts`文件，填入以下内容即可\n\n```typescript\n/// <reference types=\"vite/client\" />\n\ndeclare module '*.vue' {\n  import { DefineComponent } from 'vue'\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}\n```\n\n然后就是把一些`#ifndef VUE3`不是 vue3 的代码块，以及部分 js 文件改写成 ts 文件即可。这里把我修改后的模板上传到 github 上，有需要的可自行下载：[kuizuo/vite-vue3-uniapp (github.com)](https://github.com/kuizuo/vite-vue3-uniapp)\n\n如果不想使用官方的 vue3 模板，这里也有篇文章介绍如何迁移\n\n[迁移 HbuilderX 的 uniapp 项目到主流的前端 IDE 开发（支持 VS Code 等编辑器/IDE）](https://zhuanlan.zhihu.com/p/268206071)\n\n不过最终如果要在 app 或小程序端运行，还是得打开 HBuilder。\n\n## 总结\n\n整个过程下来，其实还是 uniapp 对 Vue3 支持不够友好，加上生态没能及时更新。并且官方提供的 Vue3 模板也存在一定问题。\n\n但最终还是使用 uniapp 来进行开发，一是对 Vue3 足够了解加上使用过 uniapp，二是 Taro 对 Vue3 是支持了，但是又该如何编译成 App 这是我主要需求的，最主要还是不想踩一遍 Taro 的坑了。"
    },
    {
      "id": "remove-ts-code-type",
      "metadata": {
        "permalink": "/remove-ts-code-type",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/去除typescript代码类型.md",
        "source": "@site/blog/develop/去除typescript代码类型.md",
        "title": "去除typescript代码类型",
        "description": "在短时间内有一个需求，原项目代码是 js，而我手里头的功能代码是 ts 的，需要将其合并。",
        "date": "2022-03-24T00:00:00.000Z",
        "formattedDate": "2022年3月24日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "typescript",
            "permalink": "/tags/typescript"
          }
        ],
        "readingTime": 6.6433333333333335,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "remove-ts-code-type",
          "title": "去除typescript代码类型",
          "date": "2022-03-24T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript",
            "typescript"
          ],
          "keywords": [
            "javascript",
            "typescript"
          ]
        },
        "prevItem": {
          "title": "vite+vue3搭建uniapp开发环境",
          "permalink": "/vite-vue3-build-uniapp-environment"
        },
        "nextItem": {
          "title": "搭建Electron+Vue3开发环境",
          "permalink": "/electron-vue3-development-environment"
        }
      },
      "content": "在**短时间**内有一个需求，原项目代码是 js，而我手里头的功能代码是 ts 的，需要将其合并。\n\n按照以往，我通常会将 js 改写成 ts，但时间方面有限，就采取js的方式。**因此希望将 ts 代码转换为存 js 代码**，只需要把 ts 中的类型直接删除即可，也就是标题所表明的意思。以下在线转化工具能够做到。\n\n[TypeScript to plain JavaScript (transform.tools)](https://transform.tools/typescript-to-javascript)\n\n可以肯定的是 ts 有选项能够去除类型，于是这次就准备深入了解 TypeScript 的编译配置，也顺带复习一下 tsconfig.json 的相关参数。\n\n**毕竟会写代码，不会编译可就...**\n\n<!-- truncate -->\n\n## 安装 TypeScript\n\n要编写 ts 代码，肯定要先安装其工具\n\n```sh\nnpm i -g typescript ts-node\n```\n\n其中`typescript`自带的 tsc 命令并不能直接运行 typescript 代码，而`ts-node`可以直接运行 ts 代码的能力，省去编译阶段。\n\n但不代表`ts-node`等于 ts 版的 Node.js，本质上 Node.js 只是 JavaScript 的运行时环境，而 Deno 确实可以直接运行 TypeScript。\n\n不过本次的主题不在 ts-node 与 deno，而在于将 TypeScript 代码编译到 JavaScript 代码。\n\n## 简单测试\n\n安装完毕，编写一个`demo.ts`的文件，在里面编写如下代码\n\n```typescript title=\"demo.ts\"\nconst add = (a: number, b: number): number => {\n  return a + b\n}\n\nlet c = add(1, 2)\n```\n\n使用命令 `tsc demo.ts`，将会在同级目录下生成`demo.js`，内容如下（默认是 ES5 标准）\n\n```javascript title=\"demo.js\"\nvar add = function (a, b) {\n  return a + b\n}\nvar c = add(1, 2)\n```\n\n## tsconfig.json\n\n可以发现上面转化的代码是 ES5 标准的，然而现在都已经步入到 ES6 阶段了，同时如果有大量 ts 文件需要编译，将十分繁琐，所以就有了 tsconfig.json 用于描述将 **TypeScript** 转为 **JavaScript** 代码的配置文件。\n\n终端使用`tsc --init`，会在目录下生成 tsconfig.json 文件，默认配置如下（已删除原注释）。\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\", // 编译\n    \"module\": \"commonjs\", // 模块导入与导出\n    \"esModuleInterop\": true, // 支持合成模块的默认导入\n    \"forceConsistentCasingInFileNames\": true, // 看不懂\n    \"strict\": true, // 严格模式\n    \"skipLibCheck\": true // 跳过.d.ts\n  }\n}\n```\n\n假设我要编译 ES6 语法的，只需要将 es5 改为 es6，然后在终端输入`tsc`，生成的 js 代码就是 es6 规范的代码。\n\n:::info\n\n如果想要单纯的取出 ts 的类型，可以设置`\"target\": \"ESNext\"`，除了 ts 的一些特殊标准，如 enum，那么生成的 js 代码基本就是原 ts 代码移除类型的代码。（基本上就已经满足了我一开始的需求）\n\n:::\n\n更多配置 => [TypeScript: TSConfig Reference - Docs on every TSConfig option (typescriptlang.org)](https://www.typescriptlang.org/tsconfig)\n\n更多相关 TS 编译配置和使用说明可以通过 `tsc -h` 查看。\n\n这里有份 [tsconfig.json 全解析](https://juejin.cn/post/7039583726375796749#heading-22) 内容如下\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    /* 基本选项 */\n    \"target\": \"es6\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [], // 指定要包含在编译中的库文件\n    \"allowJs\": true, // 允许编译 javascript 文件\n    \"checkJs\": true, // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true, // 生成相应的 '.d.ts' 文件\n    \"declarationDir\": \"./dist/types\", // 生成的 '.d.ts' 文件保存文件夹\n    \"sourceMap\": true, // 生成相应的 '.map' 文件\n    \"outFile\": \"./\", // 将输出文件合并为一个文件\n    \"outDir\": \"./dist\", // 指定输出目录\n    \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true, // 删除编译后的所有的注释\n    \"noEmit\": true, // 不生成输出文件\n    \"importHelpers\": true, // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true, // 启用所有严格类型检查选项\n    \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true, // 启用严格的 null 检查\n    \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true, // 报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\", // 用于解析非相对模块名称的基础目录\n    \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [], // 包含类型声明的文件列表\n    \"types\": [], // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。\n    \"esModuleInterop\": true, // 支持合成模块的默认导入\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true, // 启用装饰器\n    \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持\n  },\n  /* 指定编译文件或排除指定编译文件 */\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"**/*.spec.ts\"],\n  \"files\": [\"index.ts\", \"test.ts\"],\n  // 从另一个配置文件里继承配置\n  \"extends\": \"@tsconfig/recommended\",\n  // 让 IDE 在保存文件的时候根据 tsconfig.json 重新生成文件\n  \"compileOnSave\": true // 支持这个特性需要Visual Studio 2015， TypeScript 1.8.4 以上并且安装 atom-typescript 插件\n}\n```\n\n## 常用配置\n\n原本想自己总结一遍，但刷到了下面这篇文章，总结的太好了，以至于我都不是很想再写一遍主要的配置 🤩\n\n[会写 TypeScript 但你真的会 TS 编译配置吗？ - 掘金 (juejin.cn)](https://juejin.cn/post/7039583726375796749#heading-4)\n\n话虽说，但一些主要的功能还是得写一下\n\n### 配置别名\n\n在一些项目中经常能看到导入模块不是使用相对路径`./`，而是像`@/`，其中@表示 src，也就是项目的原代码目录下，也就是路径别名。要实现这样的配置，项目的脚手架肯定是需要修改的。这里我就以 vite 为例。\n\n```typescript title=\"vite.config.ts\"\nimport { defineConfig } from 'vite'\nimport { resolve } from 'path'\n\nexport default defineConfig {\n    resolve: {\n        alias: {\n            \"@\": resolve(__dirname, 'src'), // 路径别名\n        },\n        extensions: ['.js', '.json', '.ts'] // 使用路径别名时想要省略的后缀名\n    }\n    // ...\n}\n```\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // 必写，用于设置解析非相对模块名称的基本目录\n    \"paths\": {\n      \"@/*\": [\"src/*\"] // 用于设置模块名到基于baseUrl的路径映射\n    }\n    // ...\n  }\n}\n```\n\n### 支持合成默认导入\n\n在使用 ESM（ES module） 编写代码的时候，引入 CJS（CommonJS）的模块，通常需要写成 `import * as React from 'react'`的形式，若写成 `import React from 'react'` 将会提示 **模块“\"http\"”没有默认导出**。，如果将`esModuleInterop`设置为 true，同时`allowSyntheticDefaultImports` 也会自动设置为 true，则可以写成后者的形式。\n\n这里有篇文章详细的说明缘由 [esModuleInterop 到底做了什么？](https://zhuanlan.zhihu.com/p/148081795)\n\n> 所以，尽量不要用 default 导出。 ——借评论区的一条评论\n\n### 声明浏览器全局对象 API\n\n在代码中使用到浏览器的对象，如 window、document，这些对于**TypeScript Complier** 来说是不能识别。可以通过在 lib 字段中设置`\"DOM\"`\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"lib\": [\"ES5\", \"ES6\", \"DOM\"]\n  }\n}\n```\n\n### 声明文件\n\n```json\n{\n  \"compilerOptions\": {\n    \"declaration\": true, // 生成相应的`.d.ts`文件\n    \"declarationDir\": \"./dist/types\" 生成的 '.d.ts' 文件保存文件夹\n  }\n}\n```"
    },
    {
      "id": "electron-vue3-development-environment",
      "metadata": {
        "permalink": "/electron-vue3-development-environment",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/搭建Electron+Vue3开发环境.md",
        "source": "@site/blog/program/搭建Electron+Vue3开发环境.md",
        "title": "搭建Electron+Vue3开发环境",
        "description": "搭建 Electron Vue3 的开发环境，用于编写跨平台应用",
        "date": "2022-03-17T00:00:00.000Z",
        "formattedDate": "2022年3月17日",
        "tags": [
          {
            "label": "electron",
            "permalink": "/tags/electron"
          },
          {
            "label": "vue",
            "permalink": "/tags/vue"
          },
          {
            "label": "vite",
            "permalink": "/tags/vite"
          }
        ],
        "readingTime": 2.66,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "electron-vue3-development-environment",
          "title": "搭建Electron+Vue3开发环境",
          "date": "2022-03-17T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "electron",
            "vue",
            "vite"
          ],
          "keywords": [
            "electron",
            "vue",
            "vite"
          ],
          "description": "搭建 Electron Vue3 的开发环境，用于编写跨平台应用"
        },
        "prevItem": {
          "title": "去除typescript代码类型",
          "permalink": "/remove-ts-code-type"
        },
        "nextItem": {
          "title": "SSE 服务器发送事件",
          "permalink": "/sse-server-send-event"
        }
      },
      "content": "![image-20220316204205165](https://img.kuizuo.cn/image-20220316204205165.png)\n\n之前用 electron-vue 写过一个半成品的桌面端应用，但是是基于 Vue2 的，最近又想重写点桌面端应用，想要上 Vue3+TypeScript，于是便有了这篇文章总结下具体的搭建过程。\n\n<!-- truncate -->\n\n## Vue Cli\n\nVue CLI 有一个插件`vue-cli-plugin-electron-builder`，可以非常方便的搭建 electron 环境。\n\n```sh\nnpm i @vue/cli -g\n```\n\n```sh\nvue create my-app\n```\n\n根据自己项目的需求选择对应的依赖（例如 Babel，TS，Vuex 等等）\n\n```sh\nVue CLI v5.0.3\n? Please pick a preset: Manually select features\n? Check the features needed for your project: Babel, TS, Vuex, CSS Pre-processors, Linter\n? Choose a version of Vue.js that you want to start the project with 3.x\n? Use class-style component syntax? Yes\n? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes\n? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with dart-sass)\n? Pick a linter / formatter config: Prettier\n? Pick additional lint features: Lint on save\n? Where do you prefer placing config for Babel, ESLint, etc.? In package.json\n? Save this as a preset for future projects? No\n\n\nVue CLI v5.0.3\n✨  Creating project in F:\\Electron\\my-app.\n🗃  Initializing git repository...\n⚙️  Installing CLI plugins. This might take a while...\n```\n\n### 安装 vue-cli-plugin-electron-builder\n\n[Vue CLI Plugin Electron Builder (nklayman.github.io)](https://nklayman.github.io/vue-cli-plugin-electron-builder/)\n\n```sh\ncd my-app\nvue add electron-builder\n```\n\n安装过程中会提示你选择 Electron 的版本，选择最新版本即可\n\n### 启动项目\n\n```sh\nnpm run electron:serve\n```\n\n参考文章：[Electron + Vue3 开发跨平台桌面应用【从项目搭建到打包完整过程】 - 掘金 (juejin.cn)](https://juejin.cn/post/6983843979133468708)\n\n### 坑\n\n```\nerror  in ./src/background.ts\n\nModule build failed (from ./node_modules/ts-loader/index.js):\nTypeError: loaderContext.getOptions is not a function\n```\n\n我测试的时候，`@vue/cli-plugin-typescript`版本为`~5.0.0`，就会导致编译类型出错，将 package.json 中改为`\"@vue/cli-plugin-typescript\": \"~4.5.15\"`，即可正常运行（但还是会有 DeprecationWarning）\n\n## Vite\n\n上面是使用 Vue Cli 脚手架进行开发，如果想上 Vite 的话，就需要用 Vite 来构建项目，然后安装 electron 的相关依赖。\n\n这个不是作为重点，因为很多大佬都已经写了现成的模板，完全可以自行借鉴学习，就贴几个阅读过的几篇文章\n\n[Vite + Vue 3 + electron + TypeScript - DEV Community](https://dev.to/brojenuel/vite-vue-3-electron-5h4o)\n\n[2021 年最前卫的跨平台开发选择！vue3 + vite + electron - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/424202065)\n\n### 现成的模板\n\n均可在 github 上搜索到\n\n- [vite-react-electron](https://github.com/caoxiemeihao/vite-react-electron) (推荐)\n\n- [electron-vue-vite](https://github.com/caoxiemeihao/electron-vue-vite) (推荐)\n- [vite-electron-builder](https://github.com/cawa-93/vite-electron-builder)\n\n### electron-vite 脚手架（推荐）\n\n当然也可以使用脚手架，可选择 React 与 Vue，实际上也就是创建上面的前两个模板\n\n```sh\nnpm create electron-vite\n```\n\n## 现有项目使用 electron\n\nTODO...\n\n## 总结\n\n因为 Electron 本质上还是一个浏览器，无论是 Vue 还是 React 开发也好，在传统网页开发的时候都有对应的调试地址，如http://127.0.0.1:3000，而electron的做法无非就是开启一个浏览器，然后和正常的网页开发一样，并提供桌面端的api使用。\n\n目前社区两大 Vue+Electron 的脚手架主要是[electron-vue](https://github.com/SimulatedGREG/electron-vue)和[vue-cli-plugin-electron-builder](https://github.com/nklayman/vue-cli-plugin-electron-builder)，更多 electron 的开源项目都遵循着前者的项目结构，像上面的模板也就是。\n\n以上就是我所使用 Vue3 来开发 Electron 的环境搭建过程，总体来说从 Electron 除了应用体积过大，对于前端开发者来说是非常友好的，既然环境配置完，那么现在就可以开始好好的编写桌面端应用了。"
    },
    {
      "id": "sse-server-send-event",
      "metadata": {
        "permalink": "/sse-server-send-event",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/SSE 服务器发送事件.md",
        "source": "@site/blog/develop/SSE 服务器发送事件.md",
        "title": "SSE 服务器发送事件",
        "description": "先放一张 gif 图展示下效果",
        "date": "2022-03-16T00:00:00.000Z",
        "formattedDate": "2022年3月16日",
        "tags": [
          {
            "label": "http",
            "permalink": "/tags/http"
          }
        ],
        "readingTime": 2.1266666666666665,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "sse-server-send-event",
          "title": "SSE 服务器发送事件",
          "date": "2022-03-16T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "http"
          ],
          "keywords": [
            "http"
          ]
        },
        "prevItem": {
          "title": "搭建Electron+Vue3开发环境",
          "permalink": "/electron-vue3-development-environment"
        },
        "nextItem": {
          "title": "在线工具",
          "permalink": "/online-tools"
        }
      },
      "content": "<!-- truncate -->\n\n先放一张 gif 图展示下效果\n\n![sse](https://img.kuizuo.cn/sse.gif)\n\n实现上面这个效果之前，先补充点前置知识\n\n众所周知，在 HTTP 协议中，服务器无法向浏览器推送信息，可以使用 WebSocket 来实现两者双向通信。而在这里所要介绍的是 SSE（Server-Sent Events），在浏览器向服务器请求后，服务器每隔一段时间向客户端发送流数据（是单向的），来实现接收服务器的数据，例如在线视频播放，和像上面所演示的效果。\n\n![img](https://www.ruanyifeng.com/blogimg/asset/2017/bg2017052702.jpg)\n\n关于 SSE 标准文档 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)\n\n### 优点\n\n- SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。\n- SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。\n- SSE 默认支持断线重连，WebSocket 需要自己实现。\n- SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。\n- SSE 支持自定义发送的消息类型。\n\n## 服务器实现\n\n### 数据格式\n\n服务器向浏览器发送的 SSE 数据，必须是 UTF-8 编码的文本，具有如下的 HTTP 头信息。\n\n```http\nContent-Type: text/event-stream; charset=utf-8\nCache-Control: no-cache\nConnection: keep-alive\n```\n\n使用 Node 实现的代码如下\n\n```javascript\nvar http = require('http')\n\nhttp\n  .createServer(function (req, res) {\n    var fileName = '.' + req.url\n\n    if (fileName === './stream') {\n      res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        Connection: 'keep-alive',\n        'Access-Control-Allow-Origin': '*',\n      })\n      res.write('retry: 10000\\n')\n      res.write('event: connecttime\\n')\n      res.write('data: ' + new Date() + '\\n\\n')\n      res.write('data: ' + new Date() + '\\n\\n')\n\n      interval = setInterval(function () {\n        res.write('data: ' + new Date() + '\\n\\n')\n      }, 1000)\n\n      req.connection.addListener(\n        'close',\n        function () {\n          clearInterval(interval)\n        },\n        false,\n      )\n    }\n  })\n  .listen(8844, '127.0.0.1')\n```\n\n通过 node server.js 运行服务端，此时浏览器访问 http://127.0.0.1:8844/stream 得到的效果就是开头的 gif 所演示的。\n\n## 客户端 API\n\n像上面是直接向服务器请求，浏览器有`EventSource`对象，比如监听 SSE 连接，以及主动关闭 SSE 连接，具体的演示代码如下\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>JS Bin</title>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script>\n      var source = new EventSource('http://127.0.0.1:8844/stream')\n      var div = document.getElementById('example')\n\n      source.onopen = function (event) {\n        div.innerHTML += '<p>Connection open ...</p>'\n      }\n\n      source.onerror = function (event) {\n        div.innerHTML += '<p>Connection close.</p>'\n      }\n\n      source.addEventListener(\n        'connecttime',\n        function (event) {\n          div.innerHTML += '<p>Start time: ' + event.data + '</p>'\n        },\n        false,\n      )\n\n      source.onmessage = function (event) {\n        div.innerHTML += '<p>Ping: ' + event.data + '</p>'\n      }\n    </script>\n  </body>\n</html>\n```\n\n并且由于是调用浏览器 API，在开发者工具的网络面板上还能看到对应的 EventStream，像下面这样\n\n![image-20220316134321431](https://img.kuizuo.cn/image-20220316134321431.png)\n\n## 参考链接\n\n> [使用服务器发送事件 - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events)\n>\n> [Server-Sent Events 教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)"
    },
    {
      "id": "online-tools",
      "metadata": {
        "permalink": "/online-tools",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/在线工具.md",
        "source": "@site/blog/project/在线工具.md",
        "title": "在线工具",
        "description": "基于 React 与 MUI 组件库搭建在线工具网站",
        "date": "2022-03-16T00:00:00.000Z",
        "formattedDate": "2022年3月16日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          },
          {
            "label": "tool",
            "permalink": "/tags/tool"
          }
        ],
        "readingTime": 8.266666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "online-tools",
          "title": "在线工具",
          "date": "2022-03-16T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "react",
            "tool"
          ],
          "keywords": [
            "project",
            "react",
            "tool"
          ],
          "description": "基于 React 与 MUI 组件库搭建在线工具网站",
          "image": "/img/project/online-tools.png"
        },
        "prevItem": {
          "title": "SSE 服务器发送事件",
          "permalink": "/sse-server-send-event"
        },
        "nextItem": {
          "title": "HTTP请求配置客户端SSL证书",
          "permalink": "/http-config-client-ssl-certificate"
        }
      },
      "content": "![愧怍在线工具](/img/project/online-tools.png)\n\n[在线工具地址](http://tools.kuizuo.cn/)\n\n之前学习的时候，都会看到网络上一些在线工具的网站，比如获取时间戳，编码转化，正则表达式等等，这些对于一些初学者在电脑上没有安装相对应的工具，往往就会百度搜索在线工具，然后就能实现自己所要完成的目的。\n\n这些工具很是方便，或多或少都会用到。但一些在线工具并不能满足我日常开发中的个别需求，于是乎我也准备自己写一个这样的在线工具网站。不过这里肯定不会像其他网站那种搞得花里胡哨的，同时也不会去重复的造轮子，这样很没有意义。\n\n顺便也记录下这类工具的编写以及用途\n\n<!-- truncate -->\n\n## 技术栈\n\n有一段时间没怎么写 React 了，同时对 mui 组件库感兴趣，于是这次的使用 React 和 material 设计风格的组件库来进行编写，使用到 create-react-app 脚手架进行开发，同时使用 TypeScript 进行编写。\n\n该纯前端，无任何后端交互部分。\n\n不做代码分析与演示，可自行在网站上测试与 clone 源码进行查看。\n\n## 功能\n\n### 查询字符串与 json 转化\n\n如果是在协议复现的话，有些包的请求体是通过查询字符串来拼接的，也就是协议头`Content-Type：application/x-www-form-urlencoded`，请求体如 `username=kuizuo&password=a123456`，一般情况下都不会采取字符串来进行替换，而是转成 json 格式，如 `{ \"username\":\"kuizuo\",\"password\",\"a123456\"}` 然后使用一些库（querystring）将 json 转成查询字符串的形式。\n\n但是编写代码的时候，**需要把抓包得到的查询字符串转成 json**，而这也就是这部分的主要功能。\n\n不过 js 本身是不支持 gbk 编码的，遇到使用 gbk 进行 url 编码的网站就需要自定义先将原文本进行 gbk 编码或解码然后才进行转化操作。\n\n### Cookie 与 json 转化\n\n和查询字符串与 json 转化功能类似，只不过是将 cookie 文本与 json 互转。\n\n### URL UTF8 与 GBK 编码\n\n有些国内网站上可能会使用 GBK 编码，但大多数语言默认都是 UTF8 编码，如果编码格式错误，后端接收到的请求必定失败。在这里我是使用到[gbk-nice](https://www.npmjs.com/package/gbk-nice)这个库，可以达到 gbk 版的`encodeURIComponent`与`decodeURIComponent`，与 js 自带的`encodeURIComponent`和`decodeURIComponent`也就是 gbk 与 utf-8 编码的区别。\n\n## 网站实现\n\n上面所介绍的都是作为一个工具库的功能，我只是将其封装成一个在线工具使用，并非主要重点。而主要是对一些网站的功能实现，例如复制与下载等等。\n\n### react-codemirror\n\n在网页上展示代码，并有代码高亮的功能，首选的组件就是 codemirror 了，也是很多在线工具都使用的，我这里也不例外。\n\n[React CodeMirror](https://uiwjs.github.io/react-codemirror/)\n\n### 复制\n\n复制的话其实是可以使用 npm 包的，但是之前在写其他项目的时候，看到封装过一个 copyToClipboard 的功能，这里也就是将其拷贝置 utils 下供外部使用。\n\n```typescript\ninterface Options {\n  target?: HTMLElement\n}\n\nexport function copyTextToClipboard(input: string, { target = document.body }: Options = {}) {\n  const element = document.createElement('textarea')\n  const previouslyFocusedElement = document.activeElement\n\n  element.value = input\n\n  element.setAttribute('readonly', '')\n  ;(element.style as any).contain = 'strict'\n  element.style.position = 'absolute'\n  element.style.left = '-9999px'\n  element.style.fontSize = '12pt'\n\n  const selection = document.getSelection()\n  let originalRange\n  if (selection && selection.rangeCount > 0) {\n    originalRange = selection.getRangeAt(0)\n  }\n\n  target.append(element)\n  element.select()\n\n  element.selectionStart = 0\n  element.selectionEnd = input.length\n\n  let isSuccess = false\n  try {\n    isSuccess = document.execCommand('copy')\n  } catch (e: any) {\n    throw new Error(e)\n  }\n\n  element.remove()\n\n  if (originalRange && selection) {\n    selection.removeAllRanges()\n    selection.addRange(originalRange)\n  }\n\n  if (previouslyFocusedElement) {\n    ;(previouslyFocusedElement as HTMLElement).focus()\n  }\n  return isSuccess\n}\n```\n\n主要使用浏览器中的`document.execCommand('copy')`\n\n### 下载\n\n在需要这个需求的时候，我一开始是懵的，因为之前我是没有写过原生的浏览器下载事件，都是使用外有已经封装好的的接口直接调用即可，于是这次我也是毫不意外的通过搜索引擎找到了个复制的代码\n\n```typescript\ntype BlobPart = BufferSource | Blob | string\n\nexport function downloadByData(data: BlobPart, filename: string, mime?: string, bom?: BlobPart) {\n  const blobData = typeof bom !== 'undefined' ? [bom, data] : [data]\n  const blob = new Blob(blobData, { type: mime || 'application/octet-stream' })\n  const blobURL = window.URL.createObjectURL(blob)\n  const tempLink = document.createElement('a')\n  tempLink.style.display = 'none'\n  tempLink.href = blobURL\n  tempLink.setAttribute('download', filename)\n  if (typeof tempLink.download === 'undefined') {\n    tempLink.setAttribute('target', '_blank')\n  }\n  document.body.appendChild(tempLink)\n  tempLink.click()\n  document.body.removeChild(tempLink)\n  window.URL.revokeObjectURL(blobURL)\n}\n```\n\n原理的话是创建[Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)对象（类文件对象），将数据写入，然后创建一个 a 标签（隐藏任何样式），然后并点击创建后的 a 标签，最终移除 a 标签，已达到类似点击下载按钮来下载文件的目的。\n\n### 主题切换\n\n我一开始实现这个功能是想使用自定义 hooks 的，但是在我编写的过程中，发现切换主题的组件与 codemirror 展示的组件，并不属于在一个组件内。也就是说，我如果写了个 useTheme（实际上我也真写了），我相当于在这两个组件内都使用了独立的状态，互不影响，也就是我点击了切换主题的按钮，但影响不到展示组件的代码。也算是加深了我对 hooks 的理解。\n\n然后我就在想 Vue 的话是如何实现主题切换的，然后翻看了一些 vue 相关的代码，不出所料，使用到全局状态管理，也就是 Store。react 状态管理有 redux，还有官方提供的 useReducer，但我感觉都太繁琐了，于是我另寻其路。\n\n我博客不是就是用 React 写的吗，我直接看源码是如何实现的，发现使用到了 React 的 useContext，也就是接下来我所要写的。\n\n#### useContext\n\n首先要明确的是，theme 的状态应该是放在全局配置或者说最顶层的组件（当做父组件），然后子组件接收父组件的相关数据进行重新渲染组件。如果只是父子两层之间的关系还相对简单些，直接通过 props 传参即可，但是对于大部分组件关系，基本都是祖孙级别的关系，所以也就有了 Context。\n\n并且 [官方文档](https://react.docschina.org/docs/context.html#reactcreatecontext) 中也是用主题切换作为 context 作为演示例子。而对于应用程序中许多组件都需要的属性，Context 无法是一个很好的选择。\n\n首先我创建了一个 Context\n\n```tsx\nimport { createContext } from 'react'\n\nexport const ThemeContext = createContext<any>({})\n```\n\n然后在顶层组件中使用（Demo 仅作为演示），其中 value 需要是需要传入给子孙组件所要使用的状态或函数，比方这里 theme 和 toggleTheme。\n\n```tsx\nimport { ThemeContext } from '../contexts/theme-context'\n;<ThemeContext.Provider value={{ theme, toggleTheme }}>\n  <Demo></Demo>\n</ThemeContext.Provider>\n```\n\n在子孙组件的话就可以使用 `useContext(ThemeContext)` 来获取父级传入的数据，在这里也就是 `{ theme, toggleTheme }`\n\n```tsx\nimport { ThemeContext } from '../contexts/theme-context'\n\nexport default function SwitchTheme() {\n  const { theme, toggleTheme } = useContext(ThemeContext)\n\n  // ...\n}\n```\n\n接着就是切换主题的按钮点击，然后更改 theme，就会渲染对应的组件，至此切换主题的功能也就完成了\n\n## keep-alive\n\n在使用 mui 的 Tabs 组件库时，来回切换 Tab 会导致上一个页面的组件重新渲染，状态返回初始状态。这肯定不是我所希望的，由于我之前又有接触过 Vue，所以自然而然就联想到 keep-alive，然后我就去搜索 react 的 keep-alive 解决方案，找到了个[react-activation](https://github.com/CJY0208/react-activation)，并解决了的需求。\n\n想做到的目的就是能把 Demo 组件缓存起来，像下面这样的写法\n\n```tsx\n<KeepAlive>\n  <Demo></Demo>\n</KeepAlive>\n```\n\n由于我使用的是 React17+，所以需要使用放置`<AliveScope>`外层，也就是上面的代码要改写成\n\n```tsx\n<AliveScope>\n  <KeepAlive>\n    <Demo></Demo>\n  </KeepAlive>\n</AliveScope>\n```\n\n不过要注意: 当与`react-router`或`react-redux`一起使用时，你需要将`<AliveScope>`放在`<Router>`或`<Provider>`内\n\n这些在官方文档中也有介绍，这里就不细说了。\n\n## Webpack5 配置 Node 相关库\n\n由于使用的 create-react-app，就使用到了 Webpack5，但是 Webpack5 是不支持 Node 自带的一些库，例如我所需要使用到的 Buffer，所以就需要 npm run eject 把 webpack 配置暴露出来。\n\n如果是要配置 Node 相关库是有一个插件 [NodePolyfillPlugin](https://www.npmjs.com/package/node-polyfill-webpack-plugin)，将会把 Node 的系统库的函数注册到 webpack 中供前端使用，相对简单，而且方便。但相对打包体积肯定有所提升，这里只是提提。\n\n在 webpack5 官方有个测试 [兼容性](https://webpack.docschina.org/migrate/5/#test-webpack-5-compatibility) 的，就有提到 `Buffer: false`\n\n```javascript\nmodule.exports = {\n  // ...\n  node: {\n    Buffer: false,\n    process: false,\n  },\n}\n```\n\n要解决 Buffer 也比较简单，直接通过如下代码即可\n\n```javascript\nmodule.exports = {\n  // ...\n  plugins: {\n    ...new webpack.ProvidePlugin({\n      Buffer: ['buffer', 'Buffer'],\n    }),\n  },\n}\n```\n\n也有可能需要在 resolve 中设置下 fallback\n\n```javascript\nresolve: {\n  fallback: {\n    buffer: require.resolve('buffer')\n  }\n}\n```\n\n## 总结\n\n实际编写过程其实并不轻松，但是好在很多坑与开发难点都有前人的遇到，所以搜索就已经帮我解决了很多问题。不过这期间也是不断的尝试，编译，最终实现结果是符合我一开始的期望的。\n\n不过目前所编写的几个功能主要为我目前写协议复现所需要的，而对于大部分像时间戳，正则，加解密相关这些外面都有现成的，何必又要花费时间去造轮子呢。\n\n后续的话应该还是会添加一些额外的功能，例如搞个代码框的配置页面，可供选择语言，代码框的高度，可视化表格的增删改。同时对代码进行一定的重构，对一些组件复用，已经完善持久化的配置。\n\n最主要还是希望能成为我日常开发中常用的在线工具类，而不是简简单单 Demo 学习。"
    },
    {
      "id": "http-config-client-ssl-certificate",
      "metadata": {
        "permalink": "/http-config-client-ssl-certificate",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/HTTP请求配置客户端SSL证书.md",
        "source": "@site/blog/develop/HTTP请求配置客户端SSL证书.md",
        "title": "HTTP请求配置客户端SSL证书",
        "description": "在学习安卓逆向的时候，遇到一个 APP，服务端检测请求的 SSL 证书，需要提交 SSL 证书上去才能正常发送请求。而在开启抓包和协议复现的时候，请求是能正常发出去，但是服务器会返回 400 错误。于是便有了这篇文章来记录下。",
        "date": "2022-02-17T00:00:00.000Z",
        "formattedDate": "2022年2月17日",
        "tags": [
          {
            "label": "http",
            "permalink": "/tags/http"
          },
          {
            "label": "ssl",
            "permalink": "/tags/ssl"
          }
        ],
        "readingTime": 1.7833333333333334,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "http-config-client-ssl-certificate",
          "title": "HTTP请求配置客户端SSL证书",
          "date": "2022-02-17T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "http",
            "ssl"
          ],
          "keywords": [
            "http",
            "ssl"
          ]
        },
        "prevItem": {
          "title": "在线工具",
          "permalink": "/online-tools"
        },
        "nextItem": {
          "title": "记一次Github提交PR过程",
          "permalink": "/github-pr-experience"
        }
      },
      "content": "在学习安卓逆向的时候，遇到一个 APP，服务端检测请求的 SSL 证书，需要提交 SSL 证书上去才能正常发送请求。而在开启抓包和协议复现的时候，请求是能正常发出去，但是服务器会返回 400 错误。于是便有了这篇文章来记录下。\n\n<!-- truncate -->\n\n## 说明\n\n由于是服务端效验客户端发送的证书，所以使用代理服务器（FD，Charles 等）抓包是会替换本地证书，当服务器效验客户端发送的证书与服务器内的证书不一致，那么就直接返回 400 错误，实际上请求还是能够发送出去，只是被服务器给拒绝了。俗称**双向认证**\n\n所以解决办法就是在请求的时候，将正确的证书也一同发送过去，这样服务端效验时就会将正常的响应结果返回给客户端，也就是**配置自定义证书**。\n\n### 例子\n\nAPP 例子：隐约\n\n具体如何拉取证书，就是安卓逆向相关的部分了，这里我也只提供证书文件，不提供 app。\n\n贴上下载地址及密码\n\n证书: https://img.kuizuo.cn/cert.p12\n\n密码: `xinghekeji888.x`\n\n### 证书转化\n\n[证书格式转换 (myssl.com)](https://myssl.com/cert_convert.html)\n\n[SSL 在线工具-在线证书格式转换-证书在线合并-p12、pfx、jks 证书在线合成解析-SSLeye 官网](https://www.ssleye.com/ssltool/jks_pkcs12.html)\n\n也可使用 OpenSSL 工具来进行转化证书\n\n## HTTP 发送请求\n\n### node 的 axios\n\n```javascript\nconst axios = require('axios').default\nconst fs = require('fs')\nconst https = require('https')\n\naxios\n  .post(\n    `https://app.yyueapp.com/api/passLogin`,\n    {\n      mobile: '15212345678',\n      password: 'a123456',\n    },\n    {\n      httpsAgent: new https.Agent({\n        cert: fs.readFileSync('./cert.cer'),\n        key: fs.readFileSync('./cert.key'),\n        // pfx: fs.readFileSync('./cert.p12'),\n        // passphrase: 'xinghekeji888.x,\n      }),\n    },\n  )\n  .then((res) => {\n    console.log(res.data)\n  })\n  .catch((error) => {\n    console.log(error.response.data)\n  })\n```\n\n如果没有配置 httpsAgent，也就是没有配置证书，那么返回 400 错误 `400 No required SSL certificate was sent`。\n\n配置成功将会得到正确的响应结果\n\n```javascript\n{ code: 998, msg: '系统维护中...', data: null }\n```\n\n### python 的 requests\n\nrequests 不支持 p12 格式的证书，所以需要使用其他的证书格式，如下\n\n```python\nimport requests\n\nr = requests.post('https://app.yyueapp.com/api/passLogin', data={\n                  'mobile': '15212345678', 'password': 'a123456'}, cert=('./cert.cer', './cert.key'))\nprint(r.status_code)\nprint(r.text)\n```"
    },
    {
      "id": "github-pr-experience",
      "metadata": {
        "permalink": "/github-pr-experience",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/reference/记一次Github提交PR过程.md",
        "source": "@site/blog/reference/记一次Github提交PR过程.md",
        "title": "记一次Github提交PR过程",
        "description": "故事起因",
        "date": "2022-01-25T00:00:00.000Z",
        "formattedDate": "2022年1月25日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "github",
            "permalink": "/tags/github"
          },
          {
            "label": "blog",
            "permalink": "/tags/blog"
          }
        ],
        "readingTime": 4.993333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "github-pr-experience",
          "title": "记一次Github提交PR过程",
          "date": "2022-01-25T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "github",
            "blog"
          ],
          "keywords": [
            "随笔",
            "github",
            "blog"
          ]
        },
        "prevItem": {
          "title": "HTTP请求配置客户端SSL证书",
          "permalink": "/http-config-client-ssl-certificate"
        },
        "nextItem": {
          "title": "JavaScript中的二进制数据",
          "permalink": "/js-binary-data"
        }
      },
      "content": "## 故事起因\n\n博客正准备写一个项目展示的功能，其中 Docusaurus 中的[案例展示](https://docusaurus.io/zh-CN/showcase)就很适合改写成项目展示页面，然后无意间刷到我当时搭建博客所参考的博主[峰华](https://zxuqian.cn/)的博客也在展示页面。\n\n![image-20220124214558772](https://img.kuizuo.cn/20220124214558.png)\n\n于是脑海中就想：要不然提交一下我的博客试试看？然后便有了下文的故事\n\n<!-- truncate -->\n\n## 故事过程\n\n当时具体提交的[Pull requests](https://github.com/facebook/docusaurus/pull/6458)\n\n展示页面中有个很明显的按钮 Please add your site，点击后就跳转到 Github 的编辑页面了，不过浏览器不方便操作代码，所以我就 clone 了项目，根据提示，修改了两份代码（一个是添加背景图片，一个是添加博客的 json 数据）提交了 PR（Pull requests）。\n\n![image-20220124215841410](https://img.kuizuo.cn/20220124215841.png)\n\n一开始我是怀着尝试的态度去提交的，所以我不小心将代码格式化（也就是第 10 行 sortBy 两边的空格，原本代码风格是没有的），直到我已经提交上去的时候才发现 😂，甚至提交的时候我连 _description_ 都没写（所以我当时真是怀着尝试的态度去提交的）。虽然这是我第二次提交 PR，但也告诉我以后 commit 提交，一定一定一定要比对前后代码变动的地方，不然就会像上面这样。\n\n提交完之后，很快就有机器人给我回复\n\n![image-20220124220731250](https://img.kuizuo.cn/20220124220731.png)\n\n大致的意思：首先很感谢你为社区提交请求，但是呢，为了合并你的代码，我们必须要贡献者签署我们的贡献者许可协议\n\n很显然我并没有签署过，于是它就把解决方案也告诉了我，叫我访问https://code.facebook.com/cla，去签署CLA签名（贡献者许可协议），像下面这样，点击Submit就可以提交。\n\n![image-20220124221203894](https://img.kuizuo.cn/20220124221203.png)\n\n当时我看签署完毕后，返回 PR 页面还是提交要签署，所以我打算关掉这个 pr，准备重新提交一个新的 PR。（这种做法是真的愚蠢，尤其是在一个大型的开源项目）\n\n就正当我关闭 pr 的时候，这时 Reviewers（审核人）给我回复了一条信息\n\n![image-20220124221555614](https://img.kuizuo.cn/20220124221555.png)\n\n> Hey, please don't close your PR if just because of the CLA. The bot will update your status soon after you signed it.\n\n意思就是：请不要在签署 CLA 签名前关闭 PR，机器人会自动在你签署后自动为你更改状态\n\n然后我就灰溜溜的重新开放 PR，那时候感觉我是真小白，太尴尬了 😅。\n\n然后等待了差不多有半个小时左右，机器人给了回复\n\n![image-20220124222432479](https://img.kuizuo.cn/20220124222432.png)\n\n> Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Meta Open Source project. Thanks!\n\n意思：感谢您签署我们的贡献者许可协议。我们现在可以接受您的代码为这个(和任何)元开放源码项目。谢谢!\n\n然后审核人为我的错误 commit 标题进行了修改~~docs: Add Kuizuo's Personal Website to showcase page~~ docs: add Kuizuo's Personal Website to showcase，**第一个单词 Add 不应该首字母大写**，不符合规范。\n\n然后为我提交的代码做了一些小调整 minor tweaks，也就是上面所提到的 sortBy 空格，然后为我提供的展示图裁剪成标准尺寸。\n\n![image-20220124222739483](https://img.kuizuo.cn/20220124222739.png)\n\n审核人批准了我这两项修改，然后等待系统审核，具体审核的图我当时没截，现在没显示了，把已提交后的代码重新部署到 preview(预览)下，整个过程大约 5 分钟这样，接着审核人对我回复了一句 Great site, thanks! (很好的网站,谢谢)，然后这个 PR 状态就变成了 merged(合并)状态。\n\n然后我犹豫了几分钟，不知道该怎么回复了，加上我英文表达不行，所以我原本中文是\n\n谢谢,希望 Docusaurus 做的更好,一起努力 用软件翻译后 Thank you, Hope Docusaurus can do better. Let's go\n\n![image-20220124222926032](https://img.kuizuo.cn/20220124222926.png)\n\n虽然才过去两个小时，但是我现在回想起来都感觉贼丢人。\n\n首先，我这个回复不是指定为他回复，而是相当于全体评论，贼不礼貌，然后这个蹩脚的英文翻译，我真像把 Let‘s go 改成 Let's work together，就算改了，感觉这个回复也太不礼貌了，这就已经不是英文表达能力，而是中文的表达能力了。\n\n总之最后的结果是好的，我提交的 PR 已经成功合并到了 main 分支上，并且在下一个发布的版本中，案例展示中将会有我的博客显示在上面，现在访问[preview 网站](https://deploy-preview-6458--docusaurus-2.netlify.app/showcase/?name=kuizuo)，搜索 kuizuo 也能看到（B 格瞬间就上来了）\n\n![image-20220124223506489](https://img.kuizuo.cn/20220124223506.png)\n\n## 事后思考\n\n整个过程下来，审核员给我的印象太好了，我这小白式的 PR，现在回看下来都感觉太丢人了。然后我一看审核员的[Github 账号](https://github.com/Josh-Cena)，好家伙，竟然是一名在中国上海的高中生！还是团队的核心人员！太牛了！\n\n![image-20220124225625869](https://img.kuizuo.cn/20220124225625.png)\n\n![image-20220124225830338](https://img.kuizuo.cn/20220124225830.png)\n\n![image-20220124231207662](https://img.kuizuo.cn/20220124231207.png)\n\n很难想象的到一位高中生竟能为默默的为开源项目做出贡献，而我的这次 PR 能提交成功，也与这位热心的国内学生有很大关系。（再次对我一开始报着尝试提交 PR 的态度表示抱歉）\n\n但又回到我这边，这次提交 PR 的经过也让我学到了很多，commit 时一定要仔细对比更改前后的代码，提交的 commit 标题的规范，不必要的 closed，以及最重要的开源精神，让我看到一个实实在在开源者的样子，也是我梦寐以求的样子。\n\n最后也祝 Docusaurus 能越做越好，也感谢这些默默为开源做出贡献的人们，正因为有你们世界才会变得更好。"
    },
    {
      "id": "js-binary-data",
      "metadata": {
        "permalink": "/js-binary-data",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/JavaScript中的二进制数据.md",
        "source": "@site/blog/develop/JavaScript中的二进制数据.md",
        "title": "JavaScript中的二进制数据",
        "description": "在我编写 js 代码中，关于处理二进制数据了解甚少，好像都是用数组表示，但是成员又很模糊。尤其是在遇到一些 http 的 post 请求或 websocket，发送二进制数据（字节）时，还有一些算法的翻译，数据的转化，协议的复现，都需要不断的从网络上查阅，并未系统的从文档教程中入手。于是写这篇的目的就是为了加固对二进制数据的理解，以及 JavaScript 中如何操作二进制数据的。",
        "date": "2022-01-24T00:00:00.000Z",
        "formattedDate": "2022年1月24日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          }
        ],
        "readingTime": 5.923333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "js-binary-data",
          "title": "JavaScript中的二进制数据",
          "date": "2022-01-24T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript"
          ],
          "keywords": [
            "javascript"
          ]
        },
        "prevItem": {
          "title": "记一次Github提交PR过程",
          "permalink": "/github-pr-experience"
        },
        "nextItem": {
          "title": "Docusaurus配置Gitalk评论插件",
          "permalink": "/docusaurus-gitalk-plugin"
        }
      },
      "content": "在我编写 js 代码中，关于处理二进制数据了解甚少，好像都是用数组表示，但是成员又很模糊。尤其是在遇到一些 http 的 post 请求或 websocket，发送二进制数据（字节）时，还有一些算法的翻译，数据的转化，协议的复现，都需要不断的从网络上查阅，并未系统的从文档教程中入手。于是写这篇的目的就是为了加固对二进制数据的理解，以及 JavaScript 中如何操作二进制数据的。\n\n<!-- truncate -->\n\n## ArrayBuffer\n\n其他语言 java，易所表示的是字节数组，字节集，而在 js 中则称二进制数组（都是用来表示二进制数据的），要注意的是这里的二进制数组并不是真正的数组，而是类似数组的对象。（后文会提到）\n\n存储二进制数据用到的就是`ArrayBuffer`，但 `ArrayBuffer`不能直接读写，只能存储，需要通过视图来进行操作。\n\n例如存储二进制数据的则是 ArrayBuffer 对象，例如请求图片时，就会指定参数 `responseType: 'arraybuffer'`表示返回二进制数据，也就是图片数据。\n\n`ArrayBuffer`也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```javascript\nconst buffer = new ArrayBuffer(8)\n```\n\n```javascript\nArrayBuffer {\n  [Uint8Contents]: <00 00 00 00 00 00 00 00>,\n  byteLength: 8\n}\n```\n\n这里的 buffer.byteLength 属性用于获取字节长度（返回 32），直接打印 buf 的结果\n\n其中还有一个`slice`方法，允许将内存区域的一部分，拷贝生成一个新的`ArrayBuffer`对象。下面代码拷贝`buffer`对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束）\n\n```javascript\nconst buffer = new ArrayBuffer(8)\nconst newBuffer = buffer.slice(0, 3)\n```\n\n除了`slice`方法，`ArrayBuffer`对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\n## TypedArray\n\n不过只有空数据可没用，肯定需要操作`ArrayBuffer`，也就要介绍下`TypedArray`。\n\n`ArrayBuffer`对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view），`ArrayBuffer`有两种视图，一种是`TypedArray`视图，另一种是`DataView`视图。这里只介绍`TypedArray`\n\n`TypedArray`视图一共包括 9 种类型，每一种视图都是一种构造函数通过 9 个构造函数，可以生成 9 种数据格式的视图，比如`Uint8Array`（无符号 8 位整数，表示一个字节）数组视图，具体如下\n\n| 数据类型 | 字节长度 | 含义                             | 对应的 C 语言类型 |\n| :------- | :------- | :------------------------------- | :---------------- |\n| Int8     | 1        | 8 位带符号整数                   | signed char       |\n| Uint8    | 1        | 8 位不带符号整数                 | unsigned char     |\n| Uint8C   | 1        | 8 位不带符号整数（自动过滤溢出） | unsigned char     |\n| Int16    | 2        | 16 位带符号整数                  | short             |\n| Uint16   | 2        | 16 位不带符号整数                | unsigned short    |\n| Int32    | 4        | 32 位带符号整数                  | int               |\n| Uint32   | 4        | 32 位不带符号的整数              | unsigned int      |\n| Float32  | 4        | 32 位浮点数                      | float             |\n| Float64  | 8        | 64 位浮点数                      | double            |\n\n视图的构造函数可以接受三个参数：\n\n- 第一个参数（必需）：视图对应的底层`ArrayBuffer`对象。\n- 第二个参数（可选）：视图开始的字节序号，默认从 0 开始。\n- 第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。\n\n演示\n\n不妨给它写入字符串 abc，对应的十进制 ASCII 码为 97,98,99，由于 ASCII 码占用一个字节存储，所以这里选择 Uint8Array 用于表示\n\n```javascript\nconst buffer = new ArrayBuffer(8);\nconst buf = new Uint8Array(buffer);\nbuf.set([97, 98, 99]);\nconsole.log(buf.buffer);\n\n// 输出结果\nArrayBuffer {\n  [Uint8Contents]: <61 62 63 00 00 00 00 00>,\n  byteLength: 8\n}\n```\n\n可以看到 abc 确实存入了，并用十六进制的形式表示，为了验证，这里使用 NodeJS 中的 Buffer 来演示，当然也可以使用原生的[TextEncoder](https://es6.ruanyifeng.com/#docs/arraybuffer#ArrayBuffer-%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2)\n\n```javascript\nBuffer.from(buf.buffer).toString() // abc\n```\n\n你也可以直接通过数组下标的形式，来访问数据，如`buf[0]`返回的就是 97，但 buf 又有 length 与其他的属性方法，这种数组就统称为类数组。\n\nbuf 还有一些方法，无非就是操作字节复制，偏移就不做过多介绍与演示了，具体可查看[文档](https://es6.ruanyifeng.com/#docs/arraybuffer)\n\n## NodeJS 的 Buffer\n\n[buffer 缓冲区 | Node.js API 文档 (nodejs.cn)](http://nodejs.cn/api/buffer.html#buffer_buffers_and_character_encodings)\n\n在 Nodejs 中有专门的操作`ArrayBuffer` 的对象`Buffer`，`Buffer` 类是 JavaScript [`Uint8Array`](http://url.nodejs.cn/ZbDkpm) 类的子类\n\n所以`Uint8Array`有的属性方法 Buffer 也有，不过 Nodejs 对 Buffer 增加了额外的方法供开发者调用。\n\n### [Buffer.from](http://nodejs.cn/api/buffer.html#static-method-bufferfromarray)\n\n上面的代码 `Buffer.from(buf.buffer).toString()`，也就是将`ArrayBuffer` 数据转为 utf8 编码文本。其中 toString 还能转为以下编码（toString 默认 utf8）\n\n```typescript\ntype BufferEncoding = 'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'\n```\n\n不过 Nodejs 不支持 gbk 编码，所以需要使用第三方包，如 iconv-lite\n\n`Buffer.from()`有多个方法实现，第一个参数可以传入 ArrayBuffer | Uint8Array | string，如果是 string 类型，第二个参数为编码格式，例如实现编码转化\n\n```javascript\n// base64\nBuffer.from(str).toString('base64') // 将str转base64编码\nBuffer.from(str, 'base64').toString() // 将base64编码转str\n\n// hex\nBuffer.from(str).toString('hex') // 将str转hex编码\nBuffer.from(str, 'hex').toString() // 将hex编码转str\n```\n\n封装 Base64 编码与解码\n\n```javascript\nconst Base64 = {\n  encode: (str) => {\n    return Buffer.from(str).toString('base64')\n  },\n  decode: (str) => {\n    return Buffer.from(str, 'base64').toString()\n  },\n}\n```\n\n### [buf.toJSON()](http://nodejs.cn/api/buffer.html#buftojson)\n\n将会得到 buf 的视图类型，与二进制数组。\n\n```javascript\n// let buf = Buffer.from('abc');\nlet buf = Buffer.from([97, 98, 99])\nconsole.log(buf) // <Buffer 61 62 63>\n\nbuf.toJSON() // { type: 'Buffer', data: [ 97, 98, 99 ] }\n// 效果等同于 JSON.stringify(buf);\n\nbuf.values() // [ 97, 98, 99 ]   可以直接得到二进制数据\n```\n\n官方文档: [buffer 缓冲区 | Node.js API 文档 (nodejs.cn)](http://nodejs.cn/api/buffer.html#buffer)\n\n## ArrayBuffer 和 Buffer 区别\n\n上述对这两者进行了介绍，这里总结一下\n\n`ArrayBuffer` 对象用来表示通用的、固定长度的原始二进制数据缓冲区，是一个字节数组，可读但不可直接写。\n\n`Buffer` 是 Node.JS 中用于操作 `ArrayBuffer` 的视图，继承自`Uint8Array`，是 `TypedArray` 的一种。\n\n通俗点来说（**对我而言**），`ArrayBuffer`相当于其他语言的字节数组、字节集，但不可写，而`Buffer` 对象则是操作`ArrayBuffer`的。\n\n## 应用\n\n与二进制数据有关的地方就有应用\n\n### 编码转化\n\n### 将请求图片转化成 base64 编码\n\n```javascript\naxios\n  .get('图片url地址', {\n    responseType: 'arraybuffer',\n  })\n  .then((res) => {\n    let base64Img = res.data.toString('base64')\n    console.log(base64Img)\n  })\n```\n\n在 axios 请求图片数据的时候，指定`responseType: 'arraybuffer'`，返回的 data 就是一个 buffer 对象。（当时写成这样的代码 `Buffer.from(res.data).buffer`，不过不妨碍）\n\n### http 发送二进制数据与 WebSocket\n\n```javascript\naxios.post('http://example.com', Buffer.from('abc')).then((res) => {\n  console.log(res.data)\n})\n```\n\n```javascript\nlet socket = new WebSocket('ws://127.0.0.1:8081')\nsocket.binaryType = 'arraybuffer'\n\n// Wait until socket is open\nsocket.addEventListener('open', function (event) {\n  // Send binary data\n  const typedArray = new Uint8Array(4)\n  socket.send(typedArray.buffer)\n})\n\n// Receive binary data\nsocket.addEventListener('message', function (event) {\n  const arrayBuffer = event.data\n  // ···\n})\n```\n\n### 文件读写\n\n等等。。。\n\n## 参考\n\n> [ArrayBuffer - ECMAScript 6 入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/arraybuffer)\n>\n> [ArrayBuffer 和 Buffer 有何区别？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26246195/answer/1231680251#ref_1)"
    },
    {
      "id": "docusaurus-gitalk-plugin",
      "metadata": {
        "permalink": "/docusaurus-gitalk-plugin",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Docusaurus配置Gitalk评论插件.md",
        "source": "@site/blog/program/Docusaurus配置Gitalk评论插件.md",
        "title": "Docusaurus配置Gitalk评论插件",
        "description": "之前使用 vuepress 的时候，使用的评论系统是Valine，可是匿名用户也能直接评论，虽说会过滤垃圾信息，但是后台查看评论与通知总感觉没有那么实在。",
        "date": "2022-01-22T00:00:00.000Z",
        "formattedDate": "2022年1月22日",
        "tags": [
          {
            "label": "blog",
            "permalink": "/tags/blog"
          },
          {
            "label": "docusaurus",
            "permalink": "/tags/docusaurus"
          },
          {
            "label": "gitalk",
            "permalink": "/tags/gitalk"
          }
        ],
        "readingTime": 4.03,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "docusaurus-gitalk-plugin",
          "title": "Docusaurus配置Gitalk评论插件",
          "date": "2022-01-22T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "blog",
            "docusaurus",
            "gitalk"
          ],
          "keywords": [
            "blog",
            "docusaurus",
            "gitalk"
          ]
        },
        "prevItem": {
          "title": "JavaScript中的二进制数据",
          "permalink": "/js-binary-data"
        },
        "nextItem": {
          "title": "SpringBoot热更新",
          "permalink": "/springboot-hot-update"
        }
      },
      "content": "之前使用 vuepress 的时候，使用的评论系统是[Valine](https://valine.js.org/)，可是匿名用户也能直接评论，虽说会过滤垃圾信息，但是后台查看评论与通知总感觉没有那么实在。\n\n然后换到了 docusaurus，并没有内置评论相关的，原本是打算自己写一个评论系统，MongoDB 存储评论数据相对方便些。然后这一拖就是拖到了过年前。。。无意间发现有一个插件[Gitalk](https://gitalk.github.io/)，基于 Github Issue 的，而我平常又经常刷 github，加上需要 github 账号才能评论，所以就使用[Gitalk](https://gitalk.github.io/) 来作为博客的评论（注：Gitalk 是基于 react 编写的）。\n\n<!-- truncate -->\n\n## 操作步骤\n\n### 1、创建评论仓库\n\n首先需要 github 账号，创建一个仓库用于存放评论，由于我的博客是同步上传到[github](https://github.com/kuizuo/blog)上，所以就无需新建仓库\n\n### 2、开启 issues 功能\n\n默认开启，可在 Settings -> Features -> Issues 中设置\n\n![image-20220122141447919](https://img.kuizuo.cn/20220122141447.png)\n\n### 3、注册一个 Github applications\n\n点击[此处](https://github.com/settings/developers)创建或在 github 右上角路径 settings -> Developer settings -> OAuth Apps\n\n![image-20220121225059192](https://img.kuizuo.cn/20220121225106.png)\n\n- Homepage URL：就是博客的网址（如果是 github.io 的 page）\n- Authorization callback URL: 就是 github 权限验证的回调地址，一般默认就是域名\n\n### 4、获取 Client ID 和 Client Secret\n\n创建成功后，就可以获取到 Client ID 和 Client Secret 了，保存下来。\n\n![image-20220122130221871](https://img.kuizuo.cn/20220122130222.png)\n\n### 5、安装\n\n[官方教程](https://github.com/gitalk/gitalk/blob/master/readme-cn.md#安装)\n\n- 直接引入\n\n```html\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\" />\n<script src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"></script>\n\n<!-- or -->\n\n<link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\" />\n<script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"></script>\n```\n\n- npm 安装\n\n```sh\nnpm i --save gitalk\n```\n\n```javascript\nimport 'gitalk/dist/gitalk.css'\nimport Gitalk from 'gitalk'\n```\n\n### 6、使用\n\n```html\n<div id=\"gitalk-container\"></div>\n```\n\n用下面的 Javascript 代码来生成 gitalk 插件：\n\n```javascript\nconst gitalk = new Gitalk({\n  clientID: 'GitHub Application Client ID',\n  clientSecret: 'GitHub Application Client Secret',\n  repo: 'GitHub repo',\n  owner: 'GitHub repo owner',\n  admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],\n  id: location.pathname, // Ensure uniqueness and length less than 50\n  distractionFreeMode: false, // Facebook-like distraction free mode\n})\n\ngitalk.render('gitalk-container')\n```\n\n##### react 中使用\n\n导入 Gitalk 组件与样式\n\n```jsx\nimport 'gitalk/dist/gitalk.css'\nimport GitalkComponent from 'gitalk/dist/gitalk-component'\n```\n\n使用组件与配置参数\n\n```jsx\n<GitalkComponent\n  options={{\n    clientID: '...',\n    // ...\n    // options below\n  }}\n/>\n```\n\n我的配置\n\n```javascript\nconst options = {\n  clientID: 'GitHub Application Client ID',\n  clientSecret: 'GitHub Application Client Secret',\n  repo: 'blog',\n  owner: 'kuizuo',\n  admin: ['kuizuo'],\n  id: title,\n  title: title,\n  labels: labels,\n  distractionFreeMode: false,\n}\n```\n\n具体参数[gitalk](https://github.com/gitalk/gitalk/blob/master/readme-cn.md#设置)\n\n## 问题\n\n### Error: Not Found\n\noptions 有个选项 repo，填写的是仓库名称，不是链接，像上面我所填写的就是`blog`，而不是填写https://github.com/kuizuo/blog\n\n### 未找到相关的 [Issues](https://github.com/kuizuo/blog/issues) 进行评论，请联系 @xxxxx 初始化创建\n\n这里的 xxxxx 就是选项 admin 的内容，首次载入文章的话需要用管理员账号登录初始化一下（也就是新建一个 issues），否则其他人访问也将会提示该信息。\n\n目前暂时没找到有效办法一键加载所有博客的 issues，只要用登录 github 的管理员账号去访问每一篇博客。\n\n其中在[第 3 步](#3注册一个-github-applications)的 Authorization callback URL 地址一定要填写成现在博客线上环境 https://kuizuo.cn ，否则也无法正常使用\n\n### Validation failed\n\n原因是 id 参数不能超过 50 个字符，但是默认是 location.href，有可能会导致长度超过。所以我的做法是 id: title，同时访问页面的时候，会自动为仓库创建一个 issue，标题为文章的标题。\n\n也有可能是请求过于频繁，触发了 Github 的限流机制，需要等待几分钟后恢复。\n\n### react 编译遇到的问题\n\n插件中会使用到浏览器的 window 对象，开发时正常，但是编译就会报错（提示 window is not defined），这边引用了 docusaurus 的[BrowserOnly](https://docusaurus.io/zh-CN/docs/docusaurus-core#browseronly)，将代码封装成如下便可正常编译\n\n```jsx\n<BrowserOnly fallback={<div></div>}>{() => <GitalkComponent options={options} />}</BrowserOnly>\n```\n\n[查看完整源码点我](https://github.com/kuizuo/blog/blob/main/src/theme/BlogPostPage/index.jsx)\n\n## Github Api\n\n[GitHub Documentation](https://docs.github.com/cn)\n\n通过 github api 还可以获取 issues 列表\n\n访问 https://api.github.com/repos/kuizuo/blog/issues，返回结果如下\n\n```json\n[\n  {\n    \"url\": \"https://api.github.com/repos/kuizuo/blog/issues/24\",\n    \"repository_url\": \"https://api.github.com/repos/kuizuo/blog\",\n    \"labels_url\": \"https://api.github.com/repos/kuizuo/blog/issues/24/labels{/name}\",\n    \"comments_url\": \"https://api.github.com/repos/kuizuo/blog/issues/24/comments\",\n    \"events_url\": \"https://api.github.com/repos/kuizuo/blog/issues/24/events\",\n    \"html_url\": \"https://github.com/kuizuo/blog/issues/24\",\n    \"id\": 1111300101,\n    \"node_id\": \"I_kwDOF7NJDM5CPRgF\",\n    \"number\": 24,\n    \"title\": \"Docusaurus配置Gitalk评论插件\",\n    \"user\": {\n      \"login\": \"kuizuo\",\n      \"id\": 61005888,\n      \"node_id\": \"MDQ6VXNlcjYxMDA1ODg4\",\n      \"avatar_url\": \"https://avatars.githubusercontent.com/u/61005888?v=4\",\n      \"gravatar_id\": \"\",\n      \"url\": \"https://api.github.com/users/kuizuo\",\n      \"html_url\": \"https://github.com/kuizuo\",\n      \"followers_url\": \"https://api.github.com/users/kuizuo/followers\",\n      \"following_url\": \"https://api.github.com/users/kuizuo/following{/other_user}\",\n      \"gists_url\": \"https://api.github.com/users/kuizuo/gists{/gist_id}\",\n      \"starred_url\": \"https://api.github.com/users/kuizuo/starred{/owner}{/repo}\",\n      \"subscriptions_url\": \"https://api.github.com/users/kuizuo/subscriptions\",\n      \"organizations_url\": \"https://api.github.com/users/kuizuo/orgs\",\n      \"repos_url\": \"https://api.github.com/users/kuizuo/repos\",\n      \"events_url\": \"https://api.github.com/users/kuizuo/events{/privacy}\",\n      \"received_events_url\": \"https://api.github.com/users/kuizuo/received_events\",\n      \"type\": \"User\",\n      \"site_admin\": false\n    },\n    \"labels\": [\n      {\n        \"id\": 3754161267,\n        \"node_id\": \"LA_kwDOF7NJDM7fw_Rz\",\n        \"url\": \"https://api.github.com/repos/kuizuo/blog/labels/Gitalk\",\n        \"name\": \"Gitalk\",\n        \"color\": \"ededed\",\n        \"default\": false,\n        \"description\": null\n      },\n      {\n        \"id\": 3754411279,\n        \"node_id\": \"LA_kwDOF7NJDM7fx8UP\",\n        \"url\": \"https://api.github.com/repos/kuizuo/blog/labels/blog\",\n        \"name\": \"blog\",\n        \"color\": \"ededed\",\n        \"default\": false,\n        \"description\": null\n      },\n      {\n        \"id\": 3754517867,\n        \"node_id\": \"LA_kwDOF7NJDM7fyWVr\",\n        \"url\": \"https://api.github.com/repos/kuizuo/blog/labels/Docusaurus%E9%85%8D%E7%BD%AEGitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6\",\n        \"name\": \"Docusaurus配置Gitalk评论插件\",\n        \"color\": \"ededed\",\n        \"default\": false,\n        \"description\": null\n      }\n    ],\n    \"state\": \"open\",\n    \"locked\": false,\n    \"assignee\": null,\n    \"assignees\": [],\n    \"milestone\": null,\n    \"comments\": 0,\n    \"created_at\": \"2022-01-22T06:47:34Z\",\n    \"updated_at\": \"2022-01-22T06:47:34Z\",\n    \"closed_at\": null,\n    \"author_association\": \"OWNER\",\n    \"active_lock_reason\": null,\n    \"body\": \"https://kuizuo.cn/develop/Docusaurus配置Gitalk评论插件\\n前言\",\n    \"reactions\": {\n      \"url\": \"https://api.github.com/repos/kuizuo/blog/issues/24/reactions\",\n      \"total_count\": 0,\n      \"+1\": 0,\n      \"-1\": 0,\n      \"laugh\": 0,\n      \"hooray\": 0,\n      \"confused\": 0,\n      \"heart\": 0,\n      \"rocket\": 0,\n      \"eyes\": 0\n    },\n    \"timeline_url\": \"https://api.github.com/repos/kuizuo/blog/issues/24/timeline\",\n    \"performed_via_github_app\": null\n  }\n]\n```\n\n相关 api 文档 => [github docs](https://docs.github.com/cn/rest/reference/issues#comments)\n\n也许后续可能考虑使用[octokit.js](https://github.com/octokit/octokit.js)来编写一个后台查询与删除的管理页。\n\n## 最终效果\n\n#### 评论页\n\n![image-20220122164034147](https://img.kuizuo.cn/20220122164034.png)\n\n#### issues 页面\n\n![image-20220122163957435](https://img.kuizuo.cn/20220122163957.png)"
    },
    {
      "id": "springboot-hot-update",
      "metadata": {
        "permalink": "/springboot-hot-update",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/SpringBoot热更新.md",
        "source": "@site/blog/develop/SpringBoot热更新.md",
        "title": "SpringBoot热更新",
        "description": "步骤一",
        "date": "2022-01-10T00:00:00.000Z",
        "formattedDate": "2022年1月10日",
        "tags": [
          {
            "label": "java",
            "permalink": "/tags/java"
          },
          {
            "label": "springboot",
            "permalink": "/tags/springboot"
          }
        ],
        "readingTime": 0.45666666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "springboot-hot-update",
          "title": "SpringBoot热更新",
          "date": "2022-01-10T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "java",
            "springboot"
          ],
          "keywords": [
            "java",
            "springboot"
          ]
        },
        "prevItem": {
          "title": "Docusaurus配置Gitalk评论插件",
          "permalink": "/docusaurus-gitalk-plugin"
        },
        "nextItem": {
          "title": "为什么使用pnpm",
          "permalink": "/why-use-pnpm"
        }
      },
      "content": "<!-- truncate -->\n\n## 步骤一\n\npom.xml 中在加入依赖\n\n```xml\n<dependency>\n \t<groupId>org.springframework.boot</groupId>\n \t<artifactId>spring-boot-devtools</artifactId>\n \t<optional>true</optional>\n\t<scope>true</scope>\n</dependency>\n```\n\n然后再`<build>`下添加如下依赖。\n\n```xml\n<build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <fork>true</fork>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n## 步骤二\n\n（1）打开设置勾选自动构建项目\n\n![image-20220506130419248](https://img.kuizuo.cn/image-20220506130419248.png)\n\n（2）高级设置中勾选自动 make，老版 IDEA 需要`ctrl + shift + alt + /`，选择注册表，勾上 Compiler autoMake allow when app running，但新版中移到高级设置中。\n\n![image-20220506130533312](https://img.kuizuo.cn/image-20220506130533312.png)\n\n接着启动项目，修改文件即可自动热加载，无需手动重新运行。"
    },
    {
      "id": "why-use-pnpm",
      "metadata": {
        "permalink": "/why-use-pnpm",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/为什么使用pnpm.md",
        "source": "@site/blog/advice/为什么使用pnpm.md",
        "title": "为什么使用pnpm",
        "description": "pnpm 文档",
        "date": "2022-01-08T00:00:00.000Z",
        "formattedDate": "2022年1月8日",
        "tags": [
          {
            "label": "node",
            "permalink": "/tags/node"
          },
          {
            "label": "pnpm",
            "permalink": "/tags/pnpm"
          }
        ],
        "readingTime": 2.78,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "why-use-pnpm",
          "title": "为什么使用pnpm",
          "date": "2022-01-08T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "node",
            "pnpm"
          ],
          "keywords": [
            "node",
            "pnpm"
          ]
        },
        "prevItem": {
          "title": "SpringBoot热更新",
          "permalink": "/springboot-hot-update"
        },
        "nextItem": {
          "title": "SpringBoot项目结构",
          "permalink": "/springboot-project-structure"
        }
      },
      "content": "<!-- truncate -->\n\n[pnpm 文档](https://pnpm.io/zh/)\n\n## 前言\n\n在一个 node 项目中免不了 node_modules 依赖，假设项目 A 用的了 Express 依赖，同时项目 B 也用到了 Express，并且两者所存放的位置不同，那么磁盘空间将会多出两份 Express 依赖，假设有 100 个项目，那么将会有有 100 倍的空间被浪费。这些空间还可以用磁盘空间来弥补，但是这 100 个项目如果都使用 npm i 去下载同样版本依赖，则是实实在在耗费网络资源去下载。\n\npnpm 能解决以下两点问题\n\n- 包安装速度极快；\n- 磁盘空间利用非常高效。\n\n而这些问题是一个 node 项目中常有的。相信此时的你都有点蠢蠢欲动了，而安装也很简单\n\n## 安装\n\n请查阅你的 node 版本与 pnpm 是否匹配 [安装 | pnpm](https://pnpm.io/zh/installation#兼容性)\n\n```\nnpm install -g pnpm\n```\n\n### 升级\n\n```\npnpm add -g pnpm\n```\n\n此时 pnpm 就已经安装完了，与 yarn 安装一样，都感觉没安装似的。\n\n## 使用\n\npnpm 命令几乎与 npm 一样，设置配置的方式也与 npm 相同，这里不妨尝试通过 pnpm 去下载 express 依赖，打开 CMD，将路径改成你平时写 js 代码的地方，切记不要在 C 盘路径下，不然将会在`C:\\Users\\{userDir}\\.pnpm-store\\v3`去管理你的所有依赖，至于为什么后文会说，这里选择 F 盘进行安装，安装结果如下。\n\n![image-20220108040813223](https://img.kuizuo.cn/20220108040813.png)\n\n不难看出，它将依赖存放至**`F:\\.pnpm-store\\v3`**下，但此时查看项目目录的 node_modules 文件夹\n\n![image-20220108041030618](https://img.kuizuo.cn/20220108041030.png)\n\n发现`express`与`mime-types`的右侧带了回车符，而这两个文件夹实际上是 window 的硬链接，而读取的就是存放在`F:\\.pnpm-store\\v3`下的依赖。虽然查看 node_modules 属性会发现显示的空间貌似和原始的链接所占用的空间一样，但其实是同一个位置，官方中常用问题中也有介绍到 [常见问题 | pnpm](https://pnpm.io/zh/faq#如果包存储在全局存储中为什么我的-node_modules-使用了磁盘空间)，所以真不用担心磁盘空间的问题。\n\n这时候去查看 `F:\\.pnpm-store\\v3\\files` 会发现都是一堆数字与字母命名的文件夹，而依赖都存放至这些杂乱无章的文件名之中。同时.pnpm-store 是根据你所在驱动器（这里是 F 盘）下创建的，可以通过 `pnpm store path`查看，也就是上文为什么说不要在 C 盘路径（包括桌面）去安装依赖了，所以不用担心 C 盘空间会越来越小（如果你的代码是在 C 盘编写的话，那当我没说）。\n\n## 最后\n\n不过还是要提醒一句，即便 pnpm 能解决磁盘问题，但还是存在一定的兼容性，如果一个项目是用 npm 或者 yarn 进行构建的，使用 pnpm 是绝对免不了一些问题，小问题暂时想不到，大问题无法运行，所以请三思再考虑对已有项目是否尝试升级 pnpm。\n\n但我认为还是有必要尝试尝试下，不尝试，怎么能发现新大陆呢。\n\n> 参考链接：[关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn? - 掘金 (juejin.cn)](https://juejin.cn/post/6932046455733485575#heading-14)"
    },
    {
      "id": "springboot-project-structure",
      "metadata": {
        "permalink": "/springboot-project-structure",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/SpringBoot项目结构.md",
        "source": "@site/blog/program/SpringBoot项目结构.md",
        "title": "SpringBoot项目结构",
        "description": "演示代码地址：kuizuo/spring-boot-demo (github.com)",
        "date": "2022-01-08T00:00:00.000Z",
        "formattedDate": "2022年1月8日",
        "tags": [
          {
            "label": "java",
            "permalink": "/tags/java"
          },
          {
            "label": "springboot",
            "permalink": "/tags/springboot"
          },
          {
            "label": "develop",
            "permalink": "/tags/develop"
          }
        ],
        "readingTime": 4.88,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "springboot-project-structure",
          "title": "SpringBoot项目结构",
          "date": "2022-01-08T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "java",
            "springboot",
            "develop"
          ],
          "keywords": [
            "java",
            "springboot",
            "develop"
          ]
        },
        "prevItem": {
          "title": "为什么使用pnpm",
          "permalink": "/why-use-pnpm"
        },
        "nextItem": {
          "title": "为何我选择日夜颠倒敲代码",
          "permalink": "/why-i-turn-night-into-day-to-code"
        }
      },
      "content": "<!-- truncate -->\n\n演示代码地址：[kuizuo/spring-boot-demo (github.com)](https://github.com/kuizuo/spring-boot-demo)\n\n## 目录结构展示图\n\n![](https://img.kuizuo.cn/20220108011921.png)\n\n### controller\n\ncontroller 目录下对应的也就是控制器，用于接收用户的请求（get，post 等），如下面代码\n\n```java title=\"controller/UserController.java\"\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    @GetMapping(\"list\")\n    public List<User> list() {\n        return userService.findAll();\n    }\n}\n```\n\n用户请求[http://127.0.0.1:8080/user/list](http://127.0.0.1:8080/users/list) 将会调用 userService.findAll 方法，当然这个方法事先定义好，用于获取所有用户。\n\n### model（service）\n\n这里数据库连接方式以 JPA（一个 ORM 框架）为例，可以安装一个 IDEA 插件 JPA Buddy 新建文件时可以直接创建 Entity(实体)或 Repository(仓库)\n\n![image-20220506115207717](https://img.kuizuo.cn/image-20220506115207717.png)\n\n#### entity 类\n\n在 domain 目录下创建实体类，大致如下（lombok 因人而异选择使用，相对不展示 get 与 set 会好一些）\n\n```java title=\"domain/User.java\"\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport javax.persistence.*;\n\n@Entity\n@Getter\n@Setter\n@Table(name = \"user\")\npublic class User implements Serializable {\n    @Id\n    @GeneratedValue\n    @ApiModelProperty(value = \"ID\", hidden = true)\n    private Long id;\n\n    @Column(nullable = false, unique = true)\n    private String username;\n    @Column(nullable = false)\n    private String password;\n    @Column(nullable = false)\n    private String email;\n}\n```\n\nUser.java 用于定义 user 实体，在 ORM 中，数据库表中的字段都可以通过实体类中的属性来定义的，如果定义好 user 实体，并且在 resources/application.yml 中设置了`spring.jpa.hibernate.ddl-auto: update` 那么启动项目后，数据库将会自动创建 user 表且其表中字段自动为`@Column`注解的字段。\n\n#### repository 类\n\n创建完实体后，还需要定义数据接口访问层 DAO，在 JPA 中则是在 repository 目录下创建。\n\n```java title=\"repository/UserRepository.java\"\npublic interface UserRepository extends JpaRepository<User, Long> , JpaSpecificationExecutor<User> {\n    User findByUsername(String username);\n}\n```\n\n一般情况下该接口无需定义额外方法，如有需要还可以定义属于自己的查询语句，比如上面的 findByUsername，这时候就注入后的 userRepository 对象就可以使用`userRepository.findByUsername(\"kuizuo\");` ，将会返回数据库中该用户名的数据。\n\n#### UserService 类\n\n```java title=\"service/UserService.java\"\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public List<User> findAll(){\n        return userRepository.findAll();\n    }\n}\n```\n\n**@Autowired 可能不建议使用字段注入**，可以在类添加@RequiredArgsConstructor 注解，表明 userRepository 不为空，总之目的就是将 userRepository 注入，供服务可用。\n\n```java title=\"service/UserService.java\"\nimport com.kuizuo.demo.domain.User;\nimport com.kuizuo.demo.repository.UserRepository;\nimport com.kuizuo.demo.service.UserService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\n@RequiredArgsConstructor\npublic class UserService {\n    private final UserRepository userRepository;\n\n    @Override\n    public List<User> findAll() {\n        return userRepository.findAll();\n    }\n}\n```\n\n接着就可以使用 userRepository 下的方法，如 `userRepository.findAll`命令相当于 `select * from user`，返回所有的用户列表。\n\n#### service 接口实现\n\n此外 service 服务还可以有另一种写法，在 service 中添加一个 impl 目录，通过对 userService **接口**进行实现的服务。\n在上面所写的 UserService 是一个类，这边将其改为一个接口，代码如下\n\n```java title=\"service/UserService.java\"\npublic interface UserService {\n    List<User> findAll();\n    User findOne(Long id);\n}\n```\n\n同时只保留 UserService 所要提供的方法，然后在 service/impl 中创建文件 UserServiceImpl.java，具体代码如下\n\n```java title=\"service/impl/UserServiceImpl.java\"\n@Service\n@RequiredArgsConstructor\npublic class UserServiceImpl implements UserService {\n    private final UserRepository userRepository;\n\n    @Override\n    public List<User> findAll() {\n        return userRepository.findAll();\n    }\n\n\n    @Override\n    public User findOne(Long id) {\n        return userRepository.findById(id).orElseThrow(() -> new BadRequestException(\"用户不存在\"));\n    }\n}\n```\n\n调用并无差异，对 service 进一步的封装，相对更规范些（我看外面都这么写的，所以就这么写了）。\n\n#### 数据接口\n\n[POJO、PO、DTO、DAO、BO、VO 需要搞清楚的概念](https://developer.aliyun.com/article/694418)\n此外还可能对不同层的数据进行命令\n\n- 数据实体(entity)类`PO` ：\n  - jpa 项目: domain 目录\n  - mybatis 项目: entity 目录\n- 数据接口访问层`DAO`：\n  - jpa 项目： repository 目录\n  - mybatis 项目： mapper 目录\n- 数据传输对象`DTO`：dto 目录\n- 视图对象`VO`：vo 目录\n\n其中前两种在上文中 jpa 的例子中已经介绍了，简单介绍下后两者\n\n`DTO` 经过处理后的 PO，在传输数据对象中可能增加或者减少 PO 的属性\n\n`VO` 在控制层与视图层进行传输交换\n\n对于后两者而言，可能还需要提供 Mapper 类用于数据转化，如 DTO 转 PO，PO 转 DTO。\n\n##### modelMapper\n\n```xml\n<dependency>\n    <groupId>org.modelmapper</groupId>\n    <artifactId>modelmapper</artifactId>\n    <version>2.3.5</version>\n</dependency>\n```\n\n同时在启动类下配置为一个 Bean 才能被注入使用\n\n```java\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n    @Bean\n    public ModelMapper modelMapper() {\n        return new ModelMapper();\n    }\n}\n\n```\n\n##### po 与 dto 转化\n\n还是上面那个 user 实体，但是返回的数据中不需要将 user 的 password 展示出来。在 service/dto 中创建一个 UserDTO\n\n```java title=\"service/dto/UserDto.java\"\n@Getter\n@Setter\npublic class UserDto {\n    private Long id;\n    private String username;\n    private String email;\n}\n```\n\n如果要转化，通常要一个个字段转化，如下\n\n```java {5-8}\n    @Override\n    public UserDto findOne(Long id) {\n        User user =  userRepository.findById(id).orElseThrow(() -> new BadRequestException(\"用户不存在\"));\n\n        UserDto userDto = new UserDto();\n        userDto.setId(user.getId());\n        userDto.setUsername(user.getUsername());\n        userDto.setEmail(user.getEmail());\n        return userDto;\n    }\n```\n\n结果肯定是没问题的，但是代码写的很丑陋且不易于维护。就可以使用 modelMapper 来转化（前提已经注入）\n\n```java {5}\n    private final ModelMapper modelMapper;\n\n\t@Override\n    public UserDto findOne(Long id) {\n        User user =  userRepository.findById(id).orElseThrow(() -> new BadRequestException(\"用户不存在\"));\n\n        UserDto userDto = modelMapper.map(user, UserDto.class);\n        return userDto;\n    }\n```\n\n不过这样使用可能还是不大规范，同时还需要手动传入对象及其 Class 对象。所以可能还会创建 service/mapstruct，然后创建 UserMapper，这里就不举例了。\n\n### view\n\n此外还有个文件 resources/templates/user.html 用于返回页面，不过这些都属于模板语言的内容，就不细说了（针对前后端分离的项目而言，后端主要提供数据便可）\n\n### 整体流程\n\n大致的流程便可总结为 Controller 接收请求 → 调用 service 服务 → 调用数据接口服务 dao 提供数据 → 将数据(页面)返回给用户\n\n**此外，该目录结构仅仅本人所选用的 springboot 项目结构，实际情况还需额外考虑。**\n\n## 总结\n\n回到开头，其中提供业务服务（数据）的也就是 service 所做的事情，控制接口的则是 controller，还有一个视图层 view 介绍的比较少（反正就是返回数据或页面）。其中最为复杂的也就是 service 所提供的服务，相对 controller 和 view 而言会繁琐许多。"
    },
    {
      "id": "why-i-turn-night-into-day-to-code",
      "metadata": {
        "permalink": "/why-i-turn-night-into-day-to-code",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/lifestyle/为何我选择日夜颠倒敲代码.md",
        "source": "@site/blog/lifestyle/为何我选择日夜颠倒敲代码.md",
        "title": "为何我选择日夜颠倒敲代码",
        "description": "上图是我的睡眠周期，你可以发现每日的时间都在不断延后，意味着我熬的夜越来越长，甚至达到了颠倒生物钟的程度。",
        "date": "2022-01-03T00:00:00.000Z",
        "formattedDate": "2022年1月3日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "杂谈",
            "permalink": "/tags/杂谈"
          }
        ],
        "readingTime": 4.74,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "why-i-turn-night-into-day-to-code",
          "title": "为何我选择日夜颠倒敲代码",
          "date": "2022-01-03T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "杂谈"
          ],
          "keywords": [
            "随笔",
            "杂谈"
          ]
        },
        "prevItem": {
          "title": "SpringBoot项目结构",
          "permalink": "/springboot-project-structure"
        },
        "nextItem": {
          "title": "2021年终总结（休学一年）",
          "permalink": "/2021-year-end-summary"
        }
      },
      "content": "![](https://img.kuizuo.cn/20230308001404.png)\n\n上图是我的睡眠周期，你可以发现每日的时间都在不断延后，意味着我熬的夜越来越长，甚至达到了颠倒生物钟的程度。\n\n其实我很早就想写这个话题了。因为我是一个熬夜大户，经常动不动就是 3,4 点睡觉，甚至有时候是日夜颠倒的作息习惯，如同过美国时间般，在 0 点到 6 点这时间段几乎是我的 coding time。但与常人想法不同，我巴不得在保持这种作息状态。我会分以下几点来阐述我这一不正常的行为，相对于我而言的好点。\n\n<!-- truncate -->\n\n## 对我而言的好处\n\n### 安静\n\n夜生活过的人应该最清楚了，那种静可以算上是幽静了，加上黑夜的承托与屏幕前的微光，如果恰好此时耳机还播放着音乐，好了，直接进入自我境界。\n\n这种安静与图书馆的安静是根本无法相比的，图书馆可能还有走动声，而凌晨你唯独只能听见自己的脚步声（不排除有上厕所的室友，有时候可能被其吓得一跳），最主要还是黑，你的视野中除了屏幕的信息外几乎很难有其他东西去干涉你。\n\n你问我用的什么键盘？程序员不都用静电容的键盘吗？机械键盘的声音在晚上敲怕不是给室友去世器。(tips: 室友包括我)\n\n### 琐事\n\n安静也许远远还不够，想要达到与世隔绝的地步，在互联网这个时间段最简单的办法就是断网。如果事情都与你毫不相干，那也差不多已经与这个世界说拜拜了，但在白天你还是有一定的存在感，会有一些莫名的琐事干涉你当前正在进行的状态。\n\n我就说一个最简单的例子，假如你正在编写一个功能的时候，此时手机正好弹出一条信息（通常为广告），此时大多数人基本上就去看手机去了，意志力好一点的可能看完直接回到手头的任务上，差一点的可能就是几十分钟的短视频，也许很夸张，但确实如此。\n\n所以我一般都会在 0~6 点开启勿扰模式（睡眠模式），但在白天却又不能错过很多重要的信息。\n\n### 思考\n\n可能对我而言，灵感通常是在睡前（准确说是夜深时）产生的，同时脑子里想的东西也会比白天而言多，想的多自然写的东西也就多，所以也就是我为什么很多代码 Commit 与博客编写时间都是在 0~6 点这个时间，就连这篇文章也都是在夜间写的，白天实在是想不出什么点来写。\n\n也许与静也有相关，白天普遍嘈杂的声音，说实话很难让人能静下来去冥想，但在夜晚，静确实它唯一的资本。\n\n**唯有夜深人静，才有自我深思。**\n\n### 工作效率\n\n在我亲身体验下来，可以毫不夸张的说，我在夜晚的工作效率可以是白天的 3，4 倍，没错就是这么恐怖。\n\n至于原因，大概率（99%）是由上面几点导致的，所以也就是为什么我巴不得在夜深人静的时候开始 doing，导致这异于常人的作息规律。尤其在夜晚，是很难感受到时间的存在，有时候可能天亮了才知道。这时才发觉自己又熬了一个晚上。\n\n但回想 1 小时抵 3 小时，怎么想都是赚，换做你，会考虑这样的作息吗？\n\n## 对我而言的坏处\n\n不过导致这种规律的原因，与当天任务未完成，要到凌晨加班加点完成。或者是一时上头，忘记了时间的存在，手头的任务打消了睡意。久而久之，作息时间点不断延后，就导致现在现在的生物钟。\n\n其实坏处都不用写，是个正常作息的一眼就能看出来，我也不细说了。\n\n但往往事与愿违，上面的这种作息行为都有点压榨白天的时间，因为白天总要上学，上班，周末又不可能一次性就调整成这样的作息，所以我这种情况一般也都发生在长假期，例如寒暑假（包括这次的寒假）。但其实日常生活中大多时间还都是夜间做事，只是假期的夜间时间相对延后那么亿点。\n\n<font size=\"1\">与好处相比，除了猝死其他都还能接受。</font>\n\n## 总结\n\n原本标题我是起为什么喜欢熬夜，但后来我并不认为我是在熬夜，只是时间相对错乱，每天睡觉的时间与正常作息并没有差别，唯一的差别估计就是天亮了我睡了，天暗了我醒了。主要还是强调作息，所以便有了这个标题。\n\n当然我写这篇文章也不是想要倡导夜间做事有多好，每个人都有属于自己适应的时间段，比方说有些人就喜欢早晨背单词，而有些选择在睡前，道理都是同样的。我只是觉得我这种习惯比较异类，也许也有人的作息习惯和我臭味相投。\n\n:::danger  \n\n⚠️ 非专业人士，请勿模仿！ \n\n:::"
    },
    {
      "id": "2021-year-end-summary",
      "metadata": {
        "permalink": "/2021-year-end-summary",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/reference/2021年终总结（休学一年）.md",
        "source": "@site/blog/reference/2021年终总结（休学一年）.md",
        "title": "2021年终总结（休学一年）",
        "description": "距离上篇记录过去了 1 年半时间，以后应该也会在每年的 12 月 31 号发布年终总结。",
        "date": "2021-12-31T00:00:00.000Z",
        "formattedDate": "2021年12月31日",
        "tags": [
          {
            "label": "年终总结",
            "permalink": "/tags/年终总结"
          },
          {
            "label": "summary",
            "permalink": "/tags/summary"
          }
        ],
        "readingTime": 25.466666666666665,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "2021-year-end-summary",
          "title": "2021年终总结（休学一年）",
          "date": "2021-12-31T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "年终总结",
            "summary"
          ],
          "keywords": [
            "年终总结",
            "summary"
          ],
          "toc_max_heading_level": 3
        },
        "prevItem": {
          "title": "为何我选择日夜颠倒敲代码",
          "permalink": "/why-i-turn-night-into-day-to-code"
        },
        "nextItem": {
          "title": "JS代码之还原",
          "permalink": "/js-code-deobfuscator"
        }
      },
      "content": "<!-- truncate -->\n\n:::info 这篇文章发布时间与实际编写时间有所不同，所以内容上有可能会包含未来相关的信息，主要是想对过去的经历做个记录总结，算是一个弥补吧。 :::\n\n距离上篇记录过去了 1 年半时间，以后应该也会在每年的 12 月 31 号发布年终总结。\n\n不过在总结的时候还是要唠嗑唠嗑，其实说实话，今年没去年那么想写年终总结，一是感觉去年过得没有前年那么充实，尤其是在学习方面；二是因为 21 年这年休学出去工作(创业)；三是感觉很多时候过于迷茫，尤其是 2021 年后半年，浪费了太多本该提升自我的时间；最后加上 2022 年 1 月闭关安卓逆向学习，所以便没有抽出时间来完善年终总结。\n\n所以说要写年终前一定要趁早，否则将会越来越拖，这次就整整拖了半年才最终完善。平常也要时刻保持记录的习惯，这样年终总结的时候思路才清醒，看到平时记录的点滴就能一时刻地回忆起所有细节。\n\n每次写年终总结时不时也会潸然泪下，写的时候就需要不断的回忆过去，而往往过去的某些时刻的做法会让自己觉得是不是有个更优解？常常会回忆起过去这一年所经历的往往，难以忘怀，不知从何写起。\n\n话虽说，但总归还是学到了点东西，所以还是得总结一下，不记录可能这段经历就消逝在时间的烟海之中。\n\n## Web 开发\n\n在这过去的中时间内，我已经从一位逆向爱好者的转到 Web 开发行业上。在上次的记录中我也仅仅只是搭建了一个博客，还是基于[Vuepress](https://vuepress.vuejs.org/zh/)，不过由于拖更过久，于是就索性使用[Docusaurus](https://docusaurus.io/)做为未来的博客。像一些主流前端框架([Vue](https://v3.cn.vuejs.org/),[React](https://reactjs.org/))以及 [Vite](https://cn.vitejs.dev/) 和 [webpack](https://webpack.js.org/) 构建工具使用过，期间也不断尝试新的技术栈，了解其新特性，所以实现些基本的前端页面或功能倒是不成问题。\n\n但 Web 开发可不仅仅只是由前端页面构成的，虽然对于上面静态站点的博客而言，那确实够。不过想要做到一些页面阅读量，以及评论相关的，就必须涉及到数据交互，也就是后端服务。后端服务所选用的语言可就多了，例如 nodejs、java、php、python、go 等等，虽说都有接触过(尝试搭建过后端服务与部署)，但 node 还是我的后端开发首选， JavaScript/TypeScript 是我目前用的最多的编程语言，这其中就使用到[Nest.js](https://nestjs.com/)这类 Node.js 版的 Spring 框架，同时也接触到[TypeORM](https://typeorm.io/)这个 ORM 框架，操作数据就如操作对象一样，可以不用写 sql 就能完成基本的 CRUD。同时也接触到 Java 的[Spring](https://spring.io/)、Php 的[ThinkPHP](https://www.thinkphp.cn/)、Go 的[Gin](https://gin-gonic.com/zh-cn/)、Python 的[FastAPI](https://fastapi.tiangolo.com/zh/)，这些语言中的后端框架。同时数据库方面也学习与使用到[Mysql](https://www.mysql.com/)、[MongoDB](https://www.mongodb.com/)、[Redis](https://redis.io/)、[Elasticsearch](https://www.elastic.co/cn/elasticsearch/)，这些 SQL 与 NoSQL 数据库以及搜索和数据分析引擎。\n\n可以肯定是的未来的编程日子里有一大段时间估计也与 Web 开发息息相关。\n\n不过在年终这并不想介绍在学习期间所涉及的项目，因为这太啰嗦了，导致有挺大一部分时间都是在介绍，而不是在总结，违背年终总结的意义。**(学习的)过程往往不是人们所在意的，人们往往在意的是所导致的结果。**\n\n关于项目的开发我一般都会放置在[Github](https://github.com/kuizuo)上，以及[博客项目页](https://kuizuo.cn/project)中，可自行查看。\n\n:::tip tip 可以通过 git commit history 查看当前文章修改记录，有我当时对这些项目的一个不完全介绍草稿。 :::\n\n## 看书\n\n也是在今天开始去看书，看文章，加固对已有技术的理解，基本上每天凌晨 0-2 点的时间段都在看技术相关的书籍。主要都是针对 JS 相关的书籍与一些其他书籍，例如\n\n- 《JavaScript 高级程序设计》（第 4 版，简称红宝书）\n- 《重构 改善既有代码的设计》（第 2 版，JS）\n- 《JavaScript 设计模式与开发实践》\n- 《深入浅出 Node.js》\n- 《Visual Studio Code 权威指南》\n- 《深入浅出 Vue.js》\n- 《Vue.js 设计与实现》\n\n## 经历总结\n\n相比学习记录而言，我反倒是想总结个人的一些机遇与所做（缺点与不足），以及未来遇到这类情景能否有改进的地方。\n\n### 深思熟虑\n\n反思我当时面对这种情况，我当时的做法是否合理？是否为最优解？是否有考虑他人感受？是否有考虑这么做未来有什么不利？是否...?\n\n事情发生后能否做到不后悔？能否想过如何挽回？能否总结下次遇到这种情况又该如何做？...(语塞片刻) 还能有下一次吗？\n\n很显然，在这一年当中我并没有很好的反思与总结，而是直到出现一些严重性的结果，我才会开始考虑此后果与弥补。\n\n而休学便是我当时面对情景中的做法之一。\n\n当时的我没有思考我休学后所会给我带来的不利，如后续学校课程的变化能否顺便完成毕业，是否想过休学后的生活，复学手续的办理，等等太多要思考的了，然而当时的我只思考到学校课程的无聊，不如出去工作闯闯，这可不比学校每天枯燥的生活来的丰富。我甚至还幻想着我休学出去，技术特别厉害，是不是回去就能直接免修课程，直接当大三来读。然而这种想法的天真程度不亚于一个三岁小孩问父母我为什么不能像鸟儿一样在天空中遨游，而现实生活是你只能在地面上爬行。\n\n在学校跟着校方的课程，修满学分，遵守学校规定，完成日常内务卫生，方可毕业。而休学就是休学，休学期间学校只保留你的学籍，你在休学期间外面所发生的一切都与学校无关，如果在休学期结束后还未办理休学手续，则视为退学处理。\n\n到了复学的日子，当时的早上我回到学校办理复学手续，准备重归校园生活。但由于疫情的缘故，学校是不让正常进出，需要使用学校 app 上申报进出码，在当时的我无论怎么申请都无法通过，提示找不到辅导员，因为我休学期间的又重新分配了新的辅导员，也就导致我无法申报进出码，当时的保安无论如何都要学生凭进出码才可进出学校，哪怕我把学生证，以及我休学时的手续，保安与辅导员的沟通，都不允许我进去学校。即便我家属陪同的情况下，依旧等了越 10 来分钟才方可放我进入学校。\n\n现在回想当时如果我的家属没有陪同，也许这一天这个保安都可能不放我进去，保安估计是因为不希望家属在门口等候太久，同时也因为我复学的情况，所以破例放我进入学校，办理复学手续。\n\n扯了这么多，也该说说休学的原因了。\n\n当时（2020 年 12 月），我写了一个软件，并将其发布到我的 QQ 空间上供他人免费使用。有人加了我微信，简单咨询下，机缘很巧，他们的工作地点离我学校仅有 5 公里，于是线下交谈了下，问我有没有兴趣开发一个软件，并提供了一些想法和规划，当然，功能和需求与我所编写的大致。加之那段时间我已经厌烦学校所教的课程，与他们不谋而合，于是伴着辍学的心态办理休学手续，在 2021 这一整年“大展身手”。\n\n这也就是为什么我 2021 年上半年没继续学习前端，没写博客的原因。在这期间，我基本上都是在忙着对该软件的更新维护。至于说为何要休学，明明离校那么近，可以边远程边线下办公。这主要还是与我的生活态度有关，我不希望我在做任何事情的时候，突然有其他的事情来打断我现有的阶段任务，哪怕只是一点小事，都有可能导致我难以进入工作状态。我忌惮的是在同时兼顾学业与工作，到头来很有可能两者都干得一塌糊涂（不过最主要我当时的内心是非常不情愿在上课的）。于是在学业与工作上两者无法兼顾到于是就休学专心工作。\n\n说这么多，最主要是当时的我确实不是很想在校园里呆在，与其听着学校老师教的，不如自己出去社会闯荡一番来的实在。但最终的事实告诉我，还是出来太早了，社会的经验是不断磨练学习，而不是凭自己短暂实践与猜想的，只有**切身体会才能悟出真谛**。\n\n又有点扯远了，总之简单交代下休学的缘由。而在今后的未来也会有一大堆这样的例子，而所发生过的甚至能写一天。**能做的仅有是保持一颗善良的心，与权衡自己内心的真实**\n\n#### 如何考虑诸多结果\n\n有很多种结果，并不是由自己所能考虑到的，哪有该如何是好。\n\n如果之前的话，我确实不知道该如何，但现在我多半会把我所遇到的情况告诉身边的人(父母、朋友)，让他们帮我出谋划策。\n\n他们所能给的也是建议，最终的决定权还是归咎于自己。事情的最终发展走向，也是看自己的表现。\n\n### 人情世故\n\n在没休学前，我的情商可以说是低的离谱，一点人情世故都不会有的那种。遇到一些情况我都很直面的揭穿，没有留有一定的台阶给他人下，没有思考这样做的情况对长期利益下的影响。这里我有一个亲身例子。\n\n当时在工作中有位用户 A 反馈了一个网站的充值系统的 bug，这个 bug 可以导致随意给任意用户充值任意金额（没听错，这个 bug 的严重程度就是如此。不过当然不是我写的，这部分核心是由当时的一个外包公司搞得）。用户 A 交代了这个 bug 是由其他用户 B 告诉他的，并没有指名 B 的真实身份，原本 B 是想告诉 A 一起薅这个网站的漏洞，但 A 觉得不妥，想和我们长期合作，并将这个 bug 反馈给了我们。如果换做你的话，你又该如何处理这种事情。\n\n当时的我第一想法就是找到漏洞，并将该漏洞修复了，但是是否有想过，在 B 告诉 A 没多久后，网站就把这个漏洞修复了，这不就明摆告诉 B，A 把这个 bug 反馈给了网站所有者，并且出卖了他。到时候 A 和 B 的关系又会如何发展？A 是否又会认为这个网站很没有格局？最终不打算长期合作？\n\n而这些显然不是我当时所能想到的，而是我的同事所告诉我的。接着再来说说最终这件事情是如何处理的。首先我们第一时间肯定不是修复这个 bug，而是尝试去查询一些异常数据，例如大额充值，余额异常，对比真实流水与网站流水，尽快的确保找到这个 B 用户。不过这个 B 用户做事非常小心，这些数据与真实的几乎难以排查。于是我们尝试给这个 bug 加个暗桩，只要有用户触发这个 bug 就会将数据上报，最终找到 B 用户，也就是在赌这个 B 用户还会利用这个漏洞来进行充值。\n\n果不其然，这个 B 用户还是抱着侥幸心理触发了这个 bug，然后项目的负责人直接联系到 B，然后暗示 B 用户，说他最近账号的活跃度这么高，金额有点异常。人总是有做贼心虚的时候，和 B 用户说了一大堆道理啥的，也说明 B 的这种行为是直接利用网站漏洞来盈利，其行为是有可能构成犯罪的。可能是把 B 说怕了，也是让 B 自己说出自己利用过 Bug，也说自己把这个 Bug 告诉了几个同伙 A，C 等人。最终，修复了这个 Bug，并一一联系这些并将其获利的金额给补齐，也就没在追究。（但实际上是有一定的损失的，只要这个 bug 被发现，能做的也只有弥补损失）\n\n现在一回想，如果不是 A 主动告诉我们，也许这 Bug 可能在长时间都无法发现。最终这个 A 也成为了我们网站的合伙人。如果当时直接修复这个 bug，失去的金额是有可能找的回来的，但 A 这个用户却再也成为不了合作伙伴。但要说 B 会知道是 A 说的吗，他也许不知道，因为自始至终都未提及过 A，但他们之间的关系会有影响吗？与直接修复 bug 的相比，我看微不足道。\n\n身边有太多为人处世的方法、道理和经验。\n\n- 麻烦他人签字盖个凭证，如果态度不是很友好，并且无感激之言，会让签字的人所感厌烦，下次的签字是否会顺利？\n- 遇到他人能否做到打个招呼，即便不是那么熟的情况下？\n- 如果麻烦他人帮忙处理点事情，顺带带点吃的、送点礼物，那么他是否就会帮忙处理一下？\n- 学会聆听长辈的建议，长辈所经历的远非后辈可言，都有长辈一定的道理，如果你只会觉得厌烦这些道理，那么很有可能一些长辈的经验只有自己吃过亏了才懂。\n- 人都爱听赞美之词，能否在别人取得一定成果的时，给予一定的夸奖，对于他的心情是否也会变好？\n- ……\n\n有些人说他不想拘泥于生活的小节，想活得无拘无束。然而绝大多数情况下是不可能的，就像上面所举的例子而言，很多小节就有很大程度决定事情最终的发展。\n\n**人活着务必要懂的人情世故，合理的为人处世往往会名利兼收，而不是狼狈不堪。**\n\n### 行事低调\n\n人在外面，要尽可能保持低调，不要展现自己过多的储备与能力。\n\n就当我而言，我复学回学校正常上课的期间，很多学校老师所教的与所问的我都悉知，但我并不会第一时间回答，甚至是不回答。因为我知道如果我一旦回答，就会显得我很专业，他人会认为我的知识面比较广，可能就会来问我问题，交流技术。这本质是好的，一是能给同学一个相对好的印象，二是对班级同学学习氛围都有一定影响。但如果我不回答，对我有害吗？并不会。但回答就有优吗？也不见得。因为随着越来越多人询问，就可能会导致本该属于我的时间，却因为这些问答所耽搁。\n\n至于是否回答与导致的结果，就需要权衡自身当下的言语行为是否对你有利，就比如对于新室友而言，我反倒第一时间说明自己有一定的技术水平，也在外面工作过，并给他们展示一些个人项目。因为我知道他们身边有个大佬，一些技术问题就有个大腿可抱，对于人际关系与求人办事来说都是对我非常有利。\n\n不要泄露自身的“底”，这里的“底”对于上面的例子就是技术而言，而实际生活中，“底”有可能财富，背景，智慧等等。要知道社会处处是勾心斗角，越是让他人知道你的情况，往往是对自己不利。即便此刻的他对你所述的并无兴趣，但当他需要的时候，第一时间想到的就很有可能就是你。\n\n“财不外露”是古人总结的经验教训，低调就是最好的自我保护。这是社会上的生存法则。\n\n**一时的得意洋洋会换来以后的肠子悔青，一时的众星捧月会招来以后的众人愤恨。**\n\n### 言多必失\n\n我是属于那种说几句话，就容易滔滔不绝的那种。平常聊天中，也许对方只是想问下我银行卡号是多少，而我可能已经把银行卡密码告诉他（夸张点）。直白点意思就是话很多，非常容易说出一些本不应该说的东西。像以前如果有个人偷偷告诉我一个秘密，叫我千万不要说出去，而有时候不经意间就成为了告密者。然而我本意并不想泄密，但就是因为交际中，过度不必要的话语就往往。\n\n当然，如果说的是自己的一些事情的话，对于他人来说，可能就听听就忘了。但有很多时候说着说着就说到他人去了，这时候一些过多的言语，就可能导致一些不恰当的词语加在他人身上。\n\n我也许做不到**沉默是金**的实践，但我一定明白存在的意义。不善言，那就不必言。我之前就很喜欢给别人安利些东西，具体点如技术框架这些，但大部分情况下没成功安利，哪怕我对他当下的情况进行一定的分析，并告诉他使用了对自己的提升等等。而结果往往是将我的话语当做耳边风一般，也许是我的言语没有那么说服力，又或者是他不愿尝试新事物。所以这也就是为什么我现在不喜欢安利，不想多说些什么。即便说得再多，对我来说几乎没有任何利益可言，反倒是不说，没有任何亏损。\n\n**能沉默寡言就不必口若悬河**\n\n### 得意忘形\n\n当一个人突然对你特别好，那么这时候就需要谨慎了，很有可能自己**沉浸在好处之中**，而**忘记所在的风险**。\n\n就比如陌生人给小孩子糖果的例子，小孩子往往容易沉浸在得到甜味之中，而不会去想陌生人会将自己处于何种地步，当然这也和小孩子没有明确的自我辨别善恶的能力有关。但换到成人年身上不妨是同一道理，只是将这里的糖果换成了其他的好处而已。\n\n这里我想强调的是，人一旦处于高兴的状态下就容易忘记一些行为。就如酒后吐真言，在喝酒兴奋的状态，是难以有任何的危险警觉，在喝醉的情况下，可能会把自己的一切说出去，而醒后根本难以想到当时兴奋的时候竟说过这般话语。\n\n而多数人往往容易处于这种状态，对我来说可能就是别人夸我几句，我感觉非常得意，然后又和对方说起无关该话题的内容。然后这就回到上一个口若悬河话题。\n\n也许可能会说，为啥要如此盯防这些潜在危险，因为坏人多数都是利用这种得意忘形的状态去坑害受害者。而能做的只有时刻预防危险，因为你永远不清楚危险的来临，当危险真正来临之时，就以措手不及。\n\n### 急于求成\n\n就如这次休学，我就巴不得早点工作，早点实现财富自由。但**过早的发育，往往会迷失方向**。\n\n其实我日常编写代码的时候也是如此，有时候就是为了快点实现功能需求，就会去寻找相关功能库，就容易忽视底层实现逻辑。久而久之就成为了 CV（复制粘贴）工程师，导致一些学习本该了解的知识点，就因此忽视，直到别人的库无法实现自己的功能的，到自己实现起来可谓是愁眉苦脸的。\n\n所以我现在心态也相对以前平坦了许多，没有之前的那种激情劲，或者说更加稳重，走一步都要稳一步。\n\n有时候有些东西就应该顺从时间的发展，强行去改变它的发展方向有可能就得不偿失。还有，为何要急于去创造成功，而不是成功去找寻你呢？\n\n**顺其自然，不失一个生活态度。**\n\n### 虚假欺诈\n\n[楚门的世界](https://movie.douban.com/subject/1292064/)中有一句台词对我印象特别深刻。\n\n**外面的世界跟我给你的世界一样的虚假，有一样的谎言一样的欺诈**。\n\n外面的世界即现实，亦或者是社会。确实，这里存在太多虚伪的内容，多数人对他人的表现与自身内心存在极大差异。举个例子，一个非常普通的人，面对领导时展现积极主动，面对朋友时展现情同手足，面对亲人时展现情同骨肉，对不同的人，都有不同的表现形式，而真实的他却只有自己最清楚。可以说人本就是很虚伪的，只是这种形式在交际中被放大。\n\n除了虚伪外，很多的还是谎言。这里举一个不那么黑暗的谎言，多数人都喜欢装逼，吹嘘自己如何如何的。将自己包装得有多么厉害，地位多么显赫。其目的也只有自己最清楚，在被这种表面所影响下，就认为他事情都相对可靠，其实不然的。\n\n所以言语上，并不能以百分之百的确信。再好比目前互联网的新闻内容或者是短视频，我都不会去对其真实性保持绝对，至少肯定不会是完整的。因为太清楚这些内容多数是以博人眼球为目的，也许会歪曲一定的事实，营造一个绝对火爆的效果。没置身于此地，又怎敢下一断言呢。\n\n**俗话说得好眼见为实，不要轻信传闻，看到的才是事实。**\n\n不要轻易的他言，越是真诚的人，越是容易被欺骗。\n\n## 自我保护\n\n这些就是我这一年的大部分社会感悟，然而事实上这仅仅只是皮毛中的皮毛，有很多不是那么友好的面我并没有用言语去展现，也难以展示。\n\n但最终想说的是出门在外，保护好自己才是最重要的。无论是身体还是精力，起码活着是为自己而活。\n\n同时时刻**当心**生活中的风险，无论大火小火最终都有可能酿成不可挽回的伤害。能做的也只有提防，警惕。\n\n与社会相比，校园生活也确实安全多了。与你相龄的同学，很多都没有经过社会，做事处事都不会搞得如此复杂，但或多或少肯定还是存在的，只是相比社会而言没那么复杂。倒是可以说大学校园就是步入社会的一个缓冲区，缓冲区有多大，就决定在社会中你的发展效率。\n\n## 回到校园\n\n办理完复学手续，接触了新室友，新班级，依旧还是熟悉的校园，但此时此刻却感受不到校园的气息。内心也许还停留在休学一年的风光，可身体可却要老老实实在待上两年。\n\n每日起床，打开屏幕，查看邮件信息，吃饭，能旷的课就旷，不能旷的课就尽量去，坐下敲代码，一天的日子就这样过去了。这半年里至少有百分之 80 的日子是处于这种状态。\n\n要说枯燥，其实也有一些乐趣，要说充实，其实也会摸点鱼。不过，这不就是大部分人的生活方式吗？以混日子的方式做着重复的事，在重复中寻求一丝不同。\n\n在学校也没啥特殊的要求，别挂科，在读两年拿到毕业证与学位证即可。还有两年的时间发展，也许这两年是程序生涯中仅存可自由分配的时间。\n\n## 总结\n\n要说我这一年的总结，**一切行为都一定要留后路**。\n\n人生要做太多的后退路，才能够走出自己的路。过去的自己的很多决定都是不留活路，可以说是大部分的情况连后悔的机会都没有。当时的我为何要做得如此绝呢？仅仅只是鲁莽吗。不，所突显的是一个真诚的态度。如果做得任何事情都留有后路，只能说你是一个警惕的人，但不是一个真诚的人。但这个社会往往就是不需要真诚老实的人，在结果面前，这些都一文不值。越是真诚，越容易被欺骗。到头来，伤的还是真诚的人。\n\n我高中因为一些特殊原因换过班，换完之后有一段时间非常后悔，失去(永别)日常课上课下与要好的同学。可结果已经发生了，很多东西就难以还原成最初的模样。上了大学第一学期结束，我就从数学专业转到软件工程专业，只为毕业时有个科班的资格，而现在科班在我看来一文不值，还要面临补修原专业没有的课程。但相关手续都已经办理完毕，即便撕毁手续，也无济于事。每一次的选择，都总让我觉得不值，失去的远比得到的多。\n\n不过话也不能说的这么绝对，我高中换班让我远离那些特意”针对”我的老师（我高中学习表现特别差，属于那种差生不爱学习的，虽然现在也差不多）。我转专业也认识到一些志同道合都热爱编程的伙伴，我要是不转专业也许在这个学校里可能都难以有交集。同样的休学也让我收获了不少，社会经验与做人处事有了个质的提升。\n\n所以高中的我特别渴求大学，在大学里不断的提升自我，也就是为什么高考一结束，我就沉浸在电脑面前，不是游戏电影，而是可创造一切的代码上。在上一学期后，想去软件工程软件。并且当我有了一定的代码基础水平，我觉得有能力去应付实际任务需求，也就办理休学手续，去完成一番“事业”。现在回到校园，同样的，我也非常渴求毕业，只为能够更早做出一番事情来。\n\n如果有个选择让你在 40 岁前平平无奇，但在 40 岁后一鸣惊人成就一番事业，我想我肯定不会选择。我已经经历了比同龄人多的多的经历，我完全认为 30 岁就能达到 40 岁时的目标。有一个梦想叫别人 30 岁有的东西我 20 岁就要，这也是我的梦想。\n\n为什么会休学，想必已经有了一个很明确的答案。而且我也很清楚，谁都劝不动当年的我。即便休学让我晚毕业的一年，同时还带来了各种琐事。在明知道结果的前提我依然还是会决定。\n\n做技术写程序的不应该只有技术上的进步，更应该在友好的交互方面，这里的交互不单单是人与机的交互，而是生活中人与人，人与事之间的交互。\n\n一个应用程序的实用性如何，很大一部分取决于交互。生活中圈子同样与他人的交互有很大牵连。代码写的再好，功能再强大，但是没有一个好的交互，用户同样不会使用。生活中，即使能力再强大，但对他人不友好、对工作不上进，也难被认可。\n\n愿来年提升自我的同时，能够辨别是非，待人处世。修正自身缺点，发挥自有特长。不要高傲自大，不要妄自菲薄。不要只沉浸做事，而不去做人。保持原有的心态，不被大起大落所失衡。不断经历，不断收获。\n\n愿一切安好，愿前程似锦。"
    },
    {
      "id": "js-code-deobfuscator",
      "metadata": {
        "permalink": "/js-code-deobfuscator",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/JS代码之还原.md",
        "source": "@site/blog/develop/JS代码之还原.md",
        "title": "JS代码之还原",
        "description": "基于 Babel 对 JS 代码进行混淆与还原操作的网站 JS 代码混淆与还原 (kuizuo.cn)",
        "date": "2021-12-25T00:00:00.000Z",
        "formattedDate": "2021年12月25日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "ast",
            "permalink": "/tags/ast"
          },
          {
            "label": "reverse",
            "permalink": "/tags/reverse"
          },
          {
            "label": "project",
            "permalink": "/tags/project"
          }
        ],
        "readingTime": 18.983333333333334,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "js-code-deobfuscator",
          "title": "JS代码之还原",
          "date": "2021-12-25T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript",
            "ast",
            "reverse",
            "project"
          ],
          "keywords": [
            "javascript",
            "ast",
            "reverse",
            "project"
          ]
        },
        "prevItem": {
          "title": "2021年终总结（休学一年）",
          "permalink": "/2021-year-end-summary"
        },
        "nextItem": {
          "title": "JS代码之混淆",
          "permalink": "/js-code-obfuscator"
        }
      },
      "content": "基于 Babel 对 JS 代码进行混淆与还原操作的网站 [JS 代码混淆与还原 (kuizuo.cn)](http://deobfuscator.kuizuo.cn/)\n\n![js-de-obfuscator](https://img.kuizuo.cn/20220131193110.png)\n\n<!-- truncate -->\n\n## 还原前言\n\nAST 仅仅只是静态分析，但可以将还原出来的代码替换原来的代码，以便更好的动态分析找出相关点。在还原时，并不是所有的代码都能还原成一眼就识破代码执行逻辑的，ast 也并非万能，如果你拥有强大的 js 逆向能力，有时候动态调试甚至比 AST 静态分析来的事半功倍。\n\n### 还原不出最原始的代码\n\n标识符是可以随便定义的，只要变量不冲突，我可以随意定义，那么就已经决定我们还原不出源代码的变量名，所以能还原的只有一些花指令，使其代码变好看，方便调试。\n\n### 还原也不是万能的\n\n混淆的方式有很多，与之对应还原的方式也有很多，上面那套混淆的还原可能只针对那一套混淆的代码，如果拿另一份混淆过的代码，然后执行这个还原程序的话，那程序多半有可能报错。所以绝对没有万能的还原代码，所有的还原程序，都需要针对不同的混淆手段来进行处理的。\n\n**我只是将我所遇到的混淆手段整合到一套代码上，而非所有的混淆手段都能进行还原处理的。**\n\n**同时也别过于追求还原，因为还原很容易破坏原有代码，导致一些未知 bug。**\n\n:::tip\n\n如需要定制化还原，也可联系。（还是要说下，绝对无法还原出最原始代码）\n\n:::\n\n## 例子\n\n下文将会针对主流的一些混淆手段（至少是在我遇到的混淆中相对比较好还原的），并会附上对应代码供参考（不放置代码出处）。\n\n接下来我将要演示一个混淆代码是如何还原的，这个例子是我第一次接触混淆的例子，也可以说是我玩的最溜的一次还原了，反正折腾了也有 4,5 来次。\n\n贴上代码 git 地址 [js-de-obfuscator/example/deobfuscator/cx](https://github.com/kuizuo/js-de-obfuscator/blob/main/example/deobfuscator/cx/code.js)\n\n> 注：该 js 文件是通过工具[JavaScript Obfuscator Tool](https://www.obfuscator.io/)进行混淆处理的。\n\n### 分析 AST\n\n首先一定一定要将混淆的代码解析成 AST 树结构，任何混淆的还原都是如此。首先简单随便看看代码，不难发现这些代码中都有`'\\x6a\\x4b\\x71\\x4b'`这样的十六进制编码字符，可以使用现成的工具，格式化便会限制编码前的结果，不过这边使用 ast 来进行操作\n\n通过 AST 查看 node 节点，可以发现`value`正是我们想要的数据，但这里确显示的是`extra.raw`，实际上只需要遍历到相应的节点，然后 extra 属性给删除即可，同样的 Unicode 编码也是按上述方式显示。\n\n![image-20211224202108279](https://img.kuizuo.cn/image-20211224202108279.png)\n\n具体遍历的代码如下\n\n```javascript\n// 将所有十六进制编码与Unicode编码转为正常字符\nhexUnicodeToString() {\n\t\ttraverse(this.ast, {\n\t\t\tStringLiteral(path) {\n\t\t\t\tvar curNode = path.node;\n\t\t\t\tdelete curNode.extra;\n\t\t\t},\n\t\t\tNumericLiteral(path) {\n\t\t\t\tvar curNode = path.node;\n\t\t\t\tdelete curNode.extra;\n\t\t\t}\n\t\t})\n\t}\n```\n\n然后将遍历后处理过的代码与 demo.js 替换一下，方便接下来的还原处理。不过处理完还是有大部分未知的字符串需要解密，当然也有一些没处理过的代码。\n\n### 找解密函数\n\n如果你尝试过静态分析该代码，会发现一些参数都通过\\_0x3028 来调用，像这样\n\n```javascript\n_0x3028['nfkbEK']\n_0x3028('0x0', 'jKqK')\n_0x3028('0x1', ')bls')\n```\n\n不过认真查看会发现像成员表达式`MemberExpression`语句`_0x3028[\"nfkbEK\"]`，但在第三条语句却定义函数`_0x3028`。其实是 js 的特性，比方说下面的代码就可以给函数添加一个自定义属性\n\n```javascript\nlet add = function (a, b) {\n  add['abc'] = 123\n  return a + b\n}\n\nconsole.log(add(1, 2))\nconsole.log(add['abc'])\n\n// 3\n// 123\n```\n\n不过不影响，这里只是提一嘴，并不是代码的问题。而其中**`_0x3028`就是解密函数**，且遍历`_0x3028`调用表达式，且参数为两个的 CallExpression。\n\n那么接下来就要着重查看前三个语句，因为这三条语句便是这套混淆的关键所在。\n\n```javascript title=\"demo.js\" {1，3-7}\nvar _0x34ba = [\"JcOFw4ITY8KX\", \"EHrDoHNfwrDCosO6Rkw=\",...]\n(function(_0x2684bf, _0x5d23f1) {\n    // 这里只是定义了一个数组乱序的函数,但是调用是在后面\n    var _0x20d0a1 = function(_0x17cf70) {\n        while (--_0x17cf70) {\n            _0x2684bf['push'](_0x2684bf['shift']());\n        }\n    };\n    var _0x1b4e1d = function() {\n        var _0x3dfe79 = {\n            'data': {\n                'key': 'cookie',\n                'value': 'timeout'\n            },\n            \"setCookie\": function (_0x41fad3, _0x155a1e, _0x2003ae, _0x48bb02) {\n\t\t\t\t...\n            },\n            \"removeCookie\": function () {\n                return \"dev\";\n            },\n            \"getCookie\": function (_0x23cc41, _0x5ea286) {\n                _0x23cc41 = _0x23cc41 || function (_0x20a5ee) {\n                    return _0x20a5ee;\n                };\n\n                // 在这里定义了一个花指令函数调用来调用\n                var _0x267892 = function (_0x51e60d, _0x57f223) {\n                    _0x51e60d(++_0x57f223);\n                };\n\t\t\t\t// 实际调用的地方\n                _0x267892(_0x20d0a1, _0x5d23f1);\n\n                return _0x1c1cc3 ? decodeURIComponent(_0x1c1cc3[1]) : undefined;\n            }\n      }\n        };\n    };\n    _0x1b4e1d();\n}(_0x34ba, 296));\nvar _0x3028 = function (_0x2308a4, _0x573528) {\n  _0x2308a4 = _0x2308a4 - 0;\n  var _0x29a1e7 = _0x34ba[_0x2308a4];\n\n  // 省略百行代码...\n\n  return _0x29a1e7;\n};\n```\n\n其中省略的代码没必要细读，因为后续都只将这三条语句写入到 node 内存中（eval），然后来调用。接下来分析每一个语句都是干嘛的。\n\n#### 大数组\n\n基本 99%的混淆**第一条语句都是一个大数组**，存放这所有加密过的字符串，而我们要做的就是找到所有加密过的字符串，将其还原。\n\n#### 数组乱序\n\n然后接着**第二条语句一般都是自调用函数**，将大数组与数组乱序数量作为参数，其中的作用是将数组进行乱序，也就是上面代码中加亮的地方，但这里只是定义了一个函数`_0x20d0a1`，而实际调用的地方 `_0x1b4e1d` 中`_0x3dfe79`.`getCookie`中调用的，上述代码中有注释。如果你是正常一步步分析还真不一定的分析的出来，这就是混淆恶心的地方。\n\n不吹混淆了，总之只要知道第二条语句是用作数组乱序，而具体无论怎么混淆，我们都可以通过 eval 来调用一遍，详看后文代码。\n\n#### 解密函数\n\n第三条语句就是加密函数，实际上就是传入大数组的索引，然后返回数组对应的成员，只是这边将其封装成函数，相当于原本 `_0x34ba[0]` 变为`_0x3028(\"0x0\", \"jKqK\")` 形式来获取原本的字符串（这里只是举例，实际还涉及到第二个参数）。\n\n### 还原字符串\n\n上面说了那么多，实际上具体混淆逻辑其实根本没必要去理解，像传入的第二个参数做了啥根本无需了解，因为我们最终的目的是将 `_0x3028(\"0x0\", \"jKqK\")`转为原本字符串，然后替换的当前节点的。所有只需要遍历到`_0x3028(\"0x0\", \"jKqK\")`，然后**执行一遍解密函数**得到解密后的结果，然后替换即可。所以如何执行解密函数便是重点了。\n\n#### 将解密函数添加到内存中\n\n首先要将三条语句运行一遍，js 中要在运行时运行字符串的代码，就可以使用 eval，但 eval 有作用域的问题，eval 运行的代码作用范围都是局部的，如果脱离当前作用域，eval 运行的代码就相当于无效了，所有可以使用`window.eval`或`global.eval`，将其写入置全局作用域下，由于这里是 node 环境，便用`global.eval`。\n\n截取前三条语句，使用 eval 写入内存\n\n```javascript\n// 拿到解密函数所在节点\nlet stringDecryptFuncAst = this.ast.program.body[2]\n// 拿到解密函数的名字 也就是_0x3028\nlet DecryptFuncName = stringDecryptFuncAst.declarations[0].id.name\n\nlet newAst = parser.parse('')\nnewAst.program.body.push(this.ast.program.body[0])\nnewAst.program.body.push(this.ast.program.body[1])\nnewAst.program.body.push(stringDecryptFuncAst)\n// 把这三部分的代码转为字符串，由于存在格式化检测，需要指定选项，来压缩代码\nlet stringDecryptFunc = generator(newAst, { compact: true }).code\n// 将字符串形式的代码执行，这样就可以在 nodejs 中运行解密函数了\nglobal.eval(stringDecryptFunc)\n```\n\n#### 调用解密函数\n\n这时候，就可以使用`_0x3028(\"0x0\", \"jKqK\")` 来输出解密后的结果，不过要一个个手动输入还是太麻烦了，完全可以找到`_0x3028`调用的所有地方，然后判断是否为调用表达式 CallExpression，然后使用`eval('_0x3028(\"0x0\", \"jKqK\")')` 获取解密结果。这边就举一个遍历的例子。\n\n```javascript\ntraverse(this.ast, {\n  VariableDeclarator(path) {\n    // 当变量名与解密函数名相同\n    if (path.node.id.name == DecryptFuncName) {\n      let binding = path.scope.getBinding(DecryptFuncName)\n      // 通过referencePaths可以获取所有引用的地方\n      binding &&\n        binding.referencePaths.map((p) => {\n          // 判断父节点是调用表达式，且参数为两个\n          if (p.parentPath.isCallExpression()) {\n            // 输出参数与解密后的结果\n            let args = p.parentPath.node.arguments.map((a) => a.value).join(' ')\n            let str = eval(p.parentPath.toString())\n            console.log(args, str)\n            p.parentPath.replaceWith(t.stringLiteral(str))\n          }\n        })\n    }\n  },\n})\n```\n\n在混淆的时候就提及到 binding 可以获取当前变量的作用域，而`binding.referencePaths`就可以获取到所有调用的地方，那么只需要判断是否为调用表达式，且参数是两个的情况下，然后通过 eval 执行一遍整个节点，也就是`eval('_0x3028(\"0x0\", \"jKqK\")')`，然后通过 replaceWith，替换节点即可。传入的参数与加密后的结果大致展示如下，可自行运行一遍程序中`decStringArr()`\n\n```\n0x0 jKqK PdAlB\n0x1 )bls jtvLV\n0x2 M10H SjQMk\n0x3 2Q@E length\n0x4 [YLR length\n0x5 QvlS charCodeAt\n0x6 YvHw IrwYd\n0x7 iLkl ClOby\n0x8 DSlT console\n...\n```\n\n#### 两者代码对比\n\n原先代码与处理后的代码对比(部分)\n\n```javascript\nvar _0x505b30 = (function () {\n  if (_0x3028('0x0', 'jKqK') !== _0x3028('0x1', ')bls')) {\n    var _0x104ede = !![]\n\n    return function (_0x3d32a2, _0x35fd15) {\n      if ('bKNqX' === _0x3028('0x2', 'M10H')) {\n        var _0x46992c,\n          _0x1efd4e = 0,\n          _0x5cae2b = d(f)\n\n        if (0 === _0xb2c58f[_0x3028('0x3', '2Q@E')]) return _0x1efd4e\n\n        for (_0x46992c = 0; _0x46992c < _0xb2c58f[_0x3028('0x4', '[YLR')]; _0x46992c++)\n          (_0x1efd4e = (_0x1efd4e << (_0x5cae2b ? 5 : 16)) - _0x1efd4e + _0xb2c58f[_0x3028('0x5', 'QvlS')](_0x46992c)), (_0x1efd4e = _0x5cae2b ? _0x1efd4e : ~_0x1efd4e)\n\n        return 2147483647 & _0x1efd4e\n      } else {\n        var _0x45a8ce = _0x104ede\n          ? function () {\n              if (_0x3028('0x6', 'YvHw') === _0x3028('0x7', 'iLkl')) {\n                that[_0x3028('0x8', 'DSlT')]['log'] = func\n                that[_0x3028('0x9', 'YW6h')][_0x3028('0xa', '&12i')] = func\n                that[_0x3028('0xb', '1jb4')]['debug'] = func\n                that[_0x3028('0xc', 'k9U[')][_0x3028('0xd', 'nUsA')] = func\n                that[_0x3028('0xe', ')bls')][_0x3028('0xf', 'PZDB')] = func\n                that['console'][_0x3028('0x10', 'r8Qx')] = func\n                that[_0x3028('0x11', 'AIMj')][_0x3028('0x12', '[YLR')] = func\n              } else {\n                if (_0x35fd15) {\n                  if (_0x3028('0x13', 'r8Qx') !== _0x3028('0x14', 'YLF%')) {\n                    var _0x1fa1e3 = _0x35fd15[_0x3028('0x15', 'sLdn')](_0x3d32a2, arguments)\n\n                    _0x35fd15 = null\n                    return _0x1fa1e3\n                  } else {\n                    _0x142a1e()\n                  }\n                }\n              }\n            }\n          : function () {}\n\n        _0x104ede = ![]\n        return _0x45a8ce\n      }\n    }\n  } else {\n    ;(function () {\n      return ![]\n    }\n      [_0x3028('0x16', 'Yp5j')](_0x3028('0x17', ']R4I') + _0x3028('0x18', 'M10H'))\n      [_0x3028('0x19', '%#u0')]('stateObject'))\n  }\n})()\n```\n\n```javascript\nvar _0x505b30 = (function () {\n  if ('PdAlB' !== 'jtvLV') {\n    var _0x104ede = !![]\n\n    return function (_0x3d32a2, _0x35fd15) {\n      if ('bKNqX' === 'SjQMk') {\n        var _0x46992c,\n          _0x1efd4e = 0,\n          _0x5cae2b = d(f)\n\n        if (0 === _0xb2c58f['length']) return _0x1efd4e\n\n        for (_0x46992c = 0; _0x46992c < _0xb2c58f['length']; _0x46992c++)\n          (_0x1efd4e = (_0x1efd4e << (_0x5cae2b ? 5 : 16)) - _0x1efd4e + _0xb2c58f['charCodeAt'](_0x46992c)), (_0x1efd4e = _0x5cae2b ? _0x1efd4e : ~_0x1efd4e)\n\n        return 2147483647 & _0x1efd4e\n      } else {\n        var _0x45a8ce = _0x104ede\n          ? function () {\n              if ('IrwYd' === 'ClOby') {\n                that['console']['log'] = func\n                that['console']['warn'] = func\n                that['console']['debug'] = func\n                that['console']['info'] = func\n                that['console']['error'] = func\n                that['console']['exception'] = func\n                that['console']['trace'] = func\n              } else {\n                if (_0x35fd15) {\n                  if ('WuEjf' !== 'qpuuN') {\n                    var _0x1fa1e3 = _0x35fd15['apply'](_0x3d32a2, arguments)\n\n                    _0x35fd15 = null\n                    return _0x1fa1e3\n                  } else {\n                    _0x142a1e()\n                  }\n                }\n              }\n            }\n          : function () {}\n\n        _0x104ede = ![]\n        return _0x45a8ce\n      }\n    }\n  } else {\n    ;(function () {\n      return ![]\n    }\n      ['constructor']('debu' + 'gger')\n      ['apply']('stateObject'))\n  }\n})()\n```\n\n可以发现处理过的代码至少无需动态调用出解密后的结果，并且像`if (\"PdAlB\" !== \"jtvLV\")`这种语句都可以直接一眼看出必定为 true，但混淆后`if (_0x3028(\"0x0\", \"jKqK\") !== _0x3028(\"0x1\", \")bls\"))`却无法看出，**这就是 AST 静态分析的优势所在**。\n\n#### 删除混淆语句\n\n在执行完字符串解密后，其实大数组与解密函数都已经用不到了，那么就可以通过 shift 将前三条语句给删除。\n\n```javascript\n// 将源代码中的解密代码给移除\nthis.ast.program.body.shift()\nthis.ast.program.body.shift()\nthis.ast.program.body.shift()\n```\n\n但一般**不推荐删除**，因为我们有可能是需要将我们还原后的代码与网站内混淆过的代码进行替换，然后再进行动态调试分析，但如果删除了这三条混淆语句，有可能会导致代码执行出错。我之前习惯删除，但直到我遇到了一个网站。。。\n\n最终整个完成的代码在类方法`decStringArr`\n\n### 找解密函数优化\n\n在上面的代码中有一段这样的代码\n\n```javascript\n    // 当变量名与解密函数名相同\n    if (path.node.id.name == DecryptFuncName) {\n    // ...\n```\n\n其中这里的 DecryptFuncName 对应的是解密函数的函数名\\_0x3028，是通过人为定义，同时载入的是前三条语句，万一解密函数在第四条语句，或者有多个解密函数的情况下，就需要去改动代码\n\n```javascript\n// 拿到解密函数所在节点\nlet stringDecryptFuncAst = this.ast.program.body[2]\n// 拿到解密函数的名字 也就是_0x3028\nlet DecryptFuncName = stringDecryptFuncAst.declarations[0].id.name\n\nlet newAst = parser.parse('')\nnewAst.program.body.push(this.ast.program.body[0])\nnewAst.program.body.push(this.ast.program.body[1])\nnewAst.program.body.push(stringDecryptFuncAst)\n// 把这三部分的代码转为字符串，由于存在格式化检测，需要指定选项，来压缩代码\nlet stringDecryptFunc = generator(newAst, { compact: true }).code\n```\n\n无意间翻看代码的时候，灵光一现，解密函数调用的这么频繁，我直接把所有函数都遍历一遍，并将它们的引用`referencePaths`从高到低排序，不就知道那个是解密函数了吗，于是便有了`findDecFunctionArr`方法\n\n#### findDecFunctionArr\n\n一般而言，解密函数通常是在大数组与数组乱序后定义的，在上面代码中，可以看到是通过制定下标来定位解密函数 `this.ast.program.body[2];`，所以只要能截取到这个 2 即可，具体代码\n\n```javascript\n/**\n   * 根据函数调用次数寻找到解密函数\n   */\n  findDecFunction() {\n    let decFunctionArr = [];\n    let index = 0; // 定义解密函数所在语句下标\n\n    // 先遍历所有函数(作用域在Program)，并根据引用次数来判断是否为解密函数\n    traverse(this.ast, {\n      Program(p) {\n        p.traverse({\n          'FunctionDeclaration|VariableDeclarator'(path) {\n            if (!(t.isFunctionDeclaration(path.node) || t.isFunctionExpression(path.node.init))) {\n              return;\n            }\n\n            let name = path.node.id.name;\n            let binding = path.scope.getBinding(name);\n            if (!binding) return;\n\n            // 调用超过100次多半就是解密函数,具体可根据实际情况来判断\n            if (binding.referencePaths.length > 100) {\n              decFunctionArr.push(name);\n\n              // 根据最后一个解密函数来定义解密函数所在语句下标\n              let binding = p.scope.getBinding(name);\n              if (!binding) return;\n\n              let parent = binding.path.findParent((_p) => _p.isFunctionDeclaration() || _p.isVariableDeclaration());\n              if (!parent) return;\n              let body = p.scope.block.body;\n              for (let i = 0; i < body.length; i++) {\n                const node = body[i];\n                if (node.start == parent.node.start) {\n                  index = i + 1;\n                  break;\n                }\n              }\n              // 遍历完当前节点,就不再往子节点遍历\n              path.skip();\n            }\n          },\n        });\n      },\n    });\n\n    let newAst = parser.parse('');\n    // 插入解密函数前的几条语句\n    newAst.program.body = this.ast.program.body.slice(0, index);\n    // 把这部分的代码转为字符串，由于可能存在格式化检测，需要指定选项，来压缩代码\n    let code = generator(newAst, { compact: true }).code;\n    // 将字符串形式的代码执行，这样就可以在 nodejs 中运行解密函数了\n    global.eval(code);\n\n    this.decFunctionArr = decFunctionArr;\n  }\n```\n\n同时增加 decFunctionArr 属性，用于表示解密函数数组供 decStringArr 使用，就可以免去判断解密函数的步骤了。\n\n## 优化还原后的代码\n\n就此，还原后的代码基本就能静态分析出大概，接下来都是对这份代码进行细微的优化还原。\n\n### 对象['属性'] 改为对象.属性\n\n与混淆对象属性相反，但其实没必要，只是代码相对而言好看一点，影响不大。具体代码如下\n\n```javascript\nchangeObjectAccessMode() {\n\t\ttraverse(this.ast, {\n\t\t\tMemberExpression(path) {\n\t\t\t\tif (t.isStringLiteral(path.node.property)) {\n\t\t\t\t\tlet name = path.node.property.value\n\t\t\t\t\tpath.node.property = t.identifier(name)\n\t\t\t\t\tpath.node.computed = false\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n```\n\n### 还原为 Boolean\n\n在还原后的代码还存在`!![]`与 `![]`或者是`!0`与`!1`，而这对应 js 中也就是`true`与`false`，所以也可以遍历这部分的代码，然后将其还原成 Boolean，像这种表达式就不细说了（有点类似 jsfuck），ast 结构自行分析。具体代码如下\n\n```javascript\ntraverseUnaryExpression() {\n\t\ttraverse(this.ast, {\n\t\t\tUnaryExpression(path) {\n\t\t\t\tif (path.node.operator !== '!') return // 避免判断成 void\n\n\t\t\t\t// 判断第二个符号是不是!\n\t\t\t\tif (t.isUnaryExpression(path.node.argument)) {\n\t\t\t\t\tif (t.isArrayExpression(path.node.argument.argument)) { // !![]\n\t\t\t\t\t\tif (path.node.argument.argument.elements.length == 0) {\n\t\t\t\t\t\t\tpath.replaceWith(t.booleanLiteral(true))\n\t\t\t\t\t\t\tpath.skip()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (t.isArrayExpression(path.node.argument)) { // ![]\n\t\t\t\t\tif (path.node.argument.elements.length == 0) {\n\t\t\t\t\t\tpath.replaceWith(t.booleanLiteral(false))\n\t\t\t\t\t\tpath.skip()\n\t\t\t\t\t}\n\t\t\t\t} else if (t.isNumericLiteral(path.node.argument)) { // !0 or !1\n\t\t\t\t\tif (path.node.argument.value === 0) {\n\t\t\t\t\t\tpath.replaceWith(t.booleanLiteral(true))\n\t\t\t\t\t} else if (path.node.argument.value === 1) {\n\t\t\t\t\t\tpath.replaceWith(t.booleanLiteral(false))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n```\n\n### 计算二项式字面量\n\n还原后的代码中还存在`[\"constructor\"](\"debu\" + \"gger\")[\"call\"](\"action\");`这样的语句，其中`debugger` 特意给拆分成两部分，而这同样可以通过 ast 来进行还原成完整字符串，同样类似的 `1 + 2` 这种字面量 都可以合并。还原程序代码如下\n\n```javascript\n\ttraverseLiteral() {\n\t\ttraverse(this.ast, {\n\t\t\tBinaryExpression(path) {\n\t\t\t\tlet { left, right } = path.node\n\t\t\t\t// 判断左右两边是否为字面量\n\t\t\t\tif (t.isLiteral(left) && t.isLiteral(right)) {\n\t\t\t\t\tlet { confident, value } = path.evaluate() // 计算二项式的值\n\t\t\t\t\tconfident && path.replaceWith(t.valueToNode(value))\n\t\t\t\t\tpath.skip()\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n```\n\n其中 confident 表示是否为可计算，比如说一个变量 + 1，由于程序不知道这变量此时的值，所以就不可计算，confident 也就是为 false。\n\n同时这个计算二项式字面量可以还原一些相对简单的混淆，比方说数字异或混淆 `706526 ^ 706516`计算为 10 就可以直接替换原节点。所以这步的遍历需要相对其他还原提前一些。\n\n### 字符串和数值常量直接替换对应的变量引用地方\n\n有些变量可能赋值过一次就不在进行改变，就如同常量，如下面代码。\n\n```javascript\nlet a = 100\nconsole.log(a)\n```\n\n那么完全可以替换成`console.log(100)` ，最终输出的效果一样，但是前提是 a 只赋值过一次，也可以说 a 必须要是变量，否则这样还原是有可能导致原有执行结果失败，而通过 binding 就能查看变量 a 的赋值历史。\n\n```javascript\ntraverseStrNumValue() {\n\t\ttraverse(this.ast, {\n\t\t\t'AssignmentExpression|VariableDeclarator'(path) {\n\t\t\t\tlet _name = null;\n\t\t\t\tlet _initValue = null;\n\t\t\t\tif (path.isAssignmentExpression()) {\n\t\t\t\t\t_name = path.node.left.name;\n\t\t\t\t\t_initValue = path.node.right;\n\t\t\t\t} else {\n\t\t\t\t\t_name = path.node.id.name;\n\t\t\t\t\t_initValue = path.node.init;\n\t\t\t\t}\n\t\t\t\tif (t.isStringLiteral(_initValue) || t.isNumericLiteral(_initValue)) {\n\t\t\t\t\tlet binding = path.scope.getBinding(_name);\n\t\t\t\t\tif (binding && binding.constant && binding.constantViolations.length == 0) {\n\t\t\t\t\t\tfor (let i = 0; i < binding.referencePaths.length; i++) {\n\t\t\t\t\t\t\tbinding.referencePaths[i].replaceWith(_initValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n```\n\n### 移除无用变量与无用代码块\n\n上面说了有些字符串与数值常量替换，针对是只赋值过一遍的变量，但还可能存在变量未使用过的情况，遇到这种情况，我们可以判断 constantViolations 成员是否为空，然后将其删除。\n\n```javascript\n\tremoveUnusedValue() {\n\t\ttraverse(this.ast, {\n\t\t\tVariableDeclarator(path) {\n\t\t\t\tconst { id, init } = path.node;\n\t\t\t\tif (!(t.isLiteral(init) || t.isObjectExpression(init))) return;\n\t\t\t\tconst binding = path.scope.getBinding(id.name);\n\t\t\t\tif (!binding || binding.constantViolations.length > 0) return\n\n\t\t\t\tif (binding.referencePaths.length > 0) return\n\t\t\t\tpath.remove();\n\t\t\t},\n            FunctionDeclaration(path){\n\t\t\t\tconst binding = path.scope.getBinding(path.node.id.name);\n\t\t\t\tif (!binding || binding.constantViolations.length > 0) return\n\n\t\t\t\tif (binding.referencePaths.length > 0) return\n\t\t\t\tpath.remove();\n\t\t\t}\n\t\t});\n\t}\n```\n\n同时还有一些无用代码块，比如\n\n```javascript\nfunction test() {\n  if (true) {\n    return '123'\n  } else {\n    return Math.floor(10 * Math.random())\n  }\n}\ntest()\n```\n\n第二条语句是绝对不会执行到的，那么就可以将其移除。虽然说代码编辑器会将其标暗，表示不会执行到，但在混淆中巴不得代码量少一下，所有还是有必要通过 AST 进行操作。\n\n```javascript\n\tremoveUnusedBlockStatement() {\n\t\ttraverse(this.ast, {\n\t\t\tIfStatement(path) {\n\t\t\t\tif (t.isBooleanLiteral(path.node.test)) {\n\t\t\t\t\tlet testValue = path.node.test.value\n\t\t\t\t\tif (testValue === true) {\n\t\t\t\t\t\tpath.replaceInline(path.node.consequent)\n\t\t\t\t\t} else if (testValue === false) {\n\t\t\t\t\t\tpath.replaceInline(path.node.alternate)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n```\n\n虽然说这种只针对 if 条件为 Boolean，如果条件为`if(1===1)`的情况也是可以，因为在前面还原中 计算二项式字面量，就已经将`if(1===1)` 替换成了 `if(true)`，所以这里只需要判断`isBooleanLiteral`即可。最终还原后的结果会将 if 代码块去除，同时保留 BlockStatement，代码如下\n\n```\nfunction test() {\n  {\n    return \"123\";\n  }\n}\n\ntest();\n```\n\n### 添加注释\n\n有些关键的代码会隐藏在 debugger，setTimeout，setInterval 等，在调试的时候都需要额外注意下是否有关键代码，所以这时候就可以添加一个注释来进行添加一个标签如 TOLOOK 来进行定位。具体根据要指定的标识符来定位，下列代码做为演示，将会在这些地方添加注释 // TOLOOK\n\n```javascript\naddComments() {\n\t\ttraverse(this.ast, {\n\t\t\tDebuggerStatement(path) {\n\t\t\t\tpath.addComment('leading', ' TOLOOK', true);\n\t\t\t},\n\t\t\tCallExpression(path) {\n\t\t\t\tif (!['setTimeout', 'setInterval'].includes(path.node.callee.name)) return;\n\t\t\t\tpath.addComment('leading', ' TOLOOK', true);\n\t\t\t},\n\t\t\tStringLiteral(path) {\n\t\t\t\tif (path.node.value === 'debugger') {\n\t\t\t\t\tpath.addComment('leading', ' TOLOOK', true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n```\n\n### 十六进制与 Unicode 编码转正常字符\n\n在一开始还原的时候就调用过这个方法，不过这里要特意在说一遍，因为这套混淆十六进制是最后处理，也就是说我们一开始直接使用还原是没问题的，但如果加密的字符串中存在十六进制编码字符，而这步操作确实在解密字符串前的话，那么可能就有部分字符串还是以十六进制形式显示，所有把这个方法特意放到较后文的地方，同时这个方法也可以最后调用。\n\n```javascript\nhexUnicodeToString() {\n\t\ttraverse(this.ast, {\n\t\t\tStringLiteral(path) {\n\t\t\t\tvar curNode = path.node;\n\t\t\t\tdelete curNode.extra;\n\t\t\t},\n\t\t\tNumericLiteral(path) {\n\t\t\t\tvar curNode = path.node;\n\t\t\t\tdelete curNode.extra;\n\t\t\t},\n\t\t});\n\t}\n```\n\n### 标识符优化\n\n大部分的混淆标识符都为\\_0x123456 这种，但有些却很另类，比如 OOOO0o 这种，相比前面这种更容易看花眼，很容易看错代码，那么就可以将标识符都统一重命名一下。\n\n```javascript\n\trenameIdentifier() {\n\t\tlet code = this.code\n\t\tlet newAst = parser.parse(code);\n\t\ttraverse(newAst, {\n\t\t\t'Program|FunctionExpression|FunctionDeclaration'(path) {\n\t\t\t\tpath.traverse({\n\t\t\t\t\tIdentifier(p) {\n\t\t\t\t\t\tpath.scope.rename(p.node.name, path.scope.generateUidIdentifier('_0xabc').name);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\t\tthis.ast = newAst;\n\t}\n```\n\n但想知道源代码的标识符是根本不可能的，所以就无法通过代码语义来理解代码了。\n\n不过还有一些可以特定的替换，比如 for i\n\n```javascript\nfor (var _0x1e5665 = 0, _0x3620b9 = this['JIyEgF']['length']; _0x1e5665 < _0x3620b9; _0x1e5665++) {\n  this['JIyEgF']['push'](Math['round'](Math['random']()))\n  _0x3620b9 = this['JIyEgF']['length']\n}\n```\n\n像这种代码，就完全可以将`_0x1e5665`替换成`i`，不过对整体阅读影响基本不大。\n\n### 其他还原手段\n\n还有一些还原的手段就不细说了（这里例子中并未用到），比如说\n\n- 形参改为实参\n- 还原 switch 执行流程\n- 处理对象花指令\n- 处理 eval 代码\n\n等等，总之你想咋优化都完全可以优化，但还原完的代码就不一定能看懂了。与解密字符串那个相比，如果搞不定字符串解密，那这些都是徒劳。\n\n具体的实例可通过 [源码例子](https://github.com/kuizuo/js-de-obfuscator/tree/main/example/deobfuscator) 中查看对 AST 的操作。\n\n## 运行还原后的代码\n\n最终整个还原后的代码可以在`newCode.js`中查看，但到目前为止还没有测试还原后的代码到底能否正常运行，或者是替换节点导致语法错误，所有就需要将还原后的代码与混淆过的代码替换运行这样才能测试的出来。这里就不放具体执行过程了（因为真的懒得在处理这个 js 文件了。。。）\n\n## JS 混淆与还原的网站\n\n针对上述还原操作其实还不够明显，于是就编写了一个在线对 JS 代码混淆与还原的网站（主要针对还原）– [JS 代码混淆与还原 (kuizuo.cn)](https://deobfuscator.kuizuo.cn/)\n\n其实也就是对上述的还原代码进行封装成工具使用。"
    },
    {
      "id": "js-code-obfuscator",
      "metadata": {
        "permalink": "/js-code-obfuscator",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/JS代码之混淆.md",
        "source": "@site/blog/develop/JS代码之混淆.md",
        "title": "JS代码之混淆",
        "description": "AST 在线解析 AST explorer",
        "date": "2021-12-21T00:00:00.000Z",
        "formattedDate": "2021年12月21日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "ast",
            "permalink": "/tags/ast"
          },
          {
            "label": "reverse",
            "permalink": "/tags/reverse"
          },
          {
            "label": "project",
            "permalink": "/tags/project"
          }
        ],
        "readingTime": 25.343333333333334,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "js-code-obfuscator",
          "title": "JS代码之混淆",
          "date": "2021-12-21T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript",
            "ast",
            "reverse",
            "project"
          ],
          "keywords": [
            "javascript",
            "ast",
            "reverse",
            "project"
          ]
        },
        "prevItem": {
          "title": "JS代码之还原",
          "permalink": "/js-code-deobfuscator"
        },
        "nextItem": {
          "title": "JS函数hook",
          "permalink": "/js-function-hook"
        }
      },
      "content": "<!-- truncate -->\n\n> AST 在线解析 [AST explorer](https://astexplorer.net/)\n>\n> js 在线混淆工具 [JavaScript Obfuscator Tool](https://www.obfuscator.io/)\n>\n> 书籍 《反爬虫 AST 原理与还原混淆实战》\n>\n> 相关混淆代码 [kuizuo/js-de-obfuscator](https://github.com/kuizuo/js-de-obfuscator)\n>\n> 自写在线混淆与还原网站 [JS 代码混淆与还原 (kuizuo.cn)](http://deobfuscator.kuizuo.cn/)\n\n## 什么是 AST\n\n抽象语法树（Abstract Syntax Tree），简称 AST，初识 AST 是在一门网页逆向的课程，该课程讲述了 js 代码中混淆与还原的对抗，而所使用的技术便是 AST，通过 AST 能很轻松的将 js 源代码混淆成难以辨别的代码。同样的，也可以通过 AST 将其混淆的代码 还原成执行逻辑相对正常的代码。\n\n例如下面的代码（目的是当天时间格式化）\n\n```javascript\nDate.prototype.format = function (formatStr) {\n  var str = formatStr\n  var Week = ['日', '一', '二', '三', '四', '五', '六']\n  str = str.replace(/yyyy|YYYY/, this.getFullYear())\n  str = str.replace(/MM/, (this.getMonth() + 1).toString().padStart(2, '0'))\n  str = str.replace(/dd|DD/, this.getDate().toString().padStart(2, '0'))\n  return str\n}\nconsole.log(new Date().format('yyyy-MM-dd'))\n```\n\n通过 AST 混淆的结果为\n\n```javascript\nconst OOOOOO = [\n  'eXl5eS1NTS1kZA==',\n  'RGF0ZQ==',\n  'cHJvdG90eXBl',\n  'Zm9ybWF0',\n  '5pel',\n  '5LiA',\n  '5LqM',\n  '5LiJ',\n  '5Zub',\n  '5LqU',\n  '5YWt',\n  'cmVwbGFjZQ==',\n  'Z2V0RnVsbFllYXI=',\n  'Z2V0TW9udGg=',\n  'dG9TdHJpbmc=',\n  'cGFkU3RhcnQ=',\n  'MA==',\n  'Z2V0RGF0ZQ==',\n  'bG9n',\n]\n\n;(function (OOOOOO, OOOOO0) {\n  var OOOOOo = function (OOOOO0) {\n    while (--OOOOO0) {\n      OOOOOO.push(OOOOOO.shift())\n    }\n  }\n\n  OOOOOo(++OOOOO0)\n})(OOOOOO, 115918 ^ 115930)\n\nwindow[atob(OOOOOO[694578 ^ 694578])][atob(OOOOOO[873625 ^ 873624])][atob(OOOOOO[219685 ^ 219687])] = function (OOOOO0) {\n  function OOOO00(OOOOOO, OOOOO0) {\n    return OOOOOO + OOOOO0\n  }\n\n  var OOOOOo = OOOOO0\n  var OOOO0O = [\n    atob(OOOOOO[945965 ^ 945966]),\n    atob(OOOOOO[298561 ^ 298565]),\n    atob(OOOOOO[535455 ^ 535450]),\n    atob(OOOOOO[193006 ^ 193000]),\n    atob(OOOOOO[577975 ^ 577968]),\n    atob(OOOOOO[428905 ^ 428897]),\n    atob(OOOOOO[629582 ^ 629575]),\n  ]\n  OOOOOo = OOOOOo[atob(OOOOOO[607437 ^ 607431])](/yyyy|YYYY/, this[atob(OOOOOO[799010 ^ 799017])]())\n  OOOOOo = OOOOOo[atob(OOOOOO[518363 ^ 518353])](\n    /MM/,\n    OOOO00(this[atob(OOOOOO[862531 ^ 862543])](), 671347 ^ 671346)\n      [atob(OOOOOO[822457 ^ 822452])]()\n      [atob(OOOOOO[974597 ^ 974603])](741860 ^ 741862, atob(OOOOOO[544174 ^ 544161])),\n  )\n  OOOOOo = OOOOOo[atob(OOOOOO[406915 ^ 406921])](\n    /dd|DD/,\n    this[atob(OOOOOO[596004 ^ 596020])]()\n      [atob(OOOOOO[705321 ^ 705316])]()\n      [atob(OOOOOO[419232 ^ 419246])](318456 ^ 318458, atob(OOOOOO[662337 ^ 662350])),\n  )\n  return OOOOOo\n}\n\nconsole[atob(OOOOOO[490983 ^ 490998])](new window[atob(OOOOOO[116866 ^ 116866])]()[atob(OOOOOO[386287 ^ 386285])](atob(OOOOOO[530189 ^ 530207])))\n```\n\n将上述代码复制到浏览器控制台内执行，将会输出当天的年月日。\n\n### AST 有什么用\n\n除了上述的混淆代码，很多文本编辑器中也会使用到，例如：\n\n- 编辑器的错误提示、代码格式化、代码高亮、代码自动补全；\n- `elint`、`pretiier` 对代码错误或风格的检查；\n- `webpack` 通过 `babel` 转译 `javascript` 语法；\n\n不过本篇并非介绍 AST 的基本概念，看本篇你只需要知道**如何通过 babel 编译器生成 AST 并完成上述的混淆操作**即可。\n\n### 有必要学 AST 吗\n\n如果作为 JS 开发者并且想要深入了解 V8 编译，那么 AST 基本是必修课之一，像 Vue,React 主流的前端框架都使用到 AST 对代码进行编译，在 ast 学习中定能让你对 JS 语法有一个更深入的了解。\n\n### AST 误区\n\nAST 本质上是静态分析，静态分析是在不需要执行代码的前提下对代码进行分析的处理过程，与动态分析不同，静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。即便你的程序也许在运行时报错，但都不会影响 AST 解析（除非语法错误），在 js 逆向中，通过静态分析还原出相对容易看的出的代码有对于代码分析，而对于一些需要知道某一变量执行后的结果静态分析是做不到的。\n\n## 环境安装\n\n首先需要 Node 环境，这就不介绍了，其次工具 Babel 编译器可通过 npm 安装\n\n```sh\nnpm i @babel/core -S-D\n```\n\n安装代码提示\n\n```sh\nnpm i @types/node @types/babel__traverse @types/babel__generator -D\n```\n\n新建 js 文件，导入相关模块（也可使用 ES module 导入），大致代码如下\n\n```javascript\nconst fs = require('fs')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst t = require('@babel/types')\nconst generator = require('@babel/generator').default\n\nlet jscode = fs.readFileSync(__dirname + \"/demo.js\", {\n\tencoding: \"utf-8\"\n})\n\n// 解析为AST\nlet ast = parser.parse(jscode)\n\n// 转化特征代码\ntraverse(ast, {\n\t...\n})\n\n// 生成转化后的代码\nlet code = generator(ast).code\n```\n\nbabel 的编译过程主要有三个阶段\n\n1. 解析(Parse): 将输入字符流解析为 AST 抽象语法树\n2. 转化(Transform): 对抽象语法树进一步转化\n3. 生成(Generate): 根据转化后的语法树生成目标代码\n\n## AST 的 API\n\n在进行编译前，首先需要了解 Babel 的一些相关 API，这边所选择的是 babel/parser 库作为解析，还有一个在线 ast 解析网站[AST explorer](https://astexplorer.net/) 能帮助我们有效的了解 AST 中的树结构。\n\n同时 Babel 手册(中文版) [babel-handbook](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md)强烈建议反复阅读，官方的例子远比我所描述来的详细。\n\n![image-20211212151620278](https://img.kuizuo.cn/image-20211212151620278.png)\n\n### 例子\n\n这边就举一个非常简单的例子，混淆变量名（或说标识符混淆）感受一下。引用网站代码例子\n\n```javascript\n/**\n * Paste or drop some JavaScript here and explore\n * the syntax tree created by chosen parser.\n * You can use all the cool new features from ES6\n * and even more. Enjoy!\n */\n\nlet tips = [\n  \"Click on any AST node with a '+' to expand it\",\n\n  'Hovering over a node highlights the \\\n   corresponding location in the source code',\n\n  'Shift click on an AST node to expand the whole subtree',\n]\n\nfunction printTips() {\n  tips.forEach((tip, i) => console.log(`Tip ${i}:` + tip))\n}\n```\n\n比如说，我要将这个 tips 标识符更改为`_0xabcdef` ，那么肯定是需要找到这个要 tips，在 Babel 中要找到这个则可以通过遍历特部位（如函数表达式，变量声明等等）。\n\n鼠标点击这个 tips 查看 tips 变量在树节点中的节点。\n\n![image-20211212170832228](https://img.kuizuo.cn/image-20211212170832228.png)\n\n这边可以看到有两个蓝色标记的节点，分别是`VariableDeclaration`和`VariabelDeclarator`，翻译过来便是变量声明与变量说明符，很显然整个`let tips = [ ]` 是`VariableDeclaration`，而`tips`则是`VariabelDeclarator`。\n\n所以要将`tips`更改为`_0xabcdef`就需要遍历`VariabelDeclarator`并判断属性`name`是否为`tips`，大致代码如下。**（后文代码将会省略模块引入、js 代码读取、解析与生成的代码）**\n\n```javascript\nconst fs = require('fs')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst t = require('@babel/types')\nconst generator = require('@babel/generator').default\n\nlet jscode = fs.readFileSync(__dirname + '/demo.js', { encoding: 'utf-8' })\nlet ast = parser.parse(jscode)\n\ntraverse(ast, {\n  VariableDeclarator(path) {\n    let name = path.node.id.name\n    if (name === 'tips') {\n      let binding = path.scope.getOwnBinding(name)\n      binding.scope.rename(name, '_0xabcdef')\n    }\n  },\n})\nlet code = generator(ast).code\n```\n\n生成的代码如下，成功的将`tips`更改为`_0xabcdef`，并且是`tips`的所有作用域（printTips 函数下）都成功替换了。\n\n```javascript\n/**\n * Paste or drop some JavaScript here and explore\n * the syntax tree created by chosen parser.\n * You can use all the cool new features from ES6\n * and even more. Enjoy!\n */\nlet _0xabcdef = [\"Click on any AST node with a '+' to expand it\", \"Hovering over a node highlights the \\\n   corresponding location in the source code\", \"Shift click on an AST node to\nexpand the whole subtree\"];\n\nfunction printTips() {\n  _0xabcdef.forEach((tip, i) => console.log(`Tip ${i}:` + tip));\n}\n```\n\n简单描述下上述代码的过程\n\n1、遍历所有`VariableDeclarator`节点，也就是`tips`变量说明符（标识符）\n\n2、获取当前遍历到的标识符的 name，也就是`path.node.id.name`，在树节点是对应的也是`id.name`\n\n3、判断 name 是否等于 tips，是的话，通过`path.scope.getOwnBinding(name)`，获取当前标识符（tips）的作用域，scope 的意思就是作用域，如果只是赋值操作的话如`path.node.id.name = '_0xabcdef'`，那只修改的`let tips =` 的 tips，而后面的对 tips 进行`forEach`操作的 tips 并不会更改，所以这里才需要使用`binding`来获取 tips 的作用域，并调用提供好的`rename`方法来进行更改。\n\n4、调用`binding.scope.rename(name, '_0xabcdef')`，将旧名字 name（tips）更改为\\_0xabcdef，就此整个遍历就结束，此时的 ast 已经发生了变化，所以只需要根据遍历过的 ast 生成代码便可得到修改后的代码。\n\n如果在仔细观察的话，其实`Identifier`（标识符）也是蓝色表示的，说明`Identifier`也同样可以遍历，甚至比上面的效果更好（后续替换所有的标识符也是遍历这个）\n\n```javascript {3-4}\ntraverse(ast, {\n  Identifier(path) {\n    let name = path.node.name\n    console.log(name)\n    if (name === 'tips') {\n      let binding = path.scope.getOwnBinding(name)\n      binding.scope.rename(name, '_0xabcdef')\n    }\n  },\n})\n```\n\n并尝试输出所有的标识符，输出的 name 结果为\n\n```\ntips\nprintTips\n_0xabcdef\nforEach\ntip\ni\nconsole\nlog\ni\ntip\n```\n\n这个例子也许有点啰嗦，但我认为是有必要的，同时想说的是某种混淆（还原）的实现往往可以有好几种方法遍历，会懂得融会贯通，AST 混淆与还原才能精通。\n\n### parser 与 generator\n\n前者用于将 js 代码解析成 AST，后者则是将 AST 转为 js 代码，两者的具体参数可通过 babel 手册查看，这就不做过多介绍了。\n\n[babel-handbook #babel-parser](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#babel-parser)\n\n[babel-handbook #babel-generator](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#babel-generator)\n\n### traverse 与 visitor\n\n整个 ast 混淆还原最关键的操作就是遍历，而 visitor 则是根据特定标识（函数声明，变量订阅）来进行遍历各个节点，而非无意义的全部遍历。\n\ntraverse 一共有两个参数，第一个就是 ast，第二个是 visitor，而 visitor 本质是一个对象如下(分别有 JavaScript 和 TypeScript 版本，区别就是在于这样定义的 visitor 是否有代码提示)\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs>\n  <TabItem value=\"js\" label=\"JS\" default>\n\n```javascript\nconst visitor = {\n  FunctionDeclaration(path) {\n    console.log(path.node.id.name) // 输出函数名\n  },\n}\n```\n\n</TabItem>\n<TabItem value=\"ts\" label=\"TS\">\n\n```tsx\nlet visitor: Visitor = {\n  FunctionDeclaration(path) {\n    console.log(path.node.id.name) // 输出函数名\n  },\n}\n```\n\n  </TabItem>\n</Tabs>\n\n一般来说，都是直接写到写到 traverse 内。个人推荐这种写法，因为能有 js 的代码提示，如果是 TypeScript 效果也一样。\n\n```javascript\ntraverse(ast, {\n  FunctionDeclaration(path) {\n    console.log(path.node.id.name) // 输出函数名\n  },\n})\n```\n\n如果我想遍历函数声明与二项式表达式的话，还可以这么写\n\n```javascript\ntraverse(ast, {\n  'FunctionDeclaration|BinaryExpression'(path) {\n    let node = path.node\n    if (t.isFunctionDeclaration(node)) {\n      console.log(node.id.name) // 输出函数名 printTips\n    } else if (t.isBinaryExpression(node)) {\n      console.log(node.operator) // 输出操作符 +\n    }\n  },\n})\n```\n\n不过要遍历不同类型的代码，那么对应的 node 属性肯定大不相同，其中这里使用了 t（也就是`@babel/types`库）来进行判断 node 节点是否为该属性，来进行不同的操作，后文会提到 types。\n\n上述操作将会输出 `printTips` 与 `+` 因为 printTips 函数中代码有 `Tip ${i}: + tip` ，这就是一个二项式表达式。\n\n此外 visitor 中的属性中，还对应两个生命周期函数 enter(进入节点)和 exit(退出节点)，可以在这两个周期内进行不同的处理操作，演示代码如下。\n\n```javascript\ntraverse(ast, {\n  FunctionDeclaration: {\n    enter(path) {\n      console.log('进入函数声明')\n    },\n    exit(path) {\n      console.log('退出函数声明')\n    },\n  },\n})\n```\n\n其中 enter 与 exit 还可以是一个数组（当然基本没怎么会用到），比如\n\n```javascript\ntraverse(ast, {\n  FunctionDeclaration: {\n    enter: [\n      (path) => {\n        console.log('1')\n      },\n      (path) => {\n        console.log('2')\n      },\n    ],\n  },\n})\n```\n\npath 对象下还有一种方法，针对当前 path 进行遍历 `path.traverse`，比如下面代码中，我遍历到了 printTips，我想输出函数内的箭头函数中的参数，那么就可以使用这种遍历。\n\n```javascript\nfunction printTips() {\n  tips.forEach((tip, i) => console.log(`Tip ${i}:` + tip))\n}\n```\n\n此时的 path.traverse 的第一个参数便不是 ast 对象了，而是一个 visitor 对象\n\n```javascript\ntraverse(ast, {\n  FunctionDeclaration(path) {\n    path.traverse({\n      ArrowFunctionExpression(path) {\n        console.log(path.node.params)\n      },\n    })\n  },\n})\n```\n\n输出的结果如下\n\n```\n[\n  Node {\n    type: 'Identifier',\n    start: 40,\n    end: 43,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'tip'\n    },\n    name: 'tip'\n  },\n  Node {\n    type: 'Identifier',\n    start: 45,\n    end: 46,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'i'\n    },\n    name: 'i'\n  }\n]\n```\n\n### types\n\n该库主要的作用是判断节点类型与生成新的节点。判断节点类型上面已经演示过了，比如判断 node 节点是否是为标识符`t.isIdentifier(path.node)`，等同于`path.node.type === \"Identifier\"`\n\n判断节点类型是很重要的一个环节，有时候混淆需要针对很多节点进行操作，但并不是每个节点都有相同的属性，判断节点才不会导致获取到的节点属性出错，甚至可以写下面的代码（将输出所有函数声明与箭头函数的参数）。\n\n```\ntraverse(ast, {\n  enter(path) {\n    t.isFunctionDeclaration(path.node) && console.log(path.node.params)\n    t.isArrowFunctionExpression(path.node) && console.log(path.node.params)\n  }\n})\n```\n\ntypes 的主要用途还是构造节点，或者说写一个 Builders（构建器），例如我要生成 `let a = 100` 这样的变量声明原始代码，通过 types 能轻松帮我们生成。\n\n不过先别急着敲代码，把`let a = 100`代码进行 ast 解析，看看每个代码的节点对应的 type 都是什么，这样才有助于生成该代码。\n\n![image-20211216131627955](https://img.kuizuo.cn/image-20211216131627955.png)\n\nbody 内的第一个节点便是我们整条的代码，输入`t.variableDeclaration()`，鼠标悬停在 variableDeclaration 上，或者按 Ctrl 跳转只.d.ts 类型声明文件 查看该方法所需几个参数\n\n```ts\ndeclare function variableDeclaration(kind: 'var' | 'let' | 'const', declarations: Array<VariableDeclarator>): VariableDeclaration\n```\n\n可以看到第一个参数就是关键字，而第二个则一个数组，其中节点为`VariableDeclarator`，关于`variableDeclaration`与 `VariableDeclarator` 在前面已经提及过一次了，就不在赘述了。由于我们这里只是声明一个变量 a，所有数组成员只给一个便可，如果要生成 b，c 这些变量，就传入对应的`VariableDeclarator`即可\n\n这时候在查看下 VariableDeclarator 方法参数\n\n```ts\ndeclare function variableDeclarator(id: LVal, init?: Expression | null): VariableDeclarator\n```\n\n第一个参数 id 很显然就是标识符了，不过这里的 id 不能简简单单传入一个字符串 a，而需要通过`t.identifier('a')`生成该节点，在上图中 id 就是对应`Identifier`节点。然后就是第二个参数了，一个表达式，其中这个`Expression`是 ts 中的联合类型（Union Types），可以看到有很多表达式\n\n```ts\ndeclare type Expression =\n  | ArrayExpression\n  | AssignmentExpression\n  | BinaryExpression\n  | CallExpression\n  | ConditionalExpression\n  | FunctionExpression\n  | Identifier\n  | StringLiteral\n  | NumericLiteral\n  | NullLiteral\n  | BooleanLiteral\n  | RegExpLiteral\n  | LogicalExpression\n  | MemberExpression\n  | NewExpression\n  | ObjectExpression\n  | SequenceExpression\n  | ParenthesizedExpression\n  | ThisExpression\n  | UnaryExpression\n  | UpdateExpression\n  | ArrowFunctionExpression\n  | ClassExpression\n  | MetaProperty\n  | Super\n  | TaggedTemplateExpression\n  | TemplateLiteral\n  | YieldExpression\n  | AwaitExpression\n  | Import\n  | BigIntLiteral\n  | OptionalMemberExpression\n  | OptionalCallExpression\n  | TypeCastExpression\n  | JSXElement\n  | JSXFragment\n  | BindExpression\n  | DoExpression\n  | RecordExpression\n  | TupleExpression\n  | DecimalLiteral\n  | ModuleExpression\n  | TopicReference\n  | PipelineTopicExpression\n  | PipelineBareFunction\n  | PipelinePrimaryTopicReference\n  | TSAsExpression\n  | TSTypeAssertion\n  | TSNonNullExpression\n```\n\n其中我们所要赋值的数值 100，对应的节点类型`NumericLiteral`也在其中。在查看 numericLiteral 中的参数，就只给一个数值，那么便传入 100。\n\n```\ndeclare function numericLiteral(value: number): NumericLiteral;\n```\n\n最后整个代码如下，将 t.variableDeclaration 结果赋值为一个变量`var_a`，这里的 var_a 便是一个 ast 对象，通过 generator(var_a).code 就可以获取到该 ast 的代码，也就是 `let a = 100;`，默认还会帮你添加分号\n\n```javascript\nlet var_a = t.variableDeclaration('let', [t.variableDeclarator(t.identifier('a'), t.numericLiteral(100))])\n\nlet code = generator(var_a).code\n// let a = 100;\n```\n\n这边再列举一个生成函数声明代码的例子（不做解读），要生成的代码如下\n\n```javascript\nfunction b(x, y) {\n  return x + y\n}\n```\n\ntypes 操作\n\n```javascript\nlet param_x = t.identifier('x')\nlet param_y = t.identifier('y')\nlet func_b = t.functionDeclaration(t.identifier('b'), [param_x, param_y], t.blockStatement([t.returnStatement(t.binaryExpression('+', param_x, param_y))]))\n\nlet code = generator(func_b).code\n```\n\n大致步骤可以总结成一下几点\n\n1、将要生成的 js 代码进行 ast Explorer 查看树结构，理清所要构造的代码节点（很重要）\n\n2、找到最顶层的结果，如 variableDeclaration，查看该代码所对应的参数\n\n3、进一步的分析内层节点结构，构造出最终的原始代码。\n\ntypes 还有一个方法`valueToNode`，先看演示\n\n```javascript\nlet arr_c = t.valueToNode([1, 2, 3, 4, 5])\nconsole.log(arr_c)\n\n{\n  type: 'ArrayExpression',\n  elements: [\n    { type: 'NumericLiteral', value: 1 },\n    { type: 'NumericLiteral', value: 2 },\n    { type: 'NumericLiteral', value: 3 },\n    { type: 'NumericLiteral', value: 4 },\n    { type: 'NumericLiteral', value: 5 }\n  ]\n}\n```\n\n如果使用`numericLiteral`来生成这些字面量的话那要写的话代码可能就要像下面这样\n\n```javascript\nlet arr_c = t.arrayExpression([t.numericLiteral(1), t.numericLiteral(2), t.numericLiteral(3), t.numericLiteral(4), t.numericLiteral(5)])\n```\n\n而`valueToNode`能很方便地生成各种基本类型，甚至是一些对象类型（RegExp，Object 等）。不过像函数这种就不行。\n\n```javascript\nt.valueToNode(function b(x, y) {\n  return x + y\n})\n// throw new Error(\"don't know how to turn this value into a node\");\n```\n\n写到着，其实不难发现，每个 node 节点其实就是一个 json 对象，而 types 只是将其封装好方法，供使用者调用，像下面这样方式定义 arr_c，同样也能生成数组 [1, 2, 3, 4, 5]\n\n```javascript\nlet arr_c = {\n  type: 'ArrayExpression',\n  elements: [\n    { type: 'NumericLiteral', value: 1 },\n    { type: 'NumericLiteral', value: 2 },\n    { type: 'NumericLiteral', value: 3 },\n    { type: 'NumericLiteral', value: 4 },\n    { type: 'NumericLiteral', value: 5 },\n  ],\n}\nlet code = generator(arr_c).code\n```\n\n至于生成其他的语句，原理与上述一致，篇幅有限不在做其他例子演示了，Babel 中的 API 很多，最主要的是懂得善用手册与代码提示，没有什么生成不了的语句，更没有还原不了的代码。\n\n### Path\n\n上述讲了基本的库操作，不难发现，使用到最多的还是 traverse，并且都会传入一个参数 path，并且`path.node`使用到的频率很多，能理解请两个的区别（Node 与 NodePath），基本上你想遍历到的地方就没有遍历不到的。\n\n先说说 path 能干嘛，能停止遍历当前节点 （`path.stop`），能跳过当前节点（`path.skip`），还可以获取父级 path（`path.parentPath` ），替换当前节点（`path.replaceWith`），移除当前节点（`path.remove`）等等。\n\n#### 获取 Node 节点属性\n\n**`path.node`** 也就是当前节点所在的 Node 对象，比如`loc`、`id`、`init`，`param`、`name`等，这些都是在 node 对象下都是能直接获取到的。\n\n不过获取到的是 node 对象，就无法使用 path 对象的方法了，如果要获取该属性的 path，就可以使用`path.get('name')`，获取到的就是 path 对象。不过对于一些特定的属性（name，operator）获取 path 对象就多此一举了。\n\n一共有两种类型 `Node` 与 `NodePath`，记住有`Path`则是`path`，如`path`就属于`NodePath`，而`path.node` 属于`Node`。\n\n![image-20211213021420326](https://img.kuizuo.cn/image-20211213021420326.png)\n\n#### 将节点转为代码\n\n有时候遍历到一系列的代码，想输出一下原始代码，那么有以下两种方式。\n\n```javascript\ntraverse(ast, {\n  FunctionDeclaration(path) {\n    console.log(generator(path.node).code)\n    console.log(path.toString())\n  },\n})\n```\n\n#### 替换节点属性\n\n与获取节点属性相同，比如我需要修改函数的第一个参数，那么我只要获取到第一个参数，并且将值赋值为我想修改值（node 对象）便可。\n\n```javascript\ntraverse(ast, {\n  FunctionDeclaration(path) {\n    path.node.params[0] = t.identifier('x')\n  },\n})\n```\n\n#### 替换整个节点\n\n替换的相关方法有\n\n`replaceWith` 一对一替换当前节点，且严格替换。\n\n```javascript\npath.replaceWith(t.valueToNode('kuizuo'))\n```\n\n`replaceWithMultiple` 则是一对多，将多个节点替换到一个节点上。\n\n```javascript\ntraverse(ast, {\n  ReturnStatement(path) {\n    path.replaceWithMultiple([t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('console'), t.identifier('log')), [t.stringLiteral('kuizuo')])), t.returnStatement()])\n    path.stop()\n  },\n})\n```\n\n要注意的是，替换节点要非常谨慎，就比如上述代码，如果我遍历 return 语句，同时我又替换成了 return 语句，替换后的节点同样是可以进入到遍历里，如果不进行停止，将会造成死循环，所以这里才使用了`path.stop`完全停止当前遍历，直到下一条 return 语句。\n\n`path.skip()`跳过遍历当前路径的子路径。`path.stop()`完全停止当前遍历\n\n`relaceInline` 接收一个参数，如果不为数组相当于`replaceWith`，如果是数组相当于`replaceWithMultiple`\n\n`replaceWithSoureString` 该方式将字符串源码与节点进行替换，例如\n\n```javascript\n// 要替换的函数\nfunction add(a, b) {\n  return a + b\n}\n\ntraverse(ast, {\n  FunctionDeclaration(path) {\n    path.replaceWithSourceString(`function mult(a, b){\n      return a * b\n    }`)\n    path.stop()\n  },\n})\n\n// 替换后的结果\n// (function mult(a, b) {\n//   return a * b;\n// });\n```\n\n#### 删除节点\n\n```javascript\ntraverse(ast, {\n  EmptyStatement(path) {\n    path.remove()\n  },\n})\n```\n\n`EmptyStatement`指空语句，也就是多余的分号。\n\n#### 插入节点\n\n`insertBefore`与`insertAfter`分别在当前节点前后插入语句\n\n```javascript\ntraverse(ast, {\n  ReturnStatement(path) {\n    path.insertBefore(t.expressionStatement(t.stringLiteral('before')))\n    path.insertAfter(t.expressionStatement(t.stringLiteral('after')))\n  },\n})\n```\n\n#### 父级 path\n\n**`path.parent`** 表示父级的 node\n\n**`path.parentPath`** 表示父级的 path，也就是 NodePath\n\n`path.parentPath.node` === `path.parent` 两者效果一样，都是获取 Node 对象。\n\n此外还有一些方法也可以获取父级 Path\n\n**`path.findParent`** 向上遍历每一个父级 Path 并根据条件返回，与数组 find 方式类型。\n\n```javascript\ntraverse(ast, {\n  BinaryExpression(path) {\n    let parent = path.findParent((p) => p.isFunctionDeclaration())\n    console.log(parent.toString())\n  },\n})\n```\n\n**`path.find`** 与 findParent 方式类似，不过 find 方法不包括当前节点，而 findParent 不包括。\n\n**`path.getFunctionParent`** 向上查找与当前节点最接近的父函数，返回的是 Path 对象。\n\n**`path.getStatementParent`** 遍历语法树，直到找到语句节点（带有 Statement），如 return 语句（ReturnStatement），if 语句（IfStatement），块级语句（BlockStatement）\n\n#### 同级 path\n\npath 有一个属性 container，表示当前节点所处于的那个节点下，共有那些同级节点，而 listKey 表示容器名。key 表示索引或是是容器对象的属性名\n\n```javascript\ntraverse(ast, {\n  ReturnStatement(path) {\n    console.log(path.key)\n    console.log(path.listKey)\n    console.log(path.container)\n  },\n})\n```\n\n```javascript\n// 输出结果\n0\nbody\n[\n  Node {\n    type: 'ReturnStatement',\n    start: 24,\n    end: 36,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: undefined\n    },\n    argument: Node {\n      type: 'BinaryExpression',\n      start: 31,\n      end: 36,\n      loc: [SourceLocation],\n      left: [Node],\n      operator: '+',\n      right: [Node]\n    }\n  }\n]\n```\n\n在 ast 树结构中框中所表示\n\n![image-20211216200502122](https://img.kuizuo.cn/image-20211216200502122.png)\n\n也并不是说所有节点都有同级节点，也并不是所有的 container 都是一个数组，例如下面这个例子\n\n```javascript\nlet obj = {\n  name: 'kuizuo',\n}\n```\n\n```javascript\n\ninit\nundefined\nNode {\n  type: 'VariableDeclarator',\n  start: 4,\n  end: 30,\n  loc: SourceLocation {\n    start: Position { line: 1, column: 4 },\n    end: Position { line: 3, column: 1 },\n    filename: undefined,\n    identifierName: undefined\n  },\n  id: Node {\n    type: 'Identifier',\n    start: 4,\n    end: 7,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'obj'\n    },\n    name: 'obj'\n  },\n  init: Node {\n    type: 'ObjectExpression',\n    start: 10,\n    end: 30,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: undefined\n    },\n    properties: [ [Node] ]\n  }\n}\n```\n\n对应 AST 树结构中所框选\n\n![image-20211216201242257](https://img.kuizuo.cn/image-20211216201242257.png)\n\n也就是说该节点并没有同级节点\n\n其中关于同级节点有以下几种方法。\n\n`path.inList` 判断 container 属性是否为数组\n\n`path.getSibling(index)` 获取当前节点所在容器中索引对应的同级节点，index 可通过 path.key 获取。\n\n其中还有`unshiftContainer`与`pushContainer`，在容器前与后添加节点，与`Array.unshift`和`Array.push`方法类似，不过基本没怎么用过，便不做实例了。\n\n### Scope\n\n**`path.scope`** 字面名意思为作用域，可以方便查找标识符的引用。如当前变量的哪里被调用了，标识符为参数还是变量。\n\n演示代码\n\n```javascript\nfunction test() {\n  let obj = {\n    name: 'kuizuo',\n  }\n  return obj\n}\n```\n\n#### 获取标识符代码块\n\n`scope.block` 返回 Node 对象，使用方法分为两种情况，变量与函数。\n\n```javascript\ntraverse(ast, {\n  ObjectExpression(path) {\n    let block = path.scope.block\n    console.log(generator(block).code)\n  },\n})\n\n// function test() {\n//   let obj = {\n//     name: 'kuizuo'\n//   };\n//   return obj;\n// }\n```\n\n返回的是整个函数体代码\n\n```javascript\ntraverse(ast, {\n  ObjectExpression(path) {\n    let block = path.scope.block\n    console.log(generator(block).code)\n  },\n})\n\n// function test() {\n//   let obj = {\n//     name: 'kuizuo'\n//   };\n//   return obj;\n// }\n```\n\n由于`scope.block`返回的是 Node 对象，将就无法使用 path.toString()转为原始代码了。\n\n#### binding\n\n**`scope.getBinding()`** 接收一个参数，可用于获取标识符的绑定，这里的 binding 可能会有些抽象，在一开始的例子中初次接触到\n\n```javascript\ntraverse(ast, {\n  VariableDeclarator(path) {\n    let name = path.node.id.name\n    if (name === 'tips') {\n      let binding = path.scope.getOwnBinding(name)\n      console.log(binding)\n      binding.scope.rename(name, '_0xabcdef')\n    }\n  },\n})\n```\n\n其中这里的 binding 是属性相对较多，下面会一一介绍\n\n```javascript\nBinding {\n  identifier: Node {type: 'Identifier', name: 'tips'},\n  scope: <ref *1> Scope {\n  path: NodePath {...},\n  kind: 'let',\n  constantViolations: [],\n  constant: true,\n  referencePaths: [\n    NodePath {...}\n  ],\n  referenced: true,\n  references: 1,\n  hasDeoptedValue: false,\n  hasValue: false,\n  value: null\n}\n```\n\n要注意的是，getBinding 中传的值必须是当前节点能够引用到的标识符，如果当前标识符不存在，那么返回 undefined。\n\nidentifier 是标识符 tips 的 Node 的对象，path 则是标识符 Path 对象，constant 为布尔值，表示当前标识符是否为常量，referenced 表示当前节点是否被引用。references 表示引用的次数。\n\nbinding 中的 scope 等同于 path 中的 scope，作用域范围相同。\n\n**`scope.getOwnBinding()`** 获取当前节点下的绑定，不包含其他父级中定义的标识符，会包含子函数中定义的标识符绑定。\n\n#### referencePaths 与 constantViolations\n\n假如标识符被引用，referencePaths 中会存放所有引用该标识的 path 对象数组。像下面这样\n\n```javascript\nreferencePaths: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Node],\n      listKey: undefined,\n      key: 'object',\n      node: [Node],\n      type: 'Identifier',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n```\n\n而 constantViolations 则是存放所有修改标识符的 Path 对象。\n\n#### 标识符重命名\n\n这在一开始的例子中就简单介绍过了，使用的是 rename 方法，能将该标识符中所有引用的地方重命名，不过上面的例子只是重命名 tips，想要重命名所有标识符的话，就需要遍历 Identifier。不过重命名标识符不能都重命名为相同字符，有一个 api `path.scope.generateUidIdentifier` 用于生成唯一不重复标识符。\n\n```javascript\ntraverse(ast, {\n  Identifier(path) {\n    path.scope.rename(path.node.name, path.scope.generateUidIdentifier('_0xabcdef').name)\n  },\n})\n```\n\n最终生成的代码如下\n\n```javascript\n**\n * Paste or drop some JavaScript here and explore\n * the syntax tree created by chosen parser.\n * You can use all the cool new features from ES6\n * and even more. Enjoy!\n */\nlet _0xabcdef11 = [\"Click on any AST node with a '+' to expand it\", \"Hovering over a node highlights the \\\n   corresponding location in the source code\", \"Shift click on an AST node to expand the whole subtree\"];\n\nfunction _0xabcdef2() {\n  _0xabcdef11.forEach((_0xabcdef10, _0xabcdef9) => console.log(`Tip ${_0xabcdef9}:` + _0xabcdef10));\n}\n```\n\n`scope.hasBinding('a')` 查询是否有标识符 a 的绑定\n\n`scope.getAllBindings()` 获取当前节点下所有绑定，返回一个对象，以标识符名作为属性名，值为 binding。\n\n`scope.hasReference('a')` 查询当前节点是否有标识符 a 的引用。\n\n当然大部分的 api 还需要自行翻阅文档，或通过代码提示与动态调试查看方法，举一反三，来达到所想要的目的。\n\n## 混淆实战\n\n关于混淆实战的代码都已贴到 Github[kuizuo/AST-obfuscator](https://github.com/kuizuo/AST-obfuscator)，在`src/obfuscated`中便可看到完整的混淆程序。其中也包括一些实战还原的例子，大部分的写法都采用了 ES6 的类来写，方便编写理解。\n\n大部分混淆的例子在这本书《反爬虫 AST 原理与还原混淆实战》中都有，例如常量混淆，数组混淆与乱序，标识符混淆等等就不细说了，上传的代码中有，不过书中有一些 es6 的代码是没提及到的。\n\n### 模板字符串\n\n与`StringLiteral`不同，模板字符串的 type 是`TemplateLiteral`，所以是遍历不到模板字符串的。下文将用代码来实现将模板字符串转为字符串拼接\n\n演示代码\n\n```javascript\nlet a = 'kuizuo'\n;`${a}nb${12}3${'456'}`\n```\n\n分析 AST 树结构\n\n![image-20211217161958075](https://img.kuizuo.cn/image-20211217161958075.png)\n\n不难观察出，parser 将其成两部分`expressions`与`quasis`。而所要转为的最终代码应该是`'' + a + 'nb' + 12 + '3' + '456'+ ''`，并且`quasis`成员个数始终比`expressions`多一位，所以只需要将`expressions`插入置`quasis`成员内，然后通过 binaryExpression 进行拼接即可。大致的思路有了，那么就开始用代码来进行拼接。\n\n```javascript\ntraverse(ast, {\n  TemplateLiteral(path) {\n    let { expressions, quasis } = path.node\n    // 将expressions节点逐个插入到quasis节点上\n    for (const i in expressions) {\n      let e = expressions[i]\n      quasis.splice(i * 2 + 1, 0, e)\n    }\n    let newExpressions = quasis\n\n    // 循环新的表达式节点构造出二项式表达式\n    let binary\n    for (let i = 0; i < newExpressions.length; i++) {\n      let left = binary\n      let right = newExpressions[i]\n      if (i === 0) {\n        left = t.valueToNode(right.value.raw)\n        binary = left\n        continue\n      }\n\n      if (t.isTemplateElement(right)) {\n        // if (right.value.raw === '') continue\n        right = t.valueToNode(right.value.raw)\n      }\n      binary = t.binaryExpression('+', left, right)\n    }\n    path.replaceWith(binary)\n  },\n})\n```\n\n最终输出 `\"\" + a + \"nb\" + 12 + \"3\" + \"456\" + \"\"`\n\n### 类声明\n\n同样，类名与类方法名同样也是可以混淆的，演示代码如下\n\n```javascript\nclass Test {\n  age = 20\n  constructor(name) {\n    this.name = name\n  }\n\n  run() {\n    return this.name + this.age\n  }\n}\n\nlet test = new Test('kuizuo')\nconsole.log(test.run())\n```\n\n复制上述代码，观察 AST 树结构（图就不放了）\n\n不难发现，其实就是 type `ClassDeclaration`、`ClassProperty`、`ClassMethod`，通过标识符混淆的方法`renameIdentifier`，将`Program|FunctionExpression|FunctionDeclaration`新增这两个 type 即可\n\n```javascript\ntraverse(ast, {\n  'Program|FunctionExpression|FunctionDeclaration|ClassDeclaration|ClassProperty|ClassMethod'(path) {\n    renameOwnBinding(path)\n  },\n})\n```\n\n但混淆完的代码并没有把属性名与方法名给混淆到\n\n```javascript\nclass OOOOO0 {\n  age = 399100 ^ 399080\n\n  constructor(OOOOO0) {\n    this[atob(OOOOOO[226019 ^ 226019])] = OOOOO0\n  }\n\n  run() {\n    return this[atob(OOOOOO[255772 ^ 255772])] + this[atob(OOOOOO[982314 ^ 982315])]\n  }\n}\n```\n\n不过这样混淆肯定远远不够的，方法可是类中很重要的属性，同时类方法与属性还能这么编写（constructor 不行），然后将下面的代码通过混淆程序执行一遍就能成功混淆变量名。\n\n```javascript\nclass Test {\n  ['age'] = 20\n  constructor(name) {\n    this.name = name\n  }\n\n  ['run']() {\n    return this.name + this.age\n  }\n}\n```\n\n所以将`run()` 转为`[‘run’]()`便成为了关键。而实现起来也相对简单（与改变对象访问方式一样）\n\n```javascript\ntraverse(ast, {\n  'ClassProperty|ClassMethod'(path) {\n    if (t.isIdentifier(path.node.key)) {\n      let name = path.node.key.name\n      if (name === 'constructor') return\n      path.node.key = t.stringLiteral(name)\n    }\n    path.node.computed = true\n  },\n})\n```\n\n最终运行混淆程序，执行混淆后的代码，成功输出`kuizuo20`\n\n---\n\n后续有时间再补充。。。\n\n## 混淆心得\n\n### 混淆前提\n\n**不改变原有代码的执行过程与结果**，并不是随便混淆都行了，比如`let c = a + b` ，总不能混淆成 `let OO = Oo - oO`吧。其次要懂得利用 js 语法的特性来进行混淆，比如高阶函数，函数传参，jsfuck 等等。\n\n### 混淆并非万能\n\n混淆始终是混淆，只是将代码相对变得难以阅读，但不代表不可阅读。只要程序能运行，那么我就能调试，能调试还能有什么解决不了的（毕竟 bug 都是调试出来）。如果真想保全你的代码，那我的建议是编译成二进制文件，或采用远程调用的形式将执行后的结果返回。\n\n### 代码执行效率\n\n通常来说，混淆会使你的代码数量增大至 2,3 倍，与加密壳同理，但程序的执行速度也会稍慢下，当然只要不是特别 ex 的混淆，如将函数调用封装至，3,4 层的调用导致调用堆栈过大，那么这种执行效率基本可以忽略不计。\n\n### 有混淆就有还原\n\n既然混淆是通过 AST 来进行混淆的，那么还原也同样可以，不过还原就不可能还原出原始开发者所编写的，就如同一些打包工具打包后的代码，比如将 name 压缩成 n，age 压缩成 a，那么就无法推断出 n 为 name，a 为 age，而混淆也是同理，像代码`let OOOOOO = atob('a3VpenVv')`，能还原的也只能是`let OOOOOO = ‘kuizuo’`或者是将标识符重新命名`let _0x123456 = ‘kuizuo’`，相对好看些。大部分的还原工作都只是将代码变得好读一些，比如`atob('a3VpenVv')`就可以变为`‘kuizuo’`，这便是基本的还原之一，关于还原还会另出一篇文章来记录，就不在这多废笔舌了。\n\n整个混淆的过程来看，无非就是多了门技能，对 js 有了更进一步的了解，略懂 js 编译过程中的语法分析，此外也感叹 Babel 提供如此强大的 api。同时也能尝试使用最新的 ECMAScript 语法特性，无需考虑兼容问题，babel 统统都能处理。就如同 babel 官网所说的：\n\n**现在就开始使用下一代 JavaScript 语法吧**。"
    },
    {
      "id": "js-function-hook",
      "metadata": {
        "permalink": "/js-function-hook",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/JS函数hook.md",
        "source": "@site/blog/develop/JS函数hook.md",
        "title": "JS函数hook",
        "description": "前言",
        "date": "2021-11-22T00:00:00.000Z",
        "formattedDate": "2021年11月22日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "hook",
            "permalink": "/tags/hook"
          }
        ],
        "readingTime": 4.166666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "js-function-hook",
          "title": "JS函数hook",
          "date": "2021-11-22T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript",
            "hook"
          ],
          "keywords": [
            "javascript",
            "hook"
          ]
        },
        "prevItem": {
          "title": "JS代码之混淆",
          "permalink": "/js-code-obfuscator"
        },
        "nextItem": {
          "title": "RPC远程调用浏览器函数",
          "permalink": "/remote-call-browser-function"
        }
      },
      "content": "<!-- truncate -->\n\n## 前言\n\n我在阅读《JavaScript 设计模式与开发实践》的第 15 章 装饰者模式，突然发现 JS 逆向中 hook 函数和 js 中的装饰者模式有点像，仔细阅读完全篇后更是对装饰器与 hook 有了更深的理解于是便有了这篇文章来记录一下该操作。\n\nhook 直译的意思为钩子，在逆向领域通常用来针对某些参数，变量进行侦听，打印输出，替换等操作。\n\n## 正文\n\n### 示例代码\n\n```javascript\nfunction add(a, b) {\n  return a + b\n}\n```\n\n### hook 代码\n\n这是一个很简单加法函数，通过 Hook 能获取到这两个参数的值，相当于在 return 之前添加了一句代码`console.log(a,b)`，这样便能输出这两个的值便于分析。那么可以使用如下的方式来复写改函数，而这个方式在 javascript 也就是装饰者模式\n\n```javascript\nlet _add = add\nadd = function () {\n  console.log('arguments', arguments)\n  let result = _add.apply(this, arguments)\n  console.log('result', result)\n  return result // 如果不需要result 则可直接return _add()\n}\n```\n\n**完整代码**\n\n```javascript\nfunction add(a, b) {\n  return a + b\n}\n\nlet _add = add\nadd = function () {\n  console.log('arguments', arguments)\n  let result = _add.apply(this, arguments)\n  console.log('result', result)\n  return result\n}\n\nadd(1, 2)\n```\n\n再次调用`add(1,2)`便会输出 arguments 参数以及结果 3，一个很简单 HOOK 就实现了。\n\n不过这个例子可能过于简单，我所要表达的意思是，通过 Hook，定位到我们想 Hook 的函数与变量，通过一系列操作（函数复写，元编程），只要触发该函数或使用（取值，修改）该变量，便能将我们想要的结果（前后的结果（如 加密前，加密后））获取到。这才是我们的目的。\n\n书中给的例子想说明的，想为某个原函数(比如这里的 add)添加一些功能，但该原函数可能是由其他开发者所编写的，那么直接修改原函数本身将可能导致未知 BUG，于是便可以用上面的方式进行复写原函数的同时，还不破坏原函数。\n\n### this 指向问题\n\n但并不是什么函数都能这样操作，或者说这样操作会导致原本函数可能执行不了，比如 this 指向，虽说没有修改原函数，但是原函数的 this 已经给我们更改成当前环境下（如`window`），但有些函数比如`document.getElementById()` 的内部`this`指向为`document`，不妨尝试将下面代码直接复制到控制台中查看会报什么错\n\n```javascript\nlet _getElementById = document.getElementById\ngetElementById = function (id) {\n  console.log(1)\n  return _getElementById(id)\n}\n\nlet div = getElementById('div')\n```\n\n**报错:**\n\n```\nUncaught TypeError: Illegal invocation\n    at getElementById (<anonymous>:4:9)\n    at <anonymous>:7:11\n```\n\n**解决办法:**\n\n只需要将 this 指向设置为 document 即可，代码改写如下\n\n```javascript\nlet _getElementById = document.getElementById\ngetElementById = function () {\n  console.log(1)\n  return _getElementById.apply(document, arguments)\n}\n\nlet div = getElementById('div')\n```\n\n但这样做略显麻烦，且有些函数你可能都不知道 this 的指向，但又想要复写该函数，书中也提及到用 **AOP 装饰函数**\n\n### 用 AOP 装饰函数\n\n先给出 `Function.prototype.before` 和 `Function.prototype.after`方法\n\n```javascript\nFunction.prototype.before = function (beforefn) {\n  let __self = this\n  return function () {\n    beforefn.apply(this, arguments)\n    return __self.apply(this.arguments)\n  }\n}\n\nFunction.prototype.after = function (afterfn) {\n  let __self = this\n  return function () {\n    let ret = __self.apply(this, arguments)\n    afterfn.apply(this, [ret])\n    return ret\n  }\n}\n```\n\n注：这里 after 与书中略有不同，书中的是将`arguments` 传入`afterfn.apply(this, arguments)`，而我的做法则是将运行后的结果传入 `afterfn.apply(this, [ret])`\n\n那么将我们一开始的加法例子便可以替换为\n\n```javascript\nfunction add(a, b) {\n  return a + b\n}\n\nadd = add\n  .before(function () {\n    console.log('arguments', arguments)\n  })\n  .after(function (result) {\n    console.log('result', result)\n  })\n// 切记 这里不能写箭头函数 不然会指向的不是执行中的this 而是代码环境下的this\n\nadd(1, 2)\n\n// arguments Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n// result 3\n```\n\n:::danger\n注：这种装饰方式叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一定的影响\n:::\n但该方法是直接修改原型方法，有些不喜欢污染原型的方式（用原型方式是真的好写），那么做一些变通，将原函数和新函数作为参数传入，代码如下\n\n```javascript\nlet before = function (fn, beforefn) {\n  return function () {\n    beforefn.apply(this, arguments)\n    return fn.apply(this, arguments)\n  }\n}\n```\n\nadd 函数修改如下\n\n```javascript\nadd = before(add, function () {\n  console.log('arguments', arguments)\n})\n\nadd(1, 2)\n```\n\n同样也能达到所要的目的。\n\n## 写后感\n\n```javascript\nadd = function () {\n  console.log('arguments', arguments)\n  let result = _add.apply(this, arguments)\n  console.log('result', result)\n  return result\n}\n```\n\n```javascript\nadd = add\n  .before(function () {\n    console.log('arguments', arguments)\n  })\n  .after(function (result) {\n    console.log('result', result)\n  })\n```\n\n对比两者方法，前者是对函数进行替换，而后者通过函数原型链将参数与结果通过回调函数的形式进行使用。在不考虑 this 指向，我个人更偏向第一种写法，而第二种写法也确实让我眼前一亮，很巧妙的使用 js 的原型链，从而避免 this 指向的问题。"
    },
    {
      "id": "remote-call-browser-function",
      "metadata": {
        "permalink": "/remote-call-browser-function",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/RPC远程调用浏览器函数.md",
        "source": "@site/blog/develop/RPC远程调用浏览器函数.md",
        "title": "RPC远程调用浏览器函数",
        "description": "早闻 RPC（Remote Procedure Call）远程过程调用，这一词了，应该是在安卓逆向的时候听闻的，当时吹嘘的意思是这样的，通过另一个远端服务器来调用安卓代码中的函数，并将执行后的结果返回。比如有一个加密算法，如果要实现脱机（脱离当前环境）运行的话，就需要扣除相对应的代码，补齐对应的环境（模块，上下文，语言），然而要在补齐该加密算法的环境可不好实现，而通过 RPC 则可以免除扣代码，通过数据通信来达到远程调用的目的，听起来是挺牛逼的，实际上也确实挺骚的。这里我将以浏览器与本地搭建一个 websocket 来实现调用浏览器内的函数。",
        "date": "2021-10-09T00:00:00.000Z",
        "formattedDate": "2021年10月9日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "rpc",
            "permalink": "/tags/rpc"
          },
          {
            "label": "browser",
            "permalink": "/tags/browser"
          }
        ],
        "readingTime": 9.496666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "remote-call-browser-function",
          "title": "RPC远程调用浏览器函数",
          "date": "2021-10-09T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript",
            "rpc",
            "browser"
          ],
          "keywords": [
            "javascript",
            "rpc",
            "browser"
          ]
        },
        "prevItem": {
          "title": "JS函数hook",
          "permalink": "/js-function-hook"
        },
        "nextItem": {
          "title": "记 ThinkPHP 项目部署",
          "permalink": "/thinkphp-deploy"
        }
      },
      "content": "早闻 RPC（Remote Procedure Call）远程过程调用，这一词了，应该是在安卓逆向的时候听闻的，当时吹嘘的意思是这样的，通过另一个远端服务器来调用安卓代码中的函数，并将执行后的结果返回。比如有一个加密算法，如果要实现脱机（脱离当前环境）运行的话，就需要扣除相对应的代码，补齐对应的环境（模块，上下文，语言），然而要在补齐该加密算法的环境可不好实现，而通过 RPC 则可以免除扣代码，通过数据通信来达到远程调用的目的，听起来是挺牛逼的，实际上也确实挺骚的。这里我将以浏览器与本地搭建一个 websocket 来实现调用浏览器内的函数。\n\n<!-- truncate -->\n\n## 算法例子\n\n这里我所采用的是百度登录的密码加密算法，具体逆向实现就不细写了，借用视频教程[志远 2021 全新 js 逆向 RPC](https://www.bilibili.com/video/BV1Kh411r7uR?p=36)\n\n通过关键词`password:` 便可找到对应的加密地点，找到加密调用的函数所出现的位置（loginv5.js 8944 行），发现通过调用`e.RSA.encrypt(s)`（其中 s 为明文 `a123456`），便可得到加密后的结果。\n\n![image-20211008042148653](https://img.kuizuo.cn/image-20211008042148653.png)\n\n![image-20211008041300534](https://img.kuizuo.cn/image-20211008041300534.png)\n\n```\ne.RSA.encrypt(s)\n'Zhge9q9jkiMA0UTfHxwNeyafnuUG8rcAh/gKfQpZiOQq8EYI/tJO83lKr52c4Im3cew3wVcINf2jEGEqH5EimnMI3g6eOjcdqduGyqynA4JjMJ0wltGdL8VUTTJsknsHUQlJXHOm/7zqx4NaBvOzhWzdDBk5cAOJ2DXgPaqoygg='\n```\n\n按照往常的做法，需要将`e.RSA.encrypt(s)`所用的代码处单独抠出来，放在 V8 引擎上测试或使用现有的加密库 如 CryptoJS，找到对应的密钥来进行加密。不过这里使用 RPC 来实现该算法的调用。\n\n## 实现\n\n目前调用的环境有了（浏览器环境），只要我们这个浏览器不停止（使用无头浏览器运行），控制台便能一直输出我们想要的加密后结果。所以要实现的目的很简单，就是其他窗口（指其他语言所实现的程序），能远程调用`e.RSA.encrypt(s)`并将结果输出到其他窗口。\n\n那么就需要建立通信协议了，这里我所采用的是浏览器自带的 Websocket 客户端与 Nodejs 搭建的 Websocket 服务端来进行通信，众所周知 HTTP 请求是无法双向传输的。所以使用 websocket 这样服务端就可以主动向浏览器发送请求，同时 websocket 在当前这个环境下好实现。\n\n### Nodejs 实现 Websocket 服务端\n\n#### 安装 ws 模块\n\n```sh\nnpm install ws -S\nnpm install @types/ws -D\n```\n\n这里之所以选 ws，是因为 ws 对于 Websocket 协议而已，实现方便，且速度最快，并且浏览器可以通过`let ws = new Websocket()`来创建客户端直接连接，而使用 socket.io 的话，浏览器则需要载入 socket.io 客户端文件，繁琐。\n\n#### 代码例子\n\n```javascript title=\"server.js\"\nimport WebSocket, { WebSocketServer } from 'ws'\n\nlet ws = new WebSocketServer({\n  port: 8080,\n})\n\nws.on('connection', (socket) => {\n  function message(msg) {\n    console.log('接受到的msg: ' + msg)\n    socket.send('我接受到你的数据: ' + msg)\n  }\n\n  socket.on('message', message)\n})\n```\n\n使用 WebSocket 在线测试网站[websocket 在线测试 (websocket-test.com)](http://www.websocket-test.com/)\n\n测试结果如下\n\n![image-20211008043925753](https://img.kuizuo.cn/image-20211008043925753.png)\n\n上面代码写的很简陋，尤其是数据交互的地方，这里可以使用 json 来改进一下。像这样，至于为啥用 try 是防止 json 数据不对导致解析错误（具体代码就不解读了）\n\n```javascript title=\"server.js\"\nimport WebSocket, { WebSocketServer } from 'ws'\n\nlet ws = new WebSocketServer({ port: 8080 })\n\nws.on('connection', (socket) => {\n  console.log('有人连接了')\n  function message(data) {\n    try {\n      let json = JSON.parse(data) // data: {\"type\":\"callbackPasswordEnc\",\"value\":\"a123456\"}\n      let { type, value } = json\n      switch (type) {\n        case 'callbackPasswordEnc':\n          // doSomething()\n          console.log('得到的加密密文为:' + value)\n          break\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n\n  socket.on('message', message)\n\n  // 浏览器通信1秒后向浏览器调用加密算法\n  setTimeout(() => {\n    let jsonStr = JSON.stringify({\n      type: 'getPasswordEnc',\n      value: 'a123456',\n    })\n    socket.send(jsonStr)\n  }, 1000)\n})\n```\n\n### 浏览器实现 websocket\n\n既然要实现我们的代码，那么就需要将我们的代码注入到原来的代码上，这里我使用的是 Chrome 的开发者工具中的覆盖功能，选择一个本地文件夹，并允许权限。\n\n![image-20211008054918531](https://img.kuizuo.cn/image-20211008054918531.png)\n\n选择要替换代码的文件，选择保存以备替换（前提得开启覆盖）\n\n![image-20211008055032125](https://img.kuizuo.cn/image-20211008055032125.png)\n\n接着在覆盖中找到文件，找到加密的代码块，添加如下代码\n\n```javascript title=\"browser.js\"\n!(function () {\n  let url = 'ws://127.0.0.1:8080'\n  let ws = new WebSocket(url)\n\n  // 浏览器连接后告诉服务端是浏览器\n  ws.onopen = function (event) {\n    ws.send(JSON.stringify({ type: 'isBrowser', value: true }))\n  }\n\n  ws.onmessage = function (event) {\n    let json = JSON.parse(event.data)\n    let { type, value } = json\n    switch (type) {\n      case 'getPasswordEnc':\n        let passwordEnc = e.RSA.encrypt(value)\n        let jsonStr = JSON.stringify({\n          type: 'callbackPasswordEnc',\n          value: passwordEnc,\n        })\n        console.log(jsonStr)\n        ws.send(jsonStr)\n        break\n    }\n  }\n})()\n```\n\n![image-20211008201809446](https://img.kuizuo.cn/image-20211008201809446.png)\n\n然后就是最关键的地方了，触发加密函数，并将结果返回。触发加密函数只需要向浏览器发送指定数据`{\"type\":\"getPasswordEnc\",\"value\":\"a123456\"}`，浏览器接受到对应的类型与数据，便调用相应的函数，并将结果`{\"type\":\"callbackPasswordEnc\",\"value\":\"FM6SK3XiL5X0RF9NZi7qhIsu7Pd46mfKnn6YkWUNSGrJO+XXhiXyoG8huaqQW4BnmYuo0JVVQj28C+BK/r6NTNbLcV4gMSREB2hYU/oIYedCJsZ9sbZQ89p1aI9kVcDeRlXBhjNUxkcS9Rh+vKzyNApwpbPcAuGTCSZhKst8vVo=\"}`返回即可。\n\n服务端的效果如下图\n\n![image-20211008204247104](https://img.kuizuo.cn/image-20211008204247104.png)\n\n## 优化执行流程\n\n实现是实现了，但是代码貌似很不优雅，甚至有点别扭。按理来说因为是浏览器作为 websocket 服务端，我们作为客户端，客户端向服务器获取数据才合理，但在这里浏览器当不了 websocket 服务端这个角色，所以只能使用如此别扭的方式来调用。像上面例子的话，如果我的程序要实现一个某度登录的话，那么我这个程序就需要搭建一个 ws 服务器来进行两者的通信，有没有好的办法又不太依赖于 ws 服务端，就像 http 那样，程序只需要发送一个请求，给定类型和数值进行加密处理后返回即可。于是我处理的思路是这样的。\n\n## 思路\n\n我的做法是将 websocket 服务端当个中转站，而浏览器的 websocket 客户端作为一个加密算法的服务，再添加一个登录算法实现的客户端简称为用户调用的，所以现在一共有三份代码（websocket 服务端，浏览器端，用户调用端）。这里我还是以 nodejs 为例。\n\n### 浏览器端\n\n浏览器 websocket 客户端的代码，在初次连接的时候，告诉 websocket 服务端是不是浏览器。并将于浏览器连接的 socket 句柄存入全局对象，以便用户获取加密参数的时候向浏览器调用。\n\n```javascript title=\"browser.js\"\nws.onopen = function (event) {\n  ws.send(JSON.stringify({ type: 'isBrowser', value: true }))\n}\n```\n\n### 用户调用端\n\n```javascript title=\"client.js\"\nimport WebSocket from 'ws'\n\nasync function getPasswordEnc(password) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket('ws://127.0.0.1:8080')\n\n    ws.on('open', () => {\n      let jsonStr = JSON.stringify({\n        type: 'getPasswordEnc',\n        value: password,\n      })\n      ws.send(jsonStr)\n    })\n\n    ws.on('message', (message) => {\n      let json = JSON.parse(message)\n      let { type, value } = json\n      switch (type) {\n        case 'callbackPasswordEnc':\n          ws.close()\n          resolve(value)\n          break\n      }\n    })\n  })\n}\n\nasync function run() {\n  let passwordEnc = await getPasswordEnc('a123456')\n  console.log(passwordEnc)\n}\n\nrun()\n```\n\n这里对代码进行解读一下，我自行封装了一个函数，其中函数返回的是一个 Promise 对象，值则是对应的加密后的密文。如果我这边不采用 promise 来编写的话，那么获取到的数据将十分不好返回给我们的主线程。这里对于 js 的 Promise 使用需要花费点时间去理解。总而言之，通过 promise，以及 async await 语法糖，能很轻松的等待 websocket 连接与接收数据。但还是用 websocket 协议\n\n### websocket 服务端\n\n同时 websocket 服务端肯定要新增一个类型用于判断是登录算法实现的客户端。同时又新的用户要调用，所以这里使用了 uuid 这个模块来生成唯一的用户 id，同时还定义一个变量 clients 记录所连接过的用户（包括浏览器），完整代码如下\n\n```javascript title=\"server.js\"\nimport WebSocket, { WebSocketServer } from 'ws'\nimport { v4 as uuidv4 } from 'uuid'\n\nlet ws = new WebSocketServer({ port: 8080 })\n\nlet browserWebsocket = null\nlet clients = []\n\nws.on('connection', (socket) => {\n  let client_id = uuidv4()\n  clients.push({\n    id: client_id,\n    socket: socket,\n  })\n\n  socket.on('close', () => {\n    for (let i = 0; i < clients.length; i++) {\n      if (clients[i].id == client_id) {\n        clients.splice(i, 1)\n        break\n      }\n    }\n  })\n\n  socket.on('message', (message) => {\n    try {\n      let json = JSON.parse(message)\n      let { id, type, value } = json\n      switch (type) {\n        case 'isBrowser':\n          if (value) {\n            browserWebsocket = socket\n          }\n          console.log('浏览器已初始化')\n          break\n\n        // 发送给浏览器 让浏览器来调用并返回\n        case 'callbackPasswordEnc':\n          // 根据id找到调用用户的socket,并向该用户发送加密后的密文\n          let temp_socket = clients.find((c) => c.id == id).socket\n\n          temp_socket.send(message)\n          break\n        // 用户发送过来要加密的明文\n        case 'getPasswordEnc':\n          let jsonStr = JSON.stringify({\n            id: client_id,\n            type: type,\n            value: value,\n          })\n\n          // 这里一定要是浏览器的websocket句柄发送，才能调用\n          browserWebsocket.send(jsonStr)\n          break\n      }\n    } catch (error) {\n      console.log(error.message)\n    }\n  })\n})\n```\n\n最终演示效果如下视频（浏览器代码是提前注入进去的）\n\n<video width=\"800px\" height=\"450px\" controls=\"controls\" >\n<source id=\"mp4\" src=\"https://img.kuizuo.cn/rpc.mp4\" type=\"video/mp4\" />\n</video >\n\n其实还是一些是要完善的，这里的 Websocket 只是实现了连接，还有心跳包异常断开，浏览器异常关闭导致 websocket 断开无法调用函数等等，以及浏览器的代码还需要手动注入很不优化，后续如果使用 Chrome 插件开发一个实现注入 js 代码的功能也许会好一些。（正准备编写 Chrome 插件）\n\n## HTTP 协议调用实现\n\n但是，以上都是基于 WebSocket 协议，就连用户端调用也是，然而用户调用没必要保持长连接且不利于调用（相对一些语言而言），有没有能直接使用 http 协议，通过 POST 请求来实现获取参数，这才是我所要实现的。\n\n其实要实现也很简单，我只要把用户调用的 `getPasswordEnc` 这个函数 弄到 node 创建的一个 http 服务端就行了，我这里的做法也是如此。像下面这样\n\n```javascript title=\"server_http.js\"\nasync function getPasswordEnc(password) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket('ws://127.0.0.1:8080')\n\n    ws.on('open', () => {\n      let jsonStr = JSON.stringify({\n        type: 'getPasswordEnc',\n        value: password,\n      })\n      ws.send(jsonStr)\n    })\n\n    ws.on('message', (message) => {\n      let json = JSON.parse(message)\n      let { type, value } = json\n      switch (type) {\n        case 'callbackPasswordEnc':\n          ws.close()\n          resolve(value)\n          break\n      }\n    })\n  })\n}\n\n// 创建http服务\nconst app = http.createServer(async (request, response) => {\n  let { pathname, query } = url.parse(request.url, true)\n\n  if (pathname == '/getPasswordEnc') {\n    let passwordEnc = await getPasswordEnc(query.password)\n    response.end(passwordEnc)\n  }\n})\n\napp.listen(8000, () => {\n  console.log(`服务已运行 http://127.0.0.1:8000/`)\n})\n```\n\n发送 GET 请求 URL 为 http://127.0.0.1:8000/getPasswordEnc?password=a123456 实现效果如图\n\n![image-20211009040704534](https://img.kuizuo.cn/image-20211009040704534.png)\n\n对于用户调用来说相对友好了不少（其实是很好），不用在创建 websocket 客户端，只需要发送 HTTP 请求（GET 或 POST），不过我这边使用的是 Node 自带的 http 模块来搭建的一个 http 服务器，实际使用中将会采用 express 来编写路由提高开发效率和代码可读性，这里只是作为演示。\n\n至于说我为什么要在 http 内在新建一个 ws 客户端，主要原因还是 websocket 服务端向浏览器发送调用的算法，但只能在 websocket 服务端中的通过 onmessage 接受，无法在 http 服务端接受到，就别说向用户端返回了。这里其实只是不让用户来进行连接 websocket，而是我们本地（服务器）在接受到 getPasswordEnc 请求，复现了一遍上面用户连接 websocket 的例子，并将其转为 http 请求返回给用户而已。\n\n**其实也就是多了一个调用的 HTTP 服务器，而这里将 http 服务器与 websocket 服务器写到一起而已**\n\n## 代码地址\n\nhttps://github.com/kuizuo/rpc-browser.git\n\n运行方式请查看 README.md"
    },
    {
      "id": "thinkphp-deploy",
      "metadata": {
        "permalink": "/thinkphp-deploy",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/记ThinkPHP项目部署.md",
        "source": "@site/blog/program/记ThinkPHP项目部署.md",
        "title": "记 ThinkPHP 项目部署",
        "description": "事情背景",
        "date": "2021-09-25T00:00:00.000Z",
        "formattedDate": "2021年9月25日",
        "tags": [
          {
            "label": "php",
            "permalink": "/tags/php"
          },
          {
            "label": "develop",
            "permalink": "/tags/develop"
          }
        ],
        "readingTime": 3.526666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "thinkphp-deploy",
          "title": "记 ThinkPHP 项目部署",
          "date": "2021-09-25T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "php",
            "develop"
          ],
          "keywords": [
            "php",
            "develop"
          ]
        },
        "prevItem": {
          "title": "RPC远程调用浏览器函数",
          "permalink": "/remote-call-browser-function"
        },
        "nextItem": {
          "title": "使用JSONPath解析json数据",
          "permalink": "/use-jsonpath-to-parse-json-data"
        }
      },
      "content": "<!-- truncate -->\n\n## 事情背景\n\n用户花了几百块购买了一份 ThinkPHP 一个后台管理的网站源码，要求更换下部分失效接口，或是重写一个类似这样的网站。我想既然都有源码了，我改改不就完事了，这不比重写一个来的省事。虽说我不是主学 PHP 的，但至少我学过一丢丢的 PHP，接触过 ThinkPHP 项目的。不过层面都是局限在本地，部署到生产环境与本地还是有比较大的差别的，于是便有了这篇文章来记录一下自己部署 ThinkPHP 所遇到的一些坑。\n\n## Windows 部署\n\n也可理解为本地部署，本地部署就相对比较简单的了。不过需要一个工具，PHPStudy，来帮助我们配置本地的环境（Apache、Nginx、PHP、Mysql）\n\n[小皮面板(phpstudy) - 让天下没有难配的服务器环境！ (xp.cn)](https://www.xp.cn/)\n\n下载安装打开界面，选择网站，创建网站\n\n![image-20210925143601530](https://img.kuizuo.cn/image-20210925143601530.png)\n\n由于是本机，所以域名就填写 localhost 或 127.0.0.1，端口的话这边所填写的是 4200，别和其他端口冲突即可。\n\n由于 ThinkPHP 的根目录要选择的是根目录下的 public 目录，不然找不到 index.php 这个文件，所以这里根目录自己指定一下源码的位置，点击确认即可。\n\n### 初次启动 Not Found\n\n这时候访问 http://localhost:4200 提示如下\n\n![image-20210925143752775](https://img.kuizuo.cn/image-20210925143752775.png)\n\n本着不会就百度的原则，很快就找到了解决办法\n\n[ThinkPHP 报错 The requested URL /index/index/xxx.html was not found on this server](https://blog.csdn.net/qq_42940241/article/details/112461625)\n\n在入口文件夹 public 下查看.htaccess 是否存在。不存在则新建，存在的话，那内容替换为下面这串代码 就可以解决 Not Fund 问题\n\n```xml\n#<IfModule mod_rewrite.c>\n#  Options +FollowSymlinks -Multiviews\n#  RewriteEngine On\n#\n#  RewriteCond %{REQUEST_FILENAME} !-d\n#  RewriteCond %{REQUEST_FILENAME} !-f\n#  RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]\n#</IfModule>\n<IfModule mod_rewrite.c>\nRewriteEngine on\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L]\n</IfModule>\n```\n\n### 页面报错 开启 Debug\n\n上面配置完毕后，再次打开出现如下提示。\n\n![image-20210925144143248](https://img.kuizuo.cn/image-20210925144143248.png)\n\n遇到错误是很正常的，现在要做的就是输出报错信息，而不是简短的文字。到根目录下 config/app.php 中，将调试更改为 true（切记，生产环境中一定要更改为 false，不然用户就能查看报错详情以及对应代码）\n\n![image-20210925144424361](https://img.kuizuo.cn/image-20210925144424361.png)\n\n### 配置数据库\n\n再次访问页面提示\n\n**![image-20210925144620953](https://img.kuizuo.cn/image-20210925144620953.png)**\n\n报错信息倒是很全，不过要关注的是报错行和提示，大致意思就是没有定义数据库用户名 ml 以及密码，毕竟数据库啥的都好像没配置，要是能启动起来那估计就真是一个 bug 了，那就先找到配置文件，看看原本的账号密码是多少，数据库配置文件位置`config/database.php`\n\n![image-20210925145740851](https://img.kuizuo.cn/image-20210925145740851.png)\n\n不过 PHPstudy 用户名和密码长度都要在 6 位以上（Linux 倒是不用），所以勉为其难，把用户名和密码都改成 ml1234，接着 Mysql 导入源码给定的数据库文件(sql 文件)，什么，你说源码没有给数据库文件，那我建议直接删源码，并且接下来的内容也可以不用看了。\n\n数据库导入完毕后，再次访问便能看到正常的首页了，就此就算部署完毕了，这里就不放首页图了。\n\n## Linux 部署\n\nLinux 部署和 Windows 部署是有一丢丢差别的，这里我也列举一下，环境是 CentOS 7.6，安装了宝塔面板\n\n在宝塔面板出网站，添加网站，如同 PHPstudy，配置大致相同。\n\n![image-20210926050508693](https://img.kuizuo.cn/image-20210926050508693.png)\n\n### 关闭防跨站攻击\n\n情况 1，如图\n\n![image-20210925155027023](https://img.kuizuo.cn/image-20210925155027023.png)\n\n解决办法：点击网站，设置，将防跨站攻击关闭并保持，如下\n\n![image-20210925155445084](https://img.kuizuo.cn/image-20210925155445084.png)\n\n### 设置伪静态\n\n接着再次访问网站会出现 404 页面不存在报错，在设置中找到伪静态，添加一个 thinkphp 的配置，如下\n\n![image-20210925155705573](https://img.kuizuo.cn/image-20210925155705573.png)\n\n再次访问后，出现的就是数据库配置的问题，配置一下数据库，导入数据，然后再次访问便可。\n\n:::danger\n\n再次提醒，生产环境下，请将`app_debug`设置为 false，不然非法用户可以通过人为试错，查询对应报错代码。\n\n:::"
    },
    {
      "id": "use-jsonpath-to-parse-json-data",
      "metadata": {
        "permalink": "/use-jsonpath-to-parse-json-data",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/使用JSONPath解析json数据.md",
        "source": "@site/blog/develop/使用JSONPath解析json数据.md",
        "title": "使用JSONPath解析json数据",
        "description": "jsonpath 能够帮助我们快速的从json数据中提取想要的数据",
        "date": "2021-09-20T00:00:00.000Z",
        "formattedDate": "2021年9月20日",
        "tags": [
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "json",
            "permalink": "/tags/json"
          },
          {
            "label": "node",
            "permalink": "/tags/node"
          }
        ],
        "readingTime": 7.696666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "use-jsonpath-to-parse-json-data",
          "title": "使用JSONPath解析json数据",
          "date": "2021-09-20T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "javascript",
            "json",
            "node"
          ],
          "keywords": [
            "javascript",
            "json",
            "node"
          ],
          "description": "jsonpath 能够帮助我们快速的从json数据中提取想要的数据",
          "image": "/img/blog/jsonpath.png",
          "sticky": 3
        },
        "prevItem": {
          "title": "记 ThinkPHP 项目部署",
          "permalink": "/thinkphp-deploy"
        },
        "nextItem": {
          "title": "使用Vue开发Chrome插件",
          "permalink": "/vue-chrome-extension"
        }
      },
      "content": "之前学习爬虫的时候，如果是 HTML 的数据，通过 xpath 或是 css 选择器，就能很快的获取我们想要的数据，如果是 json 有没有类似 xpath 这种，能够直接根据条件定位数据，而不需要自行 json 解析在遍历获取。答案是有的，也就是 JSONPath。\n\n<!-- truncate -->\n\n在线测试网址 [JSONPath 在线验证](https://www.jsonpath.cn/)\n\n所选用的环境是 Node + JavaScript，用到 jsonpath 这个包 [jsonpath - npm (npmjs.com)](https://www.npmjs.com/package/jsonpath)\n\n> 参考链接 [JsonPath - 根据表达式路径解析 Json - 简书 (jianshu.com)](https://www.jianshu.com/p/8c0ade82891b)\n\n## 基本语法\n\n| JSONPath          | 描述                                                       |\n| ----------------- | ---------------------------------------------------------- |\n| $                 | 根对象或元素.                                              |\n| @                 | 当前对象或元素.                                            |\n| . or []           | 子元素操作符.                                              |\n| ..                | 递归匹配所有子元素.                                        |\n| \\*                | 通配符. 匹配所有对象或元素.                                |\n| []                | 下标运算符，JsonPath 索引从 0 开始.                        |\n| [,]               | 连接运算符，将多个结果拼成数组返回，JSONPath 允许使用别名. |\n| [start:end1:step] | 数组切片运算符.                                            |\n| ?()               | 过滤器（脚本）表达式.                                      |\n| ()                | 脚本表达式.                                                |\n| \\|\\|              | 表达式 或                                                  |\n| &&                | 表达式 且                                                  |\n\n### 过滤器表达式\n\n通常的表达式格式为：[?(@.age > 18)] 表示当前节点属性 age 大于 18\n\n| 操作符 | 描述                                                             |\n| ------ | ---------------------------------------------------------------- |\n| ==     | 等于符号，但数字 1 不等于字符 1(note that 1 is not equal to ‘1’) |\n| !=     | 不等于符号                                                       |\n| <      | 小于符号                                                         |\n| <=     | 小于等于符号                                                     |\n| >      | 大于符号                                                         |\n| >=     | 大于等于符号                                                     |\n| =~     | 判断是否符合正则表达式，例如[?(@.name =~ /foo.*?/i)]             |\n| in     | 所属符号，例如[?(@.size in [‘S’, ‘M’])]                          |\n| nin    | 排除符号                                                         |\n| size   | size of left (array or string) should match right                |\n| empty  | 判空 Null 符号                                                   |\n\n语法就这些，不过单单有语法，不实践肯定是不够的。下面就是一些官方简单例子操作，还有一个终极实战\n\n## 代码演示\n\n```js\nvar jp = require('jsonpath')\n\nvar cities = [\n  { name: 'London', population: 8615246 },\n  { name: 'Berlin', population: 3517424 },\n  { name: 'Madrid', population: 3165235 },\n  { name: 'Rome', population: 2870528 },\n]\n\nvar names = jp.query(cities, '$..name')\n\n// [ \"London\", \"Berlin\", \"Madrid\", \"Rome\" ]\n```\n\n如果使用 js 来遍历的话，也简单\n\n```js\nlet names = cities.map((c) => c.name)\n```\n\n这个数据可能还没那么复杂，在看看下面这个例子，代码来源于https://goessner.net/articles/JsonPath\n\n```json\n{\n  \"store\": {\n    \"book\": [\n      {\n        \"category\": \"reference\",\n        \"author\": \"Nigel Rees\",\n        \"title\": \"Sayings of the Century\",\n        \"price\": 8.95\n      },\n      {\n        \"category\": \"fiction\",\n        \"author\": \"Evelyn Waugh\",\n        \"title\": \"Sword of Honour\",\n        \"price\": 12.99\n      },\n      {\n        \"category\": \"fiction\",\n        \"author\": \"Herman Melville\",\n        \"title\": \"Moby Dick\",\n        \"isbn\": \"0-553-21311-3\",\n        \"price\": 8.99\n      },\n      {\n        \"category\": \"fiction\",\n        \"author\": \"J. R. R. Tolkien\",\n        \"title\": \"The Lord of the Rings\",\n        \"isbn\": \"0-395-19395-8\",\n        \"price\": 22.99\n      }\n    ],\n    \"bicycle\": {\n      \"color\": \"red\",\n      \"price\": 19.95\n    }\n  }\n}\n```\n\n| JsonPath                                   | Result                                       |\n| ------------------------------------------ | -------------------------------------------- |\n| `$.store.book[*].author`                   | 所有 book 的 author 节点                     |\n| `$..author`                                | 所有 author 节点                             |\n| `$.store.*`                                | store 下的所有节点，book 数组和 bicycle 节点 |\n| `$.store..price`                           | store 下的所有 price 节点                    |\n| `$..book[2]`                               | 匹配第 3 个 book 节点                        |\n| `$..book[(@.length-1)]`，或 `$..book[-1:]` | 匹配倒数第 1 个 book 节点                    |\n| `$..book[0,1]`，或 `$..book[:2]`           | 匹配前两个 book 节点                         |\n| `$..book[?(@.isbn)]`                       | 过滤含 isbn 字段的节点                       |\n| `$..book[?(@.price<10)]`                   | 过滤`price<10`的节点                         |\n| `$..*`                                     | 递归匹配所有子节点                           |\n\n对应的语法可直接到在 JSONPath 在线验证网站上进行测试。要提一点的是，jsonpath 是支持使用 || 与 && 进行过滤的，比如上面要获取 category 为 fiction，price 大于 10 的语法为`$..book[?(@.price>10 && @.category==\"fiction\")]` 结果如下\n\n```json\n[\n  {\n    \"category\": \"fiction\",\n    \"author\": \"Evelyn Waugh\",\n    \"title\": \"Sword of Honour\",\n    \"price\": 12.99\n  },\n  {\n    \"category\": \"fiction\",\n    \"author\": \"J. R. R. Tolkien\",\n    \"title\": \"The Lord of the Rings\",\n    \"isbn\": \"0-395-19395-8\",\n    \"price\": 22.99\n  }\n]\n```\n\n## 终极实战\n\n也许你会觉得上面的例子太过简单了，可能没达到你预期所想要的效果，甚至还不如使用 json 遍历呢，下面我列举一个是我实战中遇到的例子（实际上这样的例子特别多），我先把部分数据展示出来（删除部分没用到的参数，实际参数远比这多），然后通过 js 遍历，以及 jsonpath 来获取我想要的数据。\n\n### 结构\n\n![image-20210919194116296](https://img.kuizuo.cn/image-20210919194116296.png)\n\n### 数据\n\n```json\n{\n  \"role\": \"unit\",\n  \"children\": [\n    {\n      \"role\": \"section\",\n      \"children\": [\n        {\n          \"role\": \"node\",\n          \"children\": [\n            {\n              \"summary\": \"{\\\"indexMap\\\": {}, \\\"questionsList\\\": []}\",\n              \"role\": \"group\",\n              \"tab_type\": \"text\",\n              \"name\": \"Learning objectives\",\n              \"scoreDetail\": [],\n              \"id\": \"u1g2\",\n              \"url\": \"u1g2\",\n              \"tags\": []\n            }\n          ],\n          \"suggestedDuration\": \"0\",\n          \"name\": \"1-1 Learning objectives\",\n          \"block_id\": \"90ed499f91084e2aa1b7032d2e4ecd76\",\n          \"url\": \"u1g1\",\n          \"tags\": []\n        }\n      ],\n      \"name\": \"Learning objectives\",\n      \"tags\": []\n    },\n    {\n      \"role\": \"section\",\n      \"children\": [\n        {\n          \"role\": \"node\",\n          \"children\": [\n            {\n              \"role\": \"node\",\n              \"children\": [\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Practice-1\",\n                  \"scoreDetail\": [0],\n                  \"id\": \"u1g6\",\n                  \"url\": \"u1g6\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Practice-2\",\n                  \"scoreDetail\": [1, 1, 1, 1],\n                  \"id\": \"u1g7\",\n                  \"url\": \"u1g7\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Practice-3\",\n                  \"scoreDetail\": [1, 1, 1, 1, 1],\n                  \"id\": \"u1g544\",\n                  \"url\": \"u1g544\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Practice-4\",\n                  \"scoreDetail\": [1, 1, 1, 1, 1],\n                  \"id\": \"u1g9\",\n                  \"url\": \"u1g9\",\n                  \"tags\": []\n                }\n              ],\n              \"name\": \"Practice\",\n              \"block_id\": \"f6768dc9474746b9ba071e7f211534d9\",\n              \"url\": \"u1g5\",\n              \"tags\": []\n            }\n          ],\n          \"suggestedDuration\": \"0\",\n          \"name\": \"1-2 Sharing\",\n          \"block_id\": \"1c97a87a9feb4a8aa7d6ed39482d866d\",\n          \"url\": \"u1g3\",\n          \"tags\": []\n        },\n        {\n          \"role\": \"node\",\n          \"children\": [\n            {\n              \"role\": \"group\",\n              \"tab_type\": \"video\",\n              \"name\": \"Get the skills\",\n              \"scoreDetail\": [],\n              \"id\": \"u1g16\",\n              \"url\": \"u1g16\",\n              \"tags\": []\n            },\n            {\n              \"role\": \"node\",\n              \"children\": [\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Use the skills-1\",\n                  \"scoreDetail\": [0, 0],\n                  \"id\": \"u1g615\",\n                  \"url\": \"u1g615\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Use the skills-2\",\n                  \"scoreDetail\": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n                  \"id\": \"u1g18\",\n                  \"url\": \"u1g18\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Use the skills-3\",\n                  \"scoreDetail\": [0, 0, 0, 0, 0, 0, 0],\n                  \"id\": \"u1g19\",\n                  \"url\": \"u1g19\",\n                  \"tags\": []\n                }\n              ],\n              \"name\": \"Use the skills\",\n              \"block_id\": \"2d8a81799bcc44ccab2646b613557b2b\",\n              \"url\": \"u1g17\",\n              \"tags\": []\n            },\n            {\n              \"role\": \"node\",\n              \"children\": [\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Think and speak\",\n                  \"scoreDetail\": [0],\n                  \"id\": \"u1g21\",\n                  \"url\": \"u1g21\",\n                  \"tags\": []\n                }\n              ],\n              \"name\": \"Think and speak\",\n              \"block_id\": \"5833925c8c5e4ddab7a114b15d610983\",\n              \"url\": \"u1g20\",\n              \"tags\": []\n            }\n          ],\n          \"suggestedDuration\": \"0\",\n          \"name\": \"1-3 Listening\",\n          \"block_id\": \"681817aaf75845468e464e1a8d82f2c8\",\n          \"url\": \"u1g14\",\n          \"tags\": []\n        },\n        {\n          \"role\": \"node\",\n          \"children\": [\n            {\n              \"role\": \"node\",\n              \"children\": [\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Get a clue\",\n                  \"scoreDetail\": [0, 0, 0],\n                  \"id\": \"u1g25\",\n                  \"url\": \"u1g25\",\n                  \"tags\": []\n                }\n              ],\n              \"name\": \"Get a clue\",\n              \"block_id\": \"b332335ab3554dffb92afcae5f815b5a\",\n              \"url\": \"u1g24\",\n              \"tags\": []\n            },\n            {\n              \"role\": \"node\",\n              \"children\": [\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"View it-1\",\n                  \"scoreDetail\": [1, 1, 1, 1],\n                  \"id\": \"u1g27\",\n                  \"url\": \"u1g27\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"View it-2\",\n                  \"scoreDetail\": [1, 1, 1, 1, 1, 1, 1],\n                  \"id\": \"u1g545\",\n                  \"url\": \"u1g545\",\n                  \"tags\": []\n                },\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"View it-3\",\n                  \"scoreDetail\": [1, 1, 1, 1, 1, 1, 1, 1],\n                  \"id\": \"u1g29\",\n                  \"url\": \"u1g29\",\n                  \"tags\": []\n                }\n              ],\n              \"name\": \"View it\",\n              \"block_id\": \"a2ecf6464d5f480e98242ebe4431a73b\",\n              \"url\": \"u1g26\",\n              \"tags\": []\n            },\n            {\n              \"role\": \"node\",\n              \"children\": [\n                {\n                  \"role\": \"group\",\n                  \"tab_type\": \"task\",\n                  \"name\": \"Think and speak\",\n                  \"scoreDetail\": [0, 0],\n                  \"id\": \"u1g31\",\n                  \"url\": \"u1g31\",\n                  \"tags\": []\n                }\n              ],\n              \"name\": \"Think and speak\",\n              \"block_id\": \"120d0784e63c414793f5e648c416144b\",\n              \"url\": \"u1g30\",\n              \"tags\": []\n            }\n          ],\n          \"suggestedDuration\": \"0\",\n          \"name\": \"1-4 Viewing\",\n          \"block_id\": \"765a1be83ac5437aaca8fa150ad5af2e\",\n          \"url\": \"u1g22\",\n          \"tags\": []\n        }\n      ],\n      \"name\": \"Listening to the world\",\n      \"tags\": []\n    }\n  ]\n}\n```\n\n### 需求\n\n可以看到数据比一开始的例子复杂了可不是一点，不过先别管这些数据是干啥的，说说需求，从结构上也能看出来，是有很多`children`嵌套的，而需求就是**获取`role`为`group`的`children`节点数据**\n\n### js 实现遍历\n\n先说说 js 如何实现的，我贴一下对应的代码（当时项目的代码，稍微修改的一点），可自己粘贴运行一下。\n\n```js\nlet groupList = []\nfor (const node of json.children ?? []) {\n  if (node.role == 'group') groupList.push({ ...node })\n\n  for (const group of node.children ?? []) {\n    if (group.role == 'group') groupList.push({ ...group })\n\n    for (const child of group.children ?? []) {\n      if (child.role == 'group') groupList.push({ ...child })\n\n      let children4 = child.children ?? []\n      for (const child of children4) {\n        if (child.role == 'group') groupList.push({ ...child })\n      }\n    }\n  }\n}\nconsole.log(groupList)\n```\n\n因为这些数据中，是存在不确定性的，也就是在当前节点下，二级节点可能有`children`，而其他节点下的二级很可能没有 `children`，所以我在这边就加上 `?? []` （Typescript 中的`??`语法，你可以把 `??` 当做 `||` ）来判断是否有`children`节点，有些读者可能会思考，为啥不用递归呢。说的是挺轻松的，但是递归是很容易出问题的，万一爬取到后台数据进行了一些修改，很有可能对于的递归算法将失效，甚至导致堆栈溢出，所以我这边值循环 4 级`chilren`节点（实际遇到的貌似也只有 4 级，谁又能保证爬取到数据就一定只有 4 级呢）。\n\n### jsonpath 获取\n\n于是了解到 jsonpath 后，我第一个时间就开始分析这样的数据，果不其然，得到了我想要的结果 ⬇️\n\n![image-20210919200826079](https://img.kuizuo.cn/image-20210919200826079.png)\n\n语法：`$..children[?(@.role==\"group\")]`\n\n语法意思很明确，根节点下遍历所有`children`节点，同时`role`等于`group`，呈现的效果如上图。\n\n而回到需求，**就是获取`role`为`group`的`children`节点数据**，而 jsonpath 就帮我轻松实现我想要的效果。\n\n## 最终思考\n\n实际上这样的需求我已经不止遇到一次，二次了，然而我寻求百度与群友的时候，给我的结果都不尽人意。但都没有提及到 jsonpath 来进行获取。也许是我的搜索方式有问题，但千篇一律都是 js 如何解析多层 json，以及遍历所有的子元素，虽然这些办法确实能解决我的问题，但每次遇到这种数据，都需要花上长时间去编写对应的逻辑。\n\n在回想起当时爬取 HTML 页面数据的时候（数据与上面展示的差不多，都是树结构多层），而我只接触到了正则表达式，没了解过 CSS 选择器与 xpath。怎么办，为了实现目的，只好用现有的技术去实现，于是编写一个正则表达式就花费了近一个下午的时间，而使用 CSS 选择器 10 分钟不到就达到目的。没想到竟然有这么好用的方法，早知道多去了解点技术了。可能现在的心情和当时一样，只不过 HTML 换成了 JSON，编辑器还是那个编辑器，而我依旧还是我\n\n也许这就是编程，也许这就是人生。"
    },
    {
      "id": "vue-chrome-extension",
      "metadata": {
        "permalink": "/vue-chrome-extension",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/使用Vue开发Chrome插件.md",
        "source": "@site/blog/program/使用Vue开发Chrome插件.md",
        "title": "使用Vue开发Chrome插件",
        "description": "使用 Vue2 开发一个 Chrome 插件",
        "date": "2021-09-18T00:00:00.000Z",
        "formattedDate": "2021年9月18日",
        "tags": [
          {
            "label": "chrome",
            "permalink": "/tags/chrome"
          },
          {
            "label": "plugin",
            "permalink": "/tags/plugin"
          },
          {
            "label": "vue",
            "permalink": "/tags/vue"
          },
          {
            "label": "develop",
            "permalink": "/tags/develop"
          }
        ],
        "readingTime": 10.133333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "vue-chrome-extension",
          "title": "使用Vue开发Chrome插件",
          "date": "2021-09-18T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "chrome",
            "plugin",
            "vue",
            "develop"
          ],
          "keywords": [
            "chrome",
            "plugin",
            "vue",
            "develop"
          ],
          "description": "使用 Vue2 开发一个 Chrome 插件",
          "image": "/img/blog/vue-chrome-extension.png"
        },
        "prevItem": {
          "title": "使用JSONPath解析json数据",
          "permalink": "/use-jsonpath-to-parse-json-data"
        },
        "nextItem": {
          "title": "资源导航",
          "permalink": "/resource-navigation"
        }
      },
      "content": "![mini](https://img.kuizuo.cn/mini.jpg)\n\n<!-- truncate -->\n\n## 前言\n\n我当时学习开发 Chrome 插件的时候，还不会 Vue，更别说 Webpack 了，所以使用的都是原生的 html 开发，效率就不提了，而这次就准备使用 vue-cli 来进行编写一个某 B 站获取视频信息,评论的功能（原本是打算做自动回复的），顺便巩固下 chrome 开发（快一年没碰脚本类相关技术了），顺便写套模板供自己后续编写 Chrome 插件做铺垫。\n\n相关代码开源[github 地址](https://github.com/kuizuo/vue-chrome-extension)\n\n## 环境搭建\n\n[Vue Web-Extension - A Web-Extension preset for VueJS (vue-web-extension.netlify.app)](https://vue-web-extension.netlify.app/)\n\n```sh\nnpm install -g @vue/cli\nnpm install -g @vue/cli-init\nvue create --preset kocal/vue-web-extension my-extension\ncd my-extension\nnpm run server\n```\n\n会提供几个选项，如 Eslint，background.js，tab 页，axios，如下图\n\n![image-20210916142751129](https://img.kuizuo.cn/image-20210916142751129.png)\n\n选择完后，将会自动下载依赖，通过 npm run server 将会在根目录生成 dist 文件夹，将该文件拖至 Chrome 插件管理便可安装，由于使用了 webpack，所以更改代码将会热更新，不用反复的编译导入。\n\n### 项目结构\n\n```\n├─src\n|  ├─App.vue\n|  ├─background.js\n|  ├─main.js\n|  ├─manifest.json\n|  ├─views\n|  |   ├─About.vue\n|  |   └Home.vue\n|  ├─store\n|  |   └index.js\n|  ├─standalone\n|  |     ├─App.vue\n|  |     └main.js\n|  ├─router\n|  |   └index.js\n|  ├─popup\n|  |   ├─App.vue\n|  |   └main.js\n|  ├─override\n|  |    ├─App.vue\n|  |    └main.js\n|  ├─options\n|  |    ├─App.vue\n|  |    └main.js\n|  ├─devtools\n|  |    ├─App.vue\n|  |    └main.js\n|  ├─content-scripts\n|  |        └content-script.js\n|  ├─components\n|  |     └HelloWorld.vue\n|  ├─assets\n|  |   └logo.png\n├─public\n├─.browserslistrc\n├─.eslintrc.js\n├─.gitignore\n├─babel.config.js\n├─package.json\n├─vue.config.js\n├─yarn.lock\n```\n\n根据所选的页面，并在 src 与 vue.config.js 中配置页面信息编译后 dist 目录结构如下\n\n```\n├─devtools.html\n├─favicon.ico\n├─index.html\n├─manifest.json\n├─options.html\n├─override.html\n├─popup.html\n├─_locales\n├─js\n├─icons\n├─css\n```\n\n### 安装组件库\n\n#### 安装 elementUI\n\n整体的开发和 vue2 开发基本上没太大的区别，不过既然是用 vue 来开发的话，那肯定少不了组件库了。\n\n要导入 Element-ui 也十分简单，`Vue.use(ElementUI); `Vue2 中怎么导入 element，便怎么导入。演示如下\n\n![image-20210916150154078](https://img.kuizuo.cn/image-20210916150154078.png)\n\n不过我没有使用 babel-plugin-component 来按需引入，按需引入一个按钮打包后大约 1.6m，而全量引入则是 5.5 左右。至于为什么不用，因为我需要在 content-scripts.js 中引入 element 组件，如果使用 babel-plugin-component 将无法按需导入组件以及样式（应该是只支持 vue 文件按需引入，总之就是折腾了我一个晚上的时间）\n\n#### 安装 tailwindcss\n\n不过官方提供了如何使用 TailwindCSS，这里就演示一下\n\n[在 Vue 3 和 Vite 安装 Tailwind CSS - Tailwind CSS 中文文档](https://www.tailwindcss.cn/docs/guides/vue-3-vite)\n\n推荐安装低版本，最新版有兼容性问题\n\n```bash\nnpm install tailwindcss@npm:@tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9\n```\n\n创建 postcss.config.js 文件\n\n```js title=\"postcss.config.js\"\n// postcss.config.js\nmodule.exports = {\n  plugins: [\n    // ...\n    require('tailwindcss'),\n    require('autoprefixer'), // if you have installed `autoprefixer`\n    // ...\n  ],\n}\n```\n\n创建 tailwind.config.js 文件\n\n```js title=\"tailwind.config.js\"\n// tailwind.config.js\nmodule.exports = {\n  purge: {\n    // Specify the paths to all of the template files in your project\n    content: ['src/**/*.vue'],\n\n    // Whitelist selectors by using regular expression\n    whitelistPatterns: [\n      /-(leave|enter|appear)(|-(to|from|active))$/, // transitions\n      /data-v-.*/, // scoped css\n    ],\n  },\n  // ...\n}\n```\n\n在 src/popup/App.vue 中导入样式，或在新建 style.css 在 mian.js 中`import \"../style.css\";`\n\n```vue title=\"src/popup/App.vue\"\n<style>\n/* purgecss start ignore */\n@tailwind base;\n@tailwind components;\n/* purgecss end ignore */\n\n@tailwind utilities;\n</style>\n```\n\n从官方例子导入一个登陆表单，效果如下\n\n![image-20210916152633247](https://img.kuizuo.cn/image-20210916152633247.png)\n\n## 项目搭建\n\n### 页面搭建\n\n页面搭建就没什么好说的了，因为使用的是 element-ui，所以页面很快就搭建完毕了，效果如图\n\n![image-20210918115438700](https://img.kuizuo.cn/image-20210918115438700.png)\n\n### 悬浮窗\n\n悬浮窗其实可有可无，不过之前写 Chrome 插件的时候就写了悬浮窗，所以 vue 版的也顺带写一份。\n\n要注意的是悬浮窗是内嵌到网页的（且在 document 加载前载入，也就是`\"run_at\": \"document_start\"`），所以需要通过 content-scripts.js 才能操作页面 Dom 元素，首先在配置清单 manifest.json 与 vue.confing.js 中匹配要添加的网站，以及注入的 js 代码，如下\n\n```json title=\"manifest.json\"\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://www.bilibili.com/video/*\"],\n      \"js\": [\"js/jquery.js\", \"js/content-script.js\"],\n      \"css\": [\"css/index.css\"],\n      \"run_at\": \"document_start\"\n    },\n    {\n      \"matches\": [\"https://www.bilibili.com/video/*\"],\n      \"js\": [\"js/jquery.js\", \"js/bilibili.js\"],\n      \"run_at\": \"document_end\"\n    }\n  ]\n```\n\n```js title=\"vue.config.js\"\n\tcontentScripts: {\n          entries: {\n            'content-script': ['src/content-scripts/content-script.js'],\n            bilibili: ['src/content-scripts/bilibili.js'],\n          },\n        },\n```\n\n由于是用 Vue，但又要在 js 中生成组件，就使用`document.createElement`来进行创建元素，Vue 组件如下（可拖拽）\n\n![image-20210917142340863](https://img.kuizuo.cn/image-20210917142340863.png)\n\n:::danger\n\n如果使用`babel-plugin-component`按需引入，组件的样式将无法载入，同时自定义组件如果编写了 style 标签，那么也同样无法载入，报错：Cannot read properties of undefined (reading 'appendChild')\n\n大致就是 css-loader 无法加载对应的 css 代码，如果执意要写 css 的话，直接在 manifest.json 中注入 css 即可\n\n:::\n\n<details open>\n   <summary>完整代码</summary>\n\n```js title=\"content-script.js\"\n// 注意，这里引入的vue是运行时的模块，因为content是插入到目标页面，对组件的渲染需要运行时的vue， 而不是编译环境的vue （我也不知道我在说啥，反正大概意思就是这样）\nimport Vue from 'vue/dist/vue.esm.js'\nimport ElementUI, { Message } from 'element-ui'\nVue.use(ElementUI)\n\n// 注意，必须设置了run_at=document_start此段代码才会生效\ndocument.addEventListener('DOMContentLoaded', function () {\n  console.log('vue-chrome扩展已载入')\n\n  insertFloat()\n})\n\n// 在target页面中新建一个带有id的dom元素，将vue对象挂载到这个dom上。\nfunction insertFloat() {\n  let element = document.createElement('div')\n  let attr = document.createAttribute('id')\n  attr.value = 'appPlugin'\n  element.setAttributeNode(attr)\n  document.getElementsByTagName('body')[0].appendChild(element)\n\n  let link = document.createElement('link')\n  let linkAttr = document.createAttribute('rel')\n  linkAttr.value = 'stylesheet'\n  let linkHref = document.createAttribute('href')\n  linkHref.value = 'https://unpkg.com/element-ui/lib/theme-chalk/index.css'\n  link.setAttributeNode(linkAttr)\n  link.setAttributeNode(linkHref)\n  document.getElementsByTagName('head')[0].appendChild(link)\n\n  let left = 0\n  let top = 0\n  let mx = 0\n  let my = 0\n  let onDrag = false\n\n  var drag = {\n    inserted: function (el) {\n      ;(el.onmousedown = function (e) {\n        left = el.offsetLeft\n        top = el.offsetTop\n        mx = e.clientX\n        my = e.clientY\n        if (my - top > 40) return\n\n        onDrag = true\n      }),\n        (window.onmousemove = function (e) {\n          if (onDrag) {\n            let nx = e.clientX - mx + left\n            let ny = e.clientY - my + top\n            let width = el.clientWidth\n            let height = el.clientHeight\n            let bodyWidth = window.document.body.clientWidth\n            let bodyHeight = window.document.body.clientHeight\n\n            if (nx < 0) nx = 0\n            if (ny < 0) ny = 0\n\n            if (ny > bodyHeight - height && bodyHeight - height > 0) {\n              ny = bodyHeight - height\n            }\n\n            if (nx > bodyWidth - width) {\n              nx = bodyWidth - width\n            }\n\n            el.style.left = nx + 'px'\n            el.style.top = ny + 'px'\n          }\n        }),\n        (el.onmouseup = function (e) {\n          if (onDrag) {\n            onDrag = false\n          }\n        })\n    },\n  }\n\n  window.kz_vm = new Vue({\n    el: '#appPlugin',\n    directives: {\n      drag: drag,\n    },\n    template: `\n      <div class=\"float-page\" ref=\"float\" v-drag>\n        <el-card class=\"box-card\" :body-style=\"{ padding: '15px' }\">\n          <div slot=\"header\" class=\"clearfix\" style=\"cursor: move\">\n            <span>悬浮窗</span>\n            <el-button style=\"float: right; padding: 3px 0\" type=\"text\" @click=\"toggle\">{{ show ? '收起' : '展开'}}</el-button>\n          </div>\n          <transition name=\"ul\">\n            <div v-if=\"show\" class=\"ul-box\">\n              <span> {{user}} </span>\n            </div>\n          </transition>\n        </el-card>\n      </div>\n      `,\n    data: function () {\n      return {\n        show: true,\n        list: [],\n        user: {\n          username: '',\n          follow: 0,\n          title: '',\n          view: 0,\n        },\n      }\n    },\n    mounted() {},\n    methods: {\n      toggle() {\n        this.show = !this.show\n      },\n    },\n  })\n}\n```\n\n</details>\n\n因为只能在 js 中编写 vue 组件，所以得用 template 模板，同时使用了 directives，给组件添加了拖拽的功能（尤其是`window.onmousemove`，如果是元素绑定他自身的鼠标移动事件，那么拖拽鼠标将会十分卡顿），还使用了 transition 来进行缓慢动画效果其中注入的 css 代码如下\n\n```css\n.float-page {\n  width: 400px;\n  border-radius: 8px;\n  position: fixed;\n  left: 50%;\n  top: 25%;\n  z-index: 1000001;\n}\n\n.el-card__header {\n  padding: 10px 15px !important;\n}\n\n.ul-box {\n  height: 200px;\n  overflow: hidden;\n}\n\n.ul-enter-active,\n.ul-leave-active {\n  transition: all 0.5s;\n}\n.ul-enter,\n.ul-leave-to {\n  height: 0;\n}\n```\n\n相关逻辑可自行观看，这里不在赘述了，并不复杂。\n\n也顺带是复习一下 HTML 中鼠标事件和 vue 自定义命令了\n\n### 功能实现\n\n主要功能\n\n- 检测视频页面，输出对应 up 主，关注数以及视频标题播放（参数过多就不一一显示了）\n\n- 监控关键词根据内容判断是否点赞，例如文本出现了下次一定，那么就点赞。\n\n#### 输出相关信息\n\n这个其实只要接触过一丢丢爬虫的肯定都会知道如何实现，通过右键审查元素，像这样\n\n![image-20210918104907148](https://img.kuizuo.cn/image-20210918104907148.png)\n\n然后使用 dom 操作，选择对应的元素，输出便可\n\n```js\n> document.querySelector(\"#v_upinfo > div.up-info_right > div.name > a.username\").innerText\n< '老番茄'\n```\n\n当然使用 JQuery 效果也是一样的。后续我都会使用 JQuery 来进行操作\n\n在 src/content-script/bilibili.js 中写下如下代码\n\n```js\nwindow.onload = function () {\n  console.log('加载完毕')\n\n  function getInfo() {\n    let username = $('#v_upinfo > div.up-info_right > div.name > a.username').text()\n    let follow = $(`#v_upinfo > div.up-info_right > div.btn-panel > div.default-btn.follow-btn.btn-transition.b-gz.following > span > span > span`).text()\n    let title = $(`#viewbox_report > h1 > span`).text()\n    let view = $('#viewbox_report > div > span.view').attr('title')\n\n    console.log(username, follow, title, view)\n  }\n\n  getInfo()\n}\n```\n\n重新加载插件，然后输出查看结果\n\n```\n加载完毕\nbilibili.js:19 老番茄 1606.0万 顶级画质 总播放数2368406\n```\n\n这些数据肯定单纯的输出肯定是没什么作用的，要能显示到内嵌悬浮窗口，或者是 popup 页面上（甚至发送 ajax 请求到远程服务器上保存）\n\n对上面代码微改一下\n\n```js\nwindow.onload = function () {\n  console.log('加载完毕')\n\n  function getInfo() {\n    let username = $('#v_upinfo > div.up-info_right > div.name > a.username').text().trim()\n    let follow = $(`#v_upinfo > div.up-info_right > div.btn-panel > div.default-btn.follow-btn.btn-transition.b-gz.following > span > span > span`).text()\n    let title = $(`#viewbox_report > h1 > span`).text()\n    let view = $('#viewbox_report > div > span.view').attr('title')\n\n    //console.log(username, follow, title, view);\n    window.kz_vm.user = {\n      username,\n      follow,\n      title,\n      view,\n    }\n  }\n  getInfo()\n}\n```\n\n其中`window.kz_vm`是通过`window.kz_vm = new Vue()` 初始化的，方便我们操作 vm 对象，就需要通过 jquery 选择元素在添加属性了。如果你想的话也可以直接在 content-script.js 上编写代码，这样就无需使用 window 对象，但这样导致一些业务逻辑都堆在一个文件里，所以我习惯分成 bilibili.js 然后注入方式为 document_end，然后在操作 dom 元素吗，实现效果如下\n\n![image-20210918110958104](https://img.kuizuo.cn/image-20210918110958104.png)\n\n如果像显示到 popup 页面只需要通过页面通信就行了，不过前提得先 popup 打开才行，所以一般都是通过 background 来进行中转，一般来说很少 content –> popup（因为操作 popup 的前提都是 popup 要打开），相对更多的是 content –> background 或 popup –> content\n\n[content-script 主动发消息给后台 我是小茗同学 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html#content-script主动发消息给后台)\n\n#### 实现评论\n\n这边简单编写了一下页面，通过 popup 给 content，让 content 输入评论内容，与点击发送，先看效果\n\n![bilibili_comment](https://img.kuizuo.cn/bilibili_comment.gif)\n\n同样的，找到对应元素位置\n\n```js\n// 评论文本框\n$('#comment > div > div.comment > div > div.comment-send > div.textarea-container > textarea').val('要回复的内容')\n// 评论按钮\n$('#comment > div > div.comment > div > div.comment-send > div.textarea-container > button').click()\n```\n\n接着就是写页面通信的了，可以看到是 popup 向 content 发送请求\n\n```js title=\"src/content-script/bilibili.js\"\nwindow.onload = function () {\n  console.log('content加载完毕')\n\n  function comment() {\n    chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n      let { cmd, message } = request\n      if (cmd === 'addComment') {\n        $('#comment > div > div.comment > div > div.comment-send > div.textarea-container > textarea').val(message)\n        $('#comment > div > div.comment > div > div.comment-send > div.textarea-container > button').click()\n      }\n\n      sendResponse('我收到了你的消息！')\n    })\n  }\n\n  comment()\n}\n```\n\n```html title=\"src/popup/App.vue\"\n<template>\n  <div>\n    <el-container>\n      <el-header height=\"24\">B站小工具</el-header>\n      <el-main>\n        <el-row :gutter=\"5\">\n          <el-input type=\"textarea\" :rows=\"2\" placeholder=\"请输入内容\" v-model=\"message\" class=\"mb-5\"> </el-input>\n\n          <div>\n            <el-button @click=\"addComment\">评论</el-button>\n          </div>\n        </el-row>\n      </el-main>\n    </el-container>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: 'App',\n    data() {\n      return {\n        message: '',\n        list: [],\n        open: false,\n      }\n    },\n    created() {\n      chrome.storage.sync.get('list', (obj) => {\n        this.list = obj['list']\n      })\n    },\n    mounted() {\n      chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n        console.log('收到来自content-script的消息：')\n        console.log(request, sender, sendResponse)\n        sendResponse('我是后台，我已收到你的消息：' + JSON.stringify(request))\n      })\n    },\n    methods: {\n      sendMessageToContentScript(message, callback) {\n        chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n          chrome.tabs.sendMessage(tabs[0].id, message, function (response) {\n            if (callback) callback(response)\n          })\n        })\n      },\n      addComment() {\n        this.sendMessageToContentScript({ cmd: 'addComment', message: this.message }, function () {\n          console.log('来自content的回复：' + response)\n        })\n      },\n    },\n  }\n</script>\n```\n\n代码就不解读了，调用 sendMessageToContentScript 方法即可。相关源码可自行下载查看\n\n实现类似点赞功能也是同理的。\n\n## 相关模板 \n\n[vitesse-webext](https://github.com/antfu/vitesse-webext)\n\n[plasmo](https://www.plasmo.com/)\n\n## 整体体验\n\n当时写 Chrome 插件的效率不能说慢，反正不快就是了，像一些 tips，都得自行封装。用过 Vue 的都知道写网页很方便，写 Chrome 插件未尝不是编写一个网页，当时的我在接触了 Vue 后就萌发了使用 vue 来编写 Chrome 的想法，当然肯定不止我一个这么想过，所以我在 github 上就能搜索到相应的源码，于是就有了这篇文章。\n\n如果有涉及到爬取数据相关的，我肯定是首选使用 HTTP 协议，如果在搞不定我会选择使用 puppeteerjs，不过 Chrome 插件主要还是增强页面功能的，可以实现原本页面不具备的功能。\n\n本文仅仅只是初步体验，简单编写了个小项目，后期有可能会实现一个百度网盘一键填写提取码，Js 自吐 Hooke 相关的。（原本是打算做 pdd 商家自动回复的，客户说要用客户端而不是网页端（客户端可以多号登陆），无奈，这篇博客就拿 B 站来演示了）"
    },
    {
      "id": "resource-navigation",
      "metadata": {
        "permalink": "/resource-navigation",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/资源导航.md",
        "source": "@site/blog/project/资源导航.md",
        "title": "资源导航",
        "description": "资源导航",
        "date": "2021-09-09T00:00:00.000Z",
        "formattedDate": "2021年9月9日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 6.32,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "resource-navigation",
          "title": "资源导航",
          "date": "2021-09-09T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "react"
          ],
          "keywords": [
            "project",
            "react"
          ],
          "image": "/img/project/code-nav.png",
          "draft": true
        },
        "prevItem": {
          "title": "使用Vue开发Chrome插件",
          "permalink": "/vue-chrome-extension"
        },
        "nextItem": {
          "title": "尝试云开发",
          "permalink": "/try-to-cloud-develop"
        }
      },
      "content": "![资源导航](/img/project/code-nav.png)\n\n<!-- truncate -->\n\n## 为什么要写这个\n\n无意间刷到一个网站[编程导航 - 发现优质编程资源 (code-nav.cn)](https://www.code-nav.cn/)\n\n当时我学习的时候，也是有着这样类似的站点，才让我了解到一些未曾听闻过的优质资源，所以才萌生出编写类似资源导航的一个功能，记录下自己用过见过的一些工具，框架，顺便分享一波，不过我原本是考虑内置到个人博客上，而不是新建一个站点，但是上面的这个网站部分开源，并且基于 React + Ant Design Pro，正好我最新在学习该技术，于是就成为了我的一个练手项目，二话不说，直接 clone 了该仓库便开始了阅读源码。\n\n> 注: 资源数据首次加载采用了随机排序，资源不分先后顺序。\n\n## 思路分析\n\n首先该项目的后端采用的是腾讯云的云开发，这里简单介绍一些云开发，本质上和正常开发没什么区别，都是服务端编写接口逻辑，客户端调用接口，主要的特点有如下几个\n\n- **无需管理服务器、数据库等等**\n  传统的后端开发都需要另外搭建一台服务器，配置一堆相关设置，然后他人通过 ip 加端口来进行调用，所以就免不了部署这一门槛了，而使用云开发就无需考虑这些因素，只需要编写对应的业务逻辑便可，也是常说的无服务架构\n- **原生微信服务集成**\n  腾讯云云开发可以直接接入微信用户数据，如果是小程序或公众号开发，接入将会特别方便\n- **开发简单高效**\n  开发简单，不要求特定的框架和依赖，只需要关注业务逻辑便可\n- **成本更低**\n  云开发一般都是按量使用，同时还会提供一定的免费额度（初次使用有 1 年额外的免费额度），相比购买一台服务器甚至专属的云数据库而言，很多情况下都会存在资源剩余的情况。\n- **运维省事**\n  每个云函数都是单独运行、单独部署、单独伸缩，用户上传代码后即可自动部署，免除单体式应用部署升级难的问题。\n\n正好呢我又没接触过云开发，于是花了一个晚上的时间官方文档给过了一遍，理清如何发布与调用即可。\n\n但是在该项目我并不打算使用云开发，为啥呢，我是打算写成纯静态的页面，资源更新的频率又不高，并且无需登录鉴权，所以后端服务基本用不上。于是把有关用户与数据交互的地方全部都给置成本地了。（也许后续会弄成需要登录的）\n\n## 更改代码\n\n### 定义分类文件\n\n项目预先采用的是 Mock 数据，于是我吧 Mock 数据，替换成了真实数据，然后采用 Nodejs 模块导入的方式，将所要展示的资源导入进去，像这样\n\n![image-20210908024417996](https://img.kuizuo.cn/image-20210908024417996.png)\n\n标注名称、简介、logo、链接、标签这些元素后，然后根据源码中自带的列表案例，进行样式微调整即可。\n\n不过这里定义太多文件，就需要频繁的导入，于是我使用了 Nodejs 中`require.context`将指定目录 modules 中的所有文件自动导入，相关代码如下\n\n```typescript title=\"mock/index.ts\"\nconst modulesFiles = require.context('./modules', true, /\\.ts$/)\n\nlet allData: any[] = []\n\nmodulesFiles.keys().forEach((modulePath) => {\n  const value = modulesFiles(modulePath)\n  let data = value.default\n\n  if (!data) return\n  allData.push(...value.default)\n})\n```\n\n这样每次在相应目录下定义完文件，就会将模块自动导入。\n\n### 定义数据\n\n名字和简介都还比较好解决，基本上官方文档都会一个简短的案例，可以直接拷贝过来，但令我头疼的是分类和标签，有的时候一个资源可以归分为好几个类别，像一些属于 Nodejs 的，但有些有属于 JavaScript 的，比如 Webpack，EsLint，Jest，就很抉择，再比如`框架`的话又细分为好几种，要标注为前端框架，后端框架，就很头疼。\n\n一开始分类的时候没规划好，想到啥就从收藏夹中找对应的资源，开始填写，有时候写着写着，都不记得已经写过的东西\n\n其次就是图片，有些官方未提供 favicon 文件，或者是图片尺寸太小，就只好从首页获取。但首页的图片并非是一个 url 资源，有可能是 Base64 编码的图片，或者是 Svg 格式的，Base64 的话还好，直接复制浏览器便能自动解码，反倒是内嵌的 Svg 标签，没办法，只好截图将这些图片上传到图床，然后在通过外链进行访问了。\n\n### 整理资源\n\n然后就是开始整理资源，写数据，很枯燥，比写代码还要枯燥，有一时间内，我甚至开始羡慕起写代码了。\n\n目前大致把我遇到过的给记录一下，前前后后整理了有 150 个左右资源，后续是肯定还会补充新的资源点（开始点技能了），主要我的技术栈都是 JavaScript 和 Nodejs，所以大部分资源都是围绕这些，所以导航中可能会遇到些如果有我未提及到的，那大概率我没了解过或是没必要写的。\n\n资源主要来源：除了我自己之前整理过外，还借鉴了如下几个资源点。\n\n> [编程导航 - 发现优质编程资源 (code-nav.cn)](https://www.code-nav.cn/)\n>\n> [Bootstrap 中文网 (bootcss.com)](https://www.bootcss.com/)\n>\n> [技术胖/100+前端工具和网站推荐 收藏夹公开 - Gitee.com](https://gitee.com/jishupang/Favorites/blob/master/02.Markdown/Markdown技术胖浏览器收藏夹公开.md)\n\n## 一些问题\n\n#### 非搜索引擎式搜索\n\n由于网站内的资源数据都是纯静态的，在搜索上我是直接采用了 JavaScript 中数组的 includes 来进行判断是否存在的，并未使用分词这些，（如果数据都存放至 Elasticsearch 上，这些都不是事），所以搜索并不能像搜索引擎那样进行分词搜索。（就连大小写都不区分的那种）\n\n#### 标签不可自定义\n\n同样的，标签也是会有这个问题，并且我并未将全部标签内置，也就是说，部分标签是无法进行筛选了，主流的肯定是预先设置好了的。同时也不支持自定义标签搜索。\n\n#### 未含基础知识点\n\n例如基本的计算机系统，数据结构，算法等等这些我并没有写入，至于为什么，这就不细说了。（我自己都不记得我到底学没学过这些），后续如果有需要的话，应该是会补上的。\n\n## 最后\n\n从 clone 到发布花了差不多有一周左右的时间，说快也不算快，慢也不算慢，主要的时间都花在资源分类和搜索上。\n\n算是第二个 React 项目了（第一个是该博客），不过由于该资源导航是纯静态的，没有任何与后端数据交互的，所以后续有空的话，应该是会写一个 ant-design-pro 后台管理模板，能与后端有数据交互的那种。至于后端技术栈的话，也许是 Node，也许是 Go 吧。"
    },
    {
      "id": "try-to-cloud-develop",
      "metadata": {
        "permalink": "/try-to-cloud-develop",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/尝试云开发.md",
        "source": "@site/blog/develop/尝试云开发.md",
        "title": "尝试云开发",
        "description": "在接触一个开源项目的时候，项目的后端采用的是云开发的模式（云函数，云数据库等等），本人又没接触过云开发，于是便有了这篇文章。",
        "date": "2021-09-06T00:00:00.000Z",
        "formattedDate": "2021年9月6日",
        "tags": [
          {
            "label": "develop",
            "permalink": "/tags/develop"
          },
          {
            "label": "cloud",
            "permalink": "/tags/cloud"
          }
        ],
        "readingTime": 4.066666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "try-to-cloud-develop",
          "title": "尝试云开发",
          "date": "2021-09-06T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "develop",
            "cloud"
          ],
          "keywords": [
            "develop",
            "cloud"
          ]
        },
        "prevItem": {
          "title": "资源导航",
          "permalink": "/resource-navigation"
        },
        "nextItem": {
          "title": "MongoDB按时间分组",
          "permalink": "/mongodb-time-grouping"
        }
      },
      "content": "在接触一个开源项目的时候，项目的后端采用的是云开发的模式（云函数，云数据库等等），本人又没接触过云开发，于是便有了这篇文章。\n\n本文使用是的腾讯云的产品，官方文档（很详细） [云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/)\n\n<!-- truncate -->\n\n## 云开发 CloudBase 环境\n\n[开通环境 | 云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/quick-start/create-env.html)\n\n## 本地安装 CLI 工具\n\n### 安装 Nodejs\n\n### 安装 CloudBase CLI\n\n[安装 | 云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/cli-v1/install.html)\n\n使用 NPM\n\n```sh\nnpm i -g @cloudbase/cli\n```\n\n或使用 Yarn\n\n```sh\nyarn global add @cloudbase/cli\n```\n\n测试是否安装成功\n\n```sh\ntcb -v\n```\n\n## 登录方式\n\n### 腾讯云-云开发控制台授权\n\n在您的终端中输入下面的命令\n\n```sh\ntcb login\n```\n\nCloudBase CLI 会自动打开云开发控制台获取授权，您需要点击同意授权按钮允许 CloudBase CLI 获取授权。如您没有登录，您需要登录后才能进行此操作。\n\n![image-20210905085929546](https://img.kuizuo.cn/image-20210905085929546.png)\n\n### 腾讯云-云 API 密钥授权\n\n[登录方式 | 云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/cli-v1/login.html)\n\n首先您需要到腾讯云官网获取[云 API 密钥 (opens new window)](https://console.cloud.tencent.com/cam/capi)，然后在终端中输入下面的命令：\n\n```sh\ntcb login --key\n```\n\n回车后，请按提示输入云 API 密钥的 SecretId 和 SecretKey 既可完成登录。\n\n### CI 中的登录\n\n在 CI（持续集成）构建中，您可以使用下面的方式通过 API 秘钥直接登录，避免交互式输入\n\n```sh\ntcb login --apiKeyId xxx --apiKey xxx\n```\n\n### 临时秘钥登录\n\n通过腾讯云临时秘钥登录，可以在某些比较敏感的场景下使用，使用短期有效的秘钥\n\n```sh\ntcb login --apiKeyId xxx --apiKey xxx --token xxx\n```\n\n## 开始体验\n\n[介绍 | 云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/api-reference/server/node-sdk/introduction.html)\n\n所采用的是`Nodejs SDK API`进行体验\n\n### 安装\n\n```\nnpm install --save @cloudbase/node-sdk\n```\n\n### 初始化\n\n```javascript\n// 初始化示例\nconst tcb = require('@cloudbase/node-sdk')\n// 初始化资源\n\n//云函数下使用默认环境\nconst app = tcb.init()\n```\n\n### 云函数\n\n#### 创建云函数\n\n[概述 | 云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/cloud-function/introduce.html)\n\n创建一个项目，在项目的根目录创建 **functions** 文件夹。在 **functions** 下创建 **hello_world** 文件夹，包含 **index.js** 与 **package.json** 两个文件。\n\n此时目录结构如下：\n\n```text\n└── functions\n    └── hello_world\n        ├── index.js\n        └── package.json\n```\n\n**index.js** 内容如下：\n\n```js\nexports.main = async function () {\n  return 'Hello World!'\n}\n```\n\n**package.json** 内容如下：\n\n```json\n{\n  \"name\": \"hello_world\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\"\n}\n```\n\n#### 发布云函数\n\n通过前面安装的 CLI 工具，在**项目根目录**运行以下命令，并且使用**默认配置**：\n\n```bash\ncloudbase fn deploy hello_world -e <env-id>\n```\n\n`<env-id>`为环境 id，可在云开发 CloudBase 中环境查看，部署结果如下\n\n![image-20210905093035131](https://img.kuizuo.cn/image-20210905093035131.png)\n\n在控制面板中也能看到对应的云函数列表\n\n![image-20210905093757875](https://img.kuizuo.cn/image-20210905093757875.png)\n\n后台也是能完整看到对应的代码的\n\n![image-20210905094146730](https://img.kuizuo.cn/image-20210905094146730.png)\n\n#### 调用云函数\n\n##### 使用 HTTP 调用\n\n执行以下命令创建一条 HTTP 服务路由，路径为 `/hello`，指向的云函数为 `hello_world`：\n\n```bash\ncloudbase service create -p hello -f hello_world -e <env-id>\n```\n\n随后便可以通过 `https://<env-id>.service.tcloudbase.com/hello` 调用云函数，并获得返回结果。如下图\n\n![image-20210905093505618](https://img.kuizuo.cn/image-20210905093505618.png)\n\n##### Nodejs 调用\n\n```js\nconst tcb = require('@cloudbase/node-sdk')\nconst app = tcb.init({\n  secretId: 'xxxxxx',\n  secretKey: 'xxxxxx',\n  env: 'env-id',\n})\n\napp\n  .callFunction({\n    // 云函数名称\n    name: 'hello_world',\n    // 传给云函数的参数\n    data: {\n      a: 1,\n    },\n  })\n  .then((res) => {\n    console.log(res)\n  })\n  .catch(console.error)\n```\n\n输出\n\n```\n{\n  result: 'Hello World!',\n  requestId: 'xxxxx‘\n}\n```\n\n### 云数据库\n\n[概述 | 云开发 CloudBase - 一站式后端云服务](https://docs.cloudbase.net/database/introduce.html)\n\n#### 实例代码如下\n\n```javascript\nconst tcb = require('@cloudbase/node-sdk')\nconst app = tcb.init({\n  secretId: 'xxxxx',\n  secretKey: 'xxxxx',\n  env: 'env-id',\n})\n\nlet db = app.database()\n\nasync function run() {\n  // 创建集合\n  let res = await db.createCollection('books')\n  console.log(res)\n\n  // // 插入一条数据\n  let res1 = await db.collection('books').add({\n    category: 'Computer',\n    name: 'Thinking in Java',\n    onSale: true,\n    sales: 100,\n  })\n  console.log(res1)\n\n  // 获取数据库中的数据\n  let res2 = await db.collection('books').get()\n  console.log(res2)\n}\nrun()\n```\n\n运行结果如下\n\n```\n{ requestId: '17bb3e26ecb_1', message: 'success' }\n{ id: '14139e12613431c809b949933c3209de', requestId: '17bb3e27010_2' }\n{\n  data: [\n    {\n      _id: '14139e12613431c809b949933c3209de',\n      category: 'Computer',\n      name: 'Thinking in Java',\n      onSale: true,\n      sales: 100\n    }\n  ],\n  requestId: '17bb3e270ca_3'\n}\n```\n\n### 云存储\n\n暂时用不到，就没体验\n\n### 登录鉴权\n\n暂时用不到，就没体验\n\n## 体验感受\n\n除了要钱外，我目前是找不到第二个缺点，我个人体验下来，整体流程可以说是非常爽的那种。因为部署项目是一件特别折腾的一件事情，而使用云开发门槛瞬间减少一半，只要会写 js 函数，会调用数据库，就足够搞定一个后端服务了。如果是搞小程序的，又要搞服务这些，直接上手云开发，微信用户，微信支付直接一条龙服务。\n\n当然了如果要搞什么分布式，集群啥的，那还是老老实实的用后端框架吧。"
    },
    {
      "id": "mongodb-time-grouping",
      "metadata": {
        "permalink": "/mongodb-time-grouping",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/MongoDB按时间分组.md",
        "source": "@site/blog/develop/MongoDB按时间分组.md",
        "title": "MongoDB按时间分组",
        "description": "需求",
        "date": "2021-08-30T00:00:00.000Z",
        "formattedDate": "2021年8月30日",
        "tags": [
          {
            "label": "mongodb",
            "permalink": "/tags/mongodb"
          }
        ],
        "readingTime": 7.77,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "mongodb-time-grouping",
          "title": "MongoDB按时间分组",
          "date": "2021-08-30T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "mongodb"
          ],
          "keywords": [
            "mongodb"
          ]
        },
        "prevItem": {
          "title": "尝试云开发",
          "permalink": "/try-to-cloud-develop"
        },
        "nextItem": {
          "title": "基于Axios封装HTTP类库",
          "permalink": "/axios-http-class-library"
        }
      },
      "content": "<!-- truncate -->\n\n## 需求\n\n需求是这样的，要统计每一周的各个商品的销售记录，使用 echarts 图表呈现，如下图\n\n![image-20210830214556262](https://img.kuizuo.cn/image-20210830214556262.png)\n\n说实话，一开始听到这个需求的时候，我是有点慌的，因为 MongoDB 的分组玩的比较少（Mysql 也差不多），又要按照对应的星期来进行分组，这在之前学习 MongoDB 的时候还没接触过，于是就准备写了这篇文章，来记录下我是如何进行分组的\n\n## MongoDB 的一些时间操作符\n\n时间操作符（专业术语应该不是这个，后文暂且使用这个来描述），**后面会用到的**\n\n```\n$dayOfYear: 返回该日期是这一年的第几天。（全年366天）\n$dayOfMonth: 返回该日期是这一个月的第几天。（1到31）\n$dayOfWeek: 返回的是这个周的星期几。（1：星期日，7：星期六）\n$year: 返回该日期的年份部分\n$month： 返回该日期的月份部分（between 1 and 12.）\n$week： 返回该日期是所在年的第几个星期（between 0 and 53）\n$hour： 返回该日期的小时部分\n$minute: 返回该日期的分钟部分\n$second: 返回该日期的秒部分（以0到59之间的数字形式返回日期的第二部分，但可以是60来计算闰秒。）\n$millisecond：返回该日期的毫秒部分（between 0 and 999.）\n$dateToString：{ $dateToString: { format: <formatString>, date: <dateExpression> } }\n```\n\n## 日期分组\n\n[mongdb 聚合查询日期 统计每天数据](https://blog.csdn.net/wangshu_liang/article/details/95326578?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&spm=1001.2101.3001.4242)\n\n关于日期分组的话，我是借鉴了这篇文章，也确实带我解惑了下如何按照日期分组。这里贴下我的代码\n\n```js\nlet list = await this.goodsModel\n  .aggregate([\n    { $project: { date: { $dateToString: ['$created_at', 0, 10] } } },\n    { $group: { _id: '$date', count: { $sum: 1 } } },\n    { $project: { date: '$_id', _id: 0, count: 1 } }, // 再使用$project将_id改名为date\n    { $sort: { date: -1 } }, // 根据日期倒序\n  ])\n  .exec();\n```\n\n或者使用时间操作符（更准确一点）\n\n```js\nlet list = await this.goodsModel\n  .aggregate([\n    {\n      $project: { date: { $dateToString: { format: '%Y-%m-%d', date: '$created_at' } } },\n    },\n    { $group: { _id: '$date', count: { $sum: 1 } } },\n    { $project: { date: '$_id', _id: 0, count: 1 } }, // 再使用$project将_id改名为date\n    { $sort: { date: -1 } }, // 根据日期倒序\n  ])\n  .exec();\n```\n\n通过\n\n> 要注意的是，$group 里的属性必须为\\_id，不然无法分组\n\n获取到的数据如下（这里只显示一周）\n\n```json\n[\n  { \"count\": 54, \"date\": \"2021-08-30\" },\n  { \"count\": 29, \"date\": \"2021-08-29\" },\n  { \"count\": 16, \"date\": \"2021-08-28\" },\n  { \"count\": 17, \"date\": \"2021-08-27\" },\n  { \"count\": 12, \"date\": \"2021-08-26\" },\n  { \"count\": 6, \"date\": \"2021-08-25\" },\n  { \"count\": 0, \"date\": \"2021-08-24\" }\n]\n```\n\n如果只是日期和总商品的话，上面就足以显示对应的数据了，可我要根据星期进行分组的话，就需要替换 MongoDB 的时间转化函数了\n\n## 星期分组\n\n星期分组的话，其实也挺简单的，只需要把上面的\n\n```js\n$project: { day: { $dateToString: { format: \"%Y-%m-%d\", date: \"$created_at\" } } }\n```\n\n替换成\n\n```js\n$project: {\n  week: {\n    $dayOfWeek: {\n      date: '$created_at';\n    }\n  }\n}\n```\n\n完整代码如下\n\n```js\n// 要获取的是一周前的零点时间\nlet lastweekDay = dayjs(dayjs().add(-7, 'day').format('YYYY-MM-DD')).valueOf();\n\nlet list = await this.goodsModel\n  .aggregate([\n    { $match: { created_at: { $gte: new Date(lastweekDay) } } }, //范围时间\n    { $project: { week: { $dayOfWeek: { date: '$created_at' } } } },\n    { $group: { _id: '$week', count: { $sum: 1 } } },\n    { $project: { week: '$_id', _id: 0, count: 1 } }, // 再使用$project将_id改名为week\n    { $sort: { week: 1 } }, // 根据星期正序\n  ])\n  .exec();\n```\n\n获取的结果如下\n\n```js\n[\n  { count: 29, week: 1 }, // 星期七(日)\n  { count: 54, week: 2 }, // 星期一\n  { count: 1, week: 3 }, // 星期二\n  { count: 9, week: 4 }, // 星期三\n  { count: 12, week: 5 }, // 星期四\n  { count: 17, week: 6 }, // 星期五\n  { count: 16, week: 7 }, // 星期六\n];\n```\n\n但是，细心的你可能会发现，貌似数据对不上，注当天时间为 2021-08-30，星期一\n\n```json\n[\n  { \"count\": 54, \"date\": \"2021-08-30\" }, // 星期一\n  { \"count\": 29, \"date\": \"2021-08-29\" }, // 星期七(日)\n  { \"count\": 16, \"date\": \"2021-08-28\" }, // 星期六\n  { \"count\": 17, \"date\": \"2021-08-27\" }, // 星期五\n  { \"count\": 12, \"date\": \"2021-08-26\" }, // 星期四\n  { \"count\": 9, \"date\": \"2021-08-25\" }, // 星期三\n  { \"count\": 1, \"date\": \"2021-08-24\" } // 星期二\n]\n```\n\n其实只需要把星期向后排序一位就行，因为星期本来就是将星期日作为第一天的，至此，按照星期分组总商品就算完毕了。同理，要按照月份，年份，甚至小时，分钟，都可以直接利用时间操作符转化时间来进行分组。\n\n## 多商品\n\n上述只是获取了总商品了，要细分为多个商品的话，就需要再次利用聚合函数来进行分组了。\n\n这里先演示分组多个商品先，就和正常分组一样\n\n```\nlet list = await this.goodsModel.aggregate([\n{ $group: { _id: \"$type\", count: { $sum: 1 } } },\n]).exec()\n```\n\n结果如下（这里输出\\_id，是因为没有进行$project 改别名，商品所采用的是数字表示）\n\n```json\n[\n  { \"_id\": 1, \"count\": 111 },\n  { \"_id\": 2, \"count\": 18 },\n  { \"_id\": 4, \"count\": 2 },\n  { \"_id\": 3, \"count\": 16 }\n]\n```\n\n可以看到统计的是直接是所有商品的总和。\n\n但问题来了，怎么样能分组星期的同时，又对每个商品所在星期进行分组，并且到底是优先分组星期期呢，还是优先分组商品呢，这让我陷入深深的思考。\n\n## 最终实现\n\n首先，绝对不可能使用两次`$group`，要么没有星期分组，要么没有商品分组，于是我就把思路放在`$project`与`$group`内，看看内部是否有其他方法可以实现。\n\n其中`$group`可以将属性添加为数组，注意 `goods: { $push: \"$goods\" }`\n\n```js\nlet list = await this.goodsModel\n  .aggregate([\n    { $match: { created_at: { $gte: new Date(lastweekDay) } } },\n    { $project: { week: { $dayOfWeek: { date: '$created_at' } }, goods: 1 } },\n    { $group: { _id: '$week', goods: { $push: '$goods' } } },\n    { $project: { week: '$_id', _id: 0, goods: 1 } },\n    { $sort: { week: 1 } },\n  ])\n  .exec();\n```\n\n可得到的数据却是这样的\n\n```json\n[\n  {\n    \"goods\": [4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1],\n    \"week\": 1\n  },\n  {\n    \"goods\": [1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 4, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    \"week\": 2\n  },\n  {\n    \"goods\": [1],\n    \"week\": 3\n  },\n  {\n    \"goods\": [3, 3, 3, 3, 3, 3, 3, 3, 4],\n    \"week\": 4\n  },\n  {\n    \"goods\": [3, 1, 1, 1, 3, 4, 1, 1, 1, 1, 1, 1],\n    \"week\": 5\n  },\n  {\n    \"goods\": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1],\n    \"week\": 6\n  },\n  {\n    \"goods\": [4, 3, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1],\n    \"week\": 7\n  }\n]\n```\n\n数据很接近了，如果我能把对应的商品总和算起来就行了，但问题是怎么合起来。。。\n\n待会，goods 既然是数组的话，那我能不能`$unwind`全部展开，然后我再来一次聚合，说干就干！\n\n```js\nlet list = await this.goodsModel\n  .aggregate([\n    { $match: { created_at: { $gte: new Date(lastweekDay) } } },\n    { $project: { week: { $dayOfWeek: { date: '$created_at' } }, goods: 1 } },\n    { $group: { _id: '$week', goods: { $push: '$goods' } } },\n    { $project: { week: '$_id', _id: 0, goods: 1 } },\n    { $sort: { week: 1 } },\n    { $unwind: '$goods' },\n  ])\n  .exec();\n```\n\n得到的数据（省略一堆）\n\n```json\n[\n  { \"goods\": 4, \"week\": 1 },\n  { \"goods\": 4, \"week\": 1 },\n  { \"goods\": 1, \"week\": 1 },\n  { \"goods\": 1, \"week\": 1 },\n  { \"goods\": 1, \"week\": 2 },\n  { \"goods\": 1, \"week\": 3 },\n  { \"goods\": 1, \"week\": 4 }\n]\n```\n\n然后我就卡住了，因为我无论如何都无法分组一个字段的时候，又加以限制条件，要么分组商品的时候，统计的是一周各商品总数据，要么就是分组星期的时候，统计的是总的商品数据。在搜索大量资料后，查看官方一些文档也未果，于是我决定自行写一个 js 函数来进行排序（实在是折腾不动了，能力有限 🥱）\n\n最终完整代码\n\n```js\nlet lastweekDay = dayjs(dayjs().add(-7, 'day').format('YYYY-MM-DD')).valueOf();\n\nlet list = await this.goodsModel\n  .aggregate([\n    { $match: { created_at: { $gte: new Date(lastweekDay) } } },\n    { $project: { week: { $dayOfWeek: { date: '$created_at' } }, goods: 1 } },\n    { $group: { _id: '$week', goods: { $push: '$goods' } } },\n    { $project: { week: '$_id', _id: 0, goods: 1 } },\n    { $sort: { week: 1 } },\n    // { $unwind: \"$goods\" },\n  ])\n  .exec();\n\nfunction getEleNums(data) {\n  var map = {};\n  data.forEach((e) => {\n    if (map[e]) {\n      map[e] += 1;\n    } else {\n      map[e] = 1;\n    }\n  });\n  return map;\n}\n\nlist = list.map((l) => {\n  l.goods = getEleNums(l.goods);\n  return l;\n});\ncosnole.log(list);\n```\n\n运行后的 list 结果为\n\n```json\n[\n  { \"goods\": { \"1\": 26, \"4\": 3 }, \"week\": 1 },\n  { \"goods\": { \"1\": 53, \"4\": 3, \"5\": 1 }, \"week\": 2 },\n  { \"goods\": { \"1\": 1 }, \"week\": 3 },\n  { \"goods\": { \"3\": 8, \"4\": 1 }, \"week\": 4 },\n  { \"goods\": { \"1\": 9, \"3\": 2, \"4\": 1 }, \"week\": 5 },\n  { \"goods\": { \"1\": 15, \"3\": 2 }, \"week\": 6 },\n  { \"goods\": { \"1\": 9, \"3\": 6, \"4\": 1 }, \"week\": 7 }\n]\n```\n\n如果是要 goods 为分组的话，只需要把上面聚合代码中 week 和 goods 替换一下便可。\n\n## 另一种实现方式\n\n专门新建一个表，用于统计每天的销售记录，然后分组的时候就根据该表就行了，具体代码就实现了，思路是挺简单的，但是需要新建一个表，增加记录的时候有需要增加代码，如果业务复杂的话。。。"
    },
    {
      "id": "axios-http-class-library",
      "metadata": {
        "permalink": "/axios-http-class-library",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/基于Axios封装HTTP类库.md",
        "source": "@site/blog/develop/基于Axios封装HTTP类库.md",
        "title": "基于Axios封装HTTP类库",
        "description": "基于 Axios 封装 HTTP 类库，并发布到 npm 仓库中",
        "date": "2021-08-26T00:00:00.000Z",
        "formattedDate": "2021年8月26日",
        "tags": [
          {
            "label": "node",
            "permalink": "/tags/node"
          },
          {
            "label": "http",
            "permalink": "/tags/http"
          },
          {
            "label": "axios",
            "permalink": "/tags/axios"
          }
        ],
        "readingTime": 5.12,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "axios-http-class-library",
          "title": "基于Axios封装HTTP类库",
          "date": "2021-08-26T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "node",
            "http",
            "axios"
          ],
          "keywords": [
            "node",
            "http",
            "axios"
          ],
          "description": "基于 Axios 封装 HTTP 类库，并发布到 npm 仓库中"
        },
        "prevItem": {
          "title": "MongoDB按时间分组",
          "permalink": "/mongodb-time-grouping"
        },
        "nextItem": {
          "title": "第二个博客搭建之Docusaurus",
          "permalink": "/second-blog-is-docusaurus"
        }
      },
      "content": "<!-- truncate -->\n\n一个基于 Axios 封装 HTTP 类库\n\n源代码 [kz-http](https://github.com/kuizuo/kz-http)\n\n## 使用方法\n\nnpm 安装\n\n```sh\nnpm i kz-http -S\n```\n\n### 请求\n\n```javascript\nimport Http from 'kz-http'\n\nlet http = new Http()\n\nhttp.get('https://www.example.com').then((res) => {\n  console.log(res)\n})\n```\n\n## 能解决什么\n\naxios 明明那么好用，为啥又要基于 axios 重新造一个轮子。首先不得否认的是 axios 确实好用，Github 能斩获近 90k 的 star，且基本已成为前端作为数据交互的必备工具。但是它对我所使用的环境下还是存在一定的问题，也就是我为什么要重新造一个轮子。\n\n### Node 环境下无法自动封装 Set-Cookie\n\n如果 axios 是运行在浏览器那还好说，就算你无论怎么请求，浏览器都会自动将你的所有请求中的响应包含 set-cookie 参数，提供给下一次同域下的请求。但是，Node 环境并不是浏览器环境，在 Node 环境中运行并不会自动保存 Cookie，还需要手动保存，并将 Cookie 添加至协议头给下一个请求。（如果是 Python 的话，request 有个 session 方法可以自动保存 cookie，十分方便）\n\n一开始我是自行封装，将响应中的 set-cookie 全都存在实例对象 http.cookies 上，但封装的不彻底，如果有的网站\n\n间请求存在跨域，那么会将携带不该属于该域下的 Cookies。于是乎，我在 github 仓库找到了一个库可达到我的目的\n\n[3846masa/axios-cookiejar-support: Add tough-cookie support to axios. (github.com)](https://github.com/3846masa/axios-cookiejar-support)\n\n具体安装可以直接点击链接查看，这里贴下我**之前**的封装代码\n\n```javascript\nconst tough = require('tough-cookie');\nconst axiosCookieJarSupport = require('axios-cookiejar-support').default;\naxiosCookieJarSupport(axios);\n\nclass Http {\n  public cookieJar;\n  public instance: AxiosInstance;\n  construction() {\n    this.cookieJar = new tough.CookieJar(null, { allowSpecialUseDomain: true });\n    this.instance = axios.create({\n      jar: this.cookieJar,\n      ignoreCookieErrors: false,\n      withCredentials: true,\n    });\n  }\n}\n```\n\n这样 axios 就会自动将响应中的 set-cookie 封装起来，供下次使用\n\n但是正是由于导入了这个包，导致每次请求都需要处理，就会导致请求速度变慢，实测大约是在 100ms 左右，同时导入这个包之后，实例化的对象都将会携带对应 cookies，想要删除又得对应 Url，于是决定自行封装相关代码可查看 request 方法，实测下来大约有 10ms 左右的差距（前提都通过创建实例来请求），不过有个缺陷，我封装的代码是不进行同源判断的，如何你当前站点请求的是 api1.test.com，获取到 cookie1，那么请求 api2.test.com 的时候也会将 cookie1 携带，这边不做判断是不想在请求的时候耗费时间，比如网页与手机协议，一般这种情况建议实例化两个对象，如\n\n```javascript\nlet http_api1 = new Http()\nlet http_api2 = new Http()\n```\n\n### 请求失败无法自动重试\n\n在高并发的情况下，偶尔会出现请求超时，请求拒绝的情况，但是默认下 axios 是不支持自动重试请求的，不过可以借助插件`axios-retry`来达到这个目的\n\n```javascript\nconst axiosRetry = require('axios-retry')\n\nclass Http {\n  constructor(retryConfig?) {\n    this.instance = axios.create()\n\n    if (retryConfig) {\n      axiosRetry(this.instance, {\n        retries: retryConfig.retry, // 设置自动发送请求次数\n        retryDelay: (retryCount) => {\n          return retryCount * retryConfig.delay // 重复请求延迟\n        },\n        shouldResetTimeout: true, // 重置超时时间\n        retryCondition: (error) => {\n          if (axiosRetry.isNetworkOrIdempotentRequestError(error)) {\n            return true\n          }\n\n          if (error.code == 'ECONNABORTED' && error.message.indexOf('timeout') != -1) {\n            return true\n          }\n          if (['ECONNRESET', 'ETIMEDOUT'].includes(error.code)) {\n            // , 'ENOTFOUND'\n            return true\n          }\n          return false\n        },\n      })\n    }\n  }\n}\n```\n\n这边判断重新发送请求条件是连接拒绝，连接重置，和连接超时的情况。\n\n### 配置拦截器\n\n有时候一个网站的协议是这样的，每一条 Post 都自动将所有参数进行拼接，然后进行 MD5 加密，并添加为 sign 参数，于是，不得不给每一条请求都进行这样的操作，那么有没有什么能在每次请求的时候，都自动的对参数进行 MD5 加密。如果使用过 axios 来配置过 JWT 效验，那自然就会熟悉给每条请求协议头都携带 JWT 数值。同样的，这里的加密例子同样使用，具体配置实例对象 http 的请求拦截器即可，如\n\n```javascript\nlet http = new Http()\n\n// axios实例instance是公开的\nhttp.instance.interceptors.request.use(\n  (config) => {\n    // 执行每条请求都要处理的操作\n    return config\n  },\n  (error) => {},\n)\n```\n\n同样的，响应拦截器也同理，例如请求返回的响应都进行加密处理，那么就可以通过响应拦截器进行统一解密，这里就不做过多描述，具体场景具体分析。\n\n### 封装一些常用方法\n\n比如设置伪造 IP（setFakeIP），自动补全 referer 和 orgin 参数，禁止重定向等等，更详细的查看源码便可\n\n## 发布 npm 包\n\n如果要让别人使用的话，总不可能让他去下载源码然后编译吧，这里就借助 npm。\n\n:::tip\n\n在使用 npm 之前，请先使用`npm install -g npm@latest`升级为最新版，否则可能会提示 **ERR! 426 Upgrade Required**。原文 [The npm registry is deprecating TLS 1.0 and TLS 1.1 | The GitHub Blog](https://github.blog/2021-08-23-npm-registry-deprecating-tls-1-0-tls-1-1/)\n\n:::\n\n创建 npm 账号，创建 package.json\n\n```json title=\"package.json\"\n{\n  \"name\": \"kz-http\",\n  \"version\": \"0.1.0\",\n  \"description\": \"An HTTP class library based on axios\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"author\": \"kuizuo\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"axios\": \"^0.21.1\",\n    \"axios-retry\": \"^3.1.9\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^4.3.5\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/kuizuo/kz-http.git\"\n  },\n  \"keywords\": [\"node\", \"axios\", \"http\"]\n}\n```\n\n然后通过`npm login`登录 npm 账号，接着输入`npm publish --access public`发布即可\n\n发布的是要注意以下几点\n\n- 如果 npm 镜像必须是官方的，否则无法登录，镜像还原\n\n  ```sh\n  npm config set registry https://registry.npmjs.org/\n  ```\n\n  查看镜像配置地址\n\n  ```sh\n  npm get registry\n  ```\n\n- 如果包有重名，那么就无法发布，就必须要要改名\n\n- 邮箱必须要验证（会接受一条下图邮箱），不然就会发布失败\n  ![image-20210826212258752](https://img.kuizuo.cn/image-20210826212258752.png)\n\n- **请勿随意删包，否则同名的包将需要 24 小时后才能发布（亲测）**\n\n  > npm ERR! 403 403 Forbidden - PUT http://registry.npmjs.org/kz-http - kz-http cannot be republished until 24 hours have passed.\n\n发布完成后，别人只需要通过`npm i kz-http`就可成功将模块下载至本地 node_modules 文件夹下"
    },
    {
      "id": "second-blog-is-docusaurus",
      "metadata": {
        "permalink": "/second-blog-is-docusaurus",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/第二个博客搭建之Docusaurus.md",
        "source": "@site/blog/program/第二个博客搭建之Docusaurus.md",
        "title": "第二个博客搭建之Docusaurus",
        "description": "使用 docusaurus 搭建个人博客，并对其主题进行魔改",
        "date": "2021-08-20T00:00:00.000Z",
        "formattedDate": "2021年8月20日",
        "tags": [
          {
            "label": "blog",
            "permalink": "/tags/blog"
          },
          {
            "label": "docusaurus",
            "permalink": "/tags/docusaurus"
          },
          {
            "label": "project",
            "permalink": "/tags/project"
          }
        ],
        "readingTime": 2.08,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "second-blog-is-docusaurus",
          "title": "第二个博客搭建之Docusaurus",
          "date": "2021-08-20T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "blog",
            "docusaurus",
            "project"
          ],
          "keywords": [
            "blog",
            "docusaurus",
            "project"
          ],
          "description": "使用 docusaurus 搭建个人博客，并对其主题进行魔改",
          "image": "/img/project/blog.png",
          "sticky": 5
        },
        "prevItem": {
          "title": "基于Axios封装HTTP类库",
          "permalink": "/axios-http-class-library"
        },
        "nextItem": {
          "title": "记一次git丢失代码找回",
          "permalink": "/lost-code-find-by-git"
        }
      },
      "content": "博客地址: [愧怍的小站](https://kuizuo.cn/)\n\n时隔近半年没好好整理文章，博客也写的不像个人样。:joy:\n\n大半年没更新博客，一直忙着写项目（写到手软的那种），然后无意间在 B 站看到一个 Up 主 [峰华前端工程师](https://zxuqian.cn/) 基于 React 驱动的静态网站生成器搭建的个人博客。第一眼看到该站点的时候惊艳到我了，于是我在其基础上并魔改了一些页面功能，作为个人站点使用。\n\n> 不过国内 docusaurus 的使用者是真的少，Vuepress 都快烂大街了...\n\n<!-- truncate -->\n\n## 安装\n\n如果你想搭建一个类似的博客，可以 [fork 本项目](https://github.com/kuizuo/blog/fork)，修改个人信息，并将文章迁移过来。这里推荐使用 [Vercel 部署个人博客](https://kuizuo.cn/vercel-deploy-blog)，以下是本地安装示例。\n\n```bash\ngit clone https://github.com/kuizuo/blog\ncd blog\nyarn\nyarn start\n```\n\n关于主题魔改可以看 [Docusaurus 主题魔改](https://kuizuo.cn/docs/docusaurus-guides)\n\n## 一些页面\n\n### [博客页](/)\n\n![image-20230221120937768](https://img.kuizuo.cn/image-20230221120937768.png)\n\n- 支持 3 种博文信息展示\n- 博客个人信息卡片\n- 可根据 `sticky` 字段对文章进行置顶推荐\n\n### [归档页](/archive)\n\n![image-20220804052418993](https://img.kuizuo.cn/image-20220804052418993.png)\n\n### [资源导航](/resource)\n\n![image-20220804052016538](https://img.kuizuo.cn/image-20220804052016538.png)\n\n- 在此分享所收藏的一些好用、实用网站。\n\n### 评论\n\n![image-20220804052746803](https://img.kuizuo.cn/image-20220804052746803.png)\n\n- 接入 [giscus](https://giscus.app) 作为评论系统，支持 GitHub 登录。\n\n### [项目](/project)\n\n![image-20220804052117492](https://img.kuizuo.cn/image-20220804052117492.png)\n\n- 存放你的项目，或是当做一个作品集用于展示。\n\n## 部署\n\n按传统的方式，你编写好一篇文章后，需要重新打包成静态文件（.html），然后将静态文件上传到服务器（需要自己准备）上，然后通过 nginx 配置域名访问。如今有了自动化部署，你只需要将代码 push 到 Github 上，然后通过 CI/CD 自动化部署到服务器上。可以参考 [ci.yml](https://github.com/kuizuo/blog/blob/main/.github/workflows/ci.yml) 配置文件。\n\n这里推荐使用 [Vercel 部署个人博客](/vercel-deploy-blog)，部署十分简单，你甚至不需要服务器，只需要有个 Github 账号，将你的博客项目添加为一个仓库中即可（也许需要科学上网）。\n\n## 最后\n\n博客的意义在于记录，记录自己的成长，记录自己的所思所想，记录自己的所学所得。希望更多的时间用在创作内容上，而不是在搭建博客上。\n\n也就不浪费口舌了，博客搭建完毕，应该好好的去编写有意义的文章，才能够吸引他人的阅读。"
    },
    {
      "id": "lost-code-find-by-git",
      "metadata": {
        "permalink": "/lost-code-find-by-git",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/记一次git丢失代码找回.md",
        "source": "@site/blog/develop/记一次git丢失代码找回.md",
        "title": "记一次git丢失代码找回",
        "description": "记录 git 操作失误导致代码丢失与找回的过程",
        "date": "2021-08-15T00:00:00.000Z",
        "formattedDate": "2021年8月15日",
        "tags": [
          {
            "label": "git",
            "permalink": "/tags/git"
          },
          {
            "label": "code",
            "permalink": "/tags/code"
          }
        ],
        "readingTime": 1.86,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "lost-code-find-by-git",
          "title": "记一次git丢失代码找回",
          "date": "2021-08-15T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "git",
            "code"
          ],
          "keywords": [
            "git",
            "code"
          ],
          "description": "记录 git 操作失误导致代码丢失与找回的过程"
        },
        "prevItem": {
          "title": "第二个博客搭建之Docusaurus",
          "permalink": "/second-blog-is-docusaurus"
        },
        "nextItem": {
          "title": "Redis获取六位不重复数字（邀请码）",
          "permalink": "/redis-get-six-digit-number-invitation-code"
        }
      },
      "content": "<!-- truncate -->\n\n## 场景复现\n\n今晚，我和往常一样对着电脑撸着代码，这时候我灵光一现，想到了一个好的功能，于是乎我就开始增加代码文件，更改之前已有的问题，当我实现完这个功能的时候，觉得可有可无，我想通过 Git 直接回退到我没有这个新功能的版本，把新增的文件和更改的文件全都给还原回去，然而在编写新功能的时候我忘记 Commit 了！！！（正常操作应该是新建一个分支，在新分支编写新功能），于是乎我点了如图操作（这里仅作为事件发生展示，并不为实际丢失个数）\n\n![image-20210815141808996](https://img.kuizuo.cn/image-20210815141808996.png)\n\n没错，清空所有更改过的代码。导致这些文件直接丢失（并不在回收站），包括写新功能前的代码和写新功能后的代码全都丢失了 😭！！！\n\n## 找回前提\n\n庆幸的时候，写新功能前的代码我成功 add 到了暂存区，只是未 Commit 而已，那么就能找回对应的文件（仅仅只是文件，并且没有文件名，项目结构都无法还原 ）。如果有 Commit 的话非常好找回，直接回退上一个版本即可，如果连 add 操作都没有的话，除非像 VScode 插件 Local History 或一些 IDE 有记录本地文件，不然恐怕是真的找不回了。。。\n\n## 开始找回\n\n故，此次目的是找回 add 过而未 commit 的文件，首先打开 git bash 输入\n\n```sh\ngit fsck --lost-found\n```\n\n![image-20210815150520759](https://img.kuizuo.cn/image-20210815150520759.png)\n\n进入`.git\\lost-found\\other`\n\n![image-20210815153556495](https://img.kuizuo.cn/image-20210815153556495.png)\n\n然后通过文本编辑器打开即可，如果是代码的话重命名对应的后缀，如果是图片这些就得对应删除前所对应的文件链接。名字是找不回来了，只能手动重命名。\n\n## 事后回想\n\n可能这次丢失的仅仅只是几十个文件，下次丢失的可能就是一个项目了。所以在每次更改代码前做好备份才是首要做的，同时也感谢 git 这么好用的版本控制系统，不然这篇博客可能也不存在。"
    },
    {
      "id": "redis-get-six-digit-number-invitation-code",
      "metadata": {
        "permalink": "/redis-get-six-digit-number-invitation-code",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/Redis获取六位不重复数字（邀请码）.md",
        "source": "@site/blog/develop/Redis获取六位不重复数字（邀请码）.md",
        "title": "Redis获取六位不重复数字（邀请码）",
        "description": "需求",
        "date": "2021-08-11T00:00:00.000Z",
        "formattedDate": "2021年8月11日",
        "tags": [
          {
            "label": "redis",
            "permalink": "/tags/redis"
          }
        ],
        "readingTime": 2.026666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "redis-get-six-digit-number-invitation-code",
          "title": "Redis获取六位不重复数字（邀请码）",
          "date": "2021-08-11T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "redis"
          ],
          "keywords": [
            "redis"
          ]
        },
        "prevItem": {
          "title": "记一次git丢失代码找回",
          "permalink": "/lost-code-find-by-git"
        },
        "nextItem": {
          "title": "Api接口风格",
          "permalink": "/api-style"
        }
      },
      "content": "<!-- truncate -->\n\n## 需求\n\n针对每一个用户（用户量在 10w 以下）随机生成的邀请码（仅限六位数字），**且不重复**\n\n## 思考\n\n如果能把这个不重复条件去除，那么只需要使用`Math.random`然后取小数点后六位就行了，但可惜要求就是不能重复， 要是重复还得了，到时候注册的时候都不知道奖励给那个邀请码账号。同时还要求邀请码在六位且数字，这就导致即使随机生成的，会有一定的可能出现相同的邀请码。\n\n## 解决方案\n\n### 方案 1\n\n先随机生成一个六位随机数字，然后在存的时候判断数据库是否存在该邀请码，如果存在那么就重新生成一个，直到该邀请码不存在，便存入。\n\n优点：方便，如果用户量不大，完全可以\n缺点：用户量上来的情况下，判断邀请码是否存在有可能需要一段时间，并且由于需要判断，故性能欠缺\n\n### 方案 2\n\n利用 redis 的 set 数据类型，先将所有的邀请码存入到 set 中，然后通过 srandmember 随机获取一个数值，在通过 srem 删除该元素即可。\n\n或者也可以通过 list 队列，将预先随机生成的六位不重复数字的所有集合统统添加到队列中，然后获取的时候通过 rpop 或 lpop 获取\n\n优点：相当于空间换时间，无需判断，后期即便用户量上来的，也完全可以重新生成一批（七位或字母）重新导入\n\n缺点：过于依赖 Redis，redis 服务一旦停止，便无法正常获取数据。\n\n## 实现\n\n既然想都想了，那怎么能不实现呢。我这边仅仅是一个测试 Demo，利用的是方案 2，通过 set 数据类型进行获取相关代码如下\n\n### 预先存入数据\n\n```js\nlet key = 'code';\nfunction genCode() {\n  let num = 999999;\n  for (let i = 100000; i < num; i++) {\n    client.sadd(key, i, function (err, data) {});\n  }\n  console.log('数据导入完毕');\n}\ngenCode();\n```\n\n### 获取数据并删除\n\n```js\n// 输出所有成员\nclient.smembers(key, function (err, data) {\n  console.log(data);\n});\n\n// 随机获取一个数据\nclient.srandmember(key, function (err, data) {\n  console.log(data);\n  client.srem(key, data, function (err, data) {});\n});\n```\n\n整体耗时不会超过 3 分钟\n\n通过`console.time()`获取数据耗时如下\n\n```\ndefault: 0.174ms\n```"
    },
    {
      "id": "api-style",
      "metadata": {
        "permalink": "/api-style",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/Api接口风格.md",
        "source": "@site/blog/advice/Api接口风格.md",
        "title": "Api接口风格",
        "description": "前后端数据交互，经常要和 Api 打交道，于是关于 Api 接口的设计，有必要好好写一写",
        "date": "2021-08-06T00:00:00.000Z",
        "formattedDate": "2021年8月6日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "api",
            "permalink": "/tags/api"
          }
        ],
        "readingTime": 3.723333333333333,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "api-style",
          "title": "Api接口风格",
          "date": "2021-08-06T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "api"
          ],
          "keywords": [
            "随笔",
            "api"
          ]
        },
        "prevItem": {
          "title": "Redis获取六位不重复数字（邀请码）",
          "permalink": "/redis-get-six-digit-number-invitation-code"
        },
        "nextItem": {
          "title": "为什么是JavaScript",
          "permalink": "/why-javascript"
        }
      },
      "content": "<!-- truncate -->\n\n前后端数据交互，经常要和 Api 打交道，于是关于 Api 接口的设计，有必要好好写一写\n\n## Restful api 风格\n\n首先还是得说一下**REST 是设计风格而不是标准**，也就是在写 api 接口的时候，喜欢就遵循。\n\n这里举一个常见的 api 接口设计\n\n常见的 CRUD 操作\n\n```js\nPOST /user/list // 获取列表\nPOST /user/get // 获取用户\nPOST /user/add // 添加用户\nPOST /user/edit // 编辑用户\nPOST /user/delete // 删除用户\n```\n\n与之对应 Restful Api 风格\n\n```js\nGET / user // 获取列表\nGET / user / { id } // 获取用户\nPOST / user // 添加用户\nPUT / user / { id } // 编辑用户\nDELETE / user / { id } // 删除用户\n\n// {id} 通过后端路由 参数Params可以获取到\n```\n\n可以看到 Restful 风格相比于正常的 POST 而言，少了请求的路径，而同时使用请求方法字段（GET,POST,PUT,DELETE） 要与之表明的意思也很明确（前提：在增删改查的时候），也就只是增删改查而已。\n\n## 我何时使用 Restful\n\n这里我要说说我个人使用情况下，如果单单只是增删改查的话，我会使用 Restful 风格，好用是一方面，不必在修改数据的还要在 body 中添加 id 这个字段。其次 restful 确实也算广泛，但也仅仅只是在增删改查中。\n\n实际业务中复杂情况太多了，有的时候仅仅这四个请求方法不能很明确的表达所要的意思，例如下面一些业务逻辑\n\n```js\nPOST user/login  发送登录请求\n\nPOST user/register  发送注册请求\n\nPOST user/info 获取个人信息\n\nPOST user/forget 忘记个人密码\n\nPOST user/getCode  获取验证码\n```\n\n此外还有充值，获取消费记录、登录记录等等就不一一列举了，总之这时候我毫不犹豫会使用 POST，可能有人会好奇，为啥获取信息和获取验证码的时候要使用 POST 请求，用 GET 不好吗？好，但后文会说为什么。\n\n## 易猜测 api 接口\n\n实际上，采用了 Restful 风格，几乎一猜就能猜到对应的 api。比如商品管理，无非就是获取商品列表，添加商品，编辑商品，删除商品。同时又传入的是对应的 ID，这要是 Mysql，ID 基本都是按顺序的，万一 api 鉴权没做好，都不知道数据怎么变动的。当然这种情况一般都是比较少见的了。\n\n## 不易加密\n\n上文不是说到为啥都要使用 POST 请求，原因也挺简单的，就是加密，GET 请求一般都不会携带过多参数，针对数据效验的话最多也就一个 MD5 效验，然而是远远不够的，而 POST 所能携带的数据不仅仅是 MD5 效验，还能携带风控算法，二次效验，浏览器指纹算法等等，能保证一定的防破解性。一些看似用 GET 请求方便的接口，但实际都要考虑所包含的风险，就如上面那个发送验证码的接口，如果不加以加密，特别容易仿造出与之对应的协议请求，再次仿造发送也不难。当然，对于这种限制类的业务，还是得要后端进行限制，例如 1 分钟只能发送一条，一天一号只能发送 10 条。\n\n## 最后\n\n其实可以发现绝大多数的网站基本上都不是采用 Restful 风格（貌似用的最多的也就是管理系统了），因为所涉及的业务逻辑实在是太复杂了，不单单只能使用请求方法来表明意思，有时候 Url 路径更能表达明确意思。\n\nRestful 风格想的太美好了，然而实际业务中 很多时候并不能单纯的通过 get post put delete 这四种请求发送来表明真实意义，所以我在增删改查的时候才会使用 Restful api 风格。\n\n在我写项目中遇到一些复杂业务逻辑，我是毫不犹豫使用 Post 请求的，然后通过 url 路径表明 api 所要请求的路径，同时编写 Swagger Api 文档。什么样的风格都因人而异，主要自己用的习惯就行，毕竟 api 接口只是风格，并不作为标准来衡量。"
    },
    {
      "id": "why-javascript",
      "metadata": {
        "permalink": "/why-javascript",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/为什么是JavaScript.md",
        "source": "@site/blog/advice/为什么是JavaScript.md",
        "title": "为什么是JavaScript",
        "description": "关于标题 我想说说自己对一些编程语言的看法，以及我为什么选择 JavaScript 开发，而不是其他主流的编程语言，在一定程度上能帮助一些犹豫选择编程语言的开发者。",
        "date": "2021-01-03T00:00:00.000Z",
        "formattedDate": "2021年1月3日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          },
          {
            "label": "node",
            "permalink": "/tags/node"
          },
          {
            "label": "fontend",
            "permalink": "/tags/fontend"
          }
        ],
        "readingTime": 4.94,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "why-javascript",
          "title": "为什么是JavaScript",
          "date": "2021-01-03T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "javascript",
            "node",
            "fontend"
          ],
          "keywords": [
            "随笔",
            "javascript",
            "node",
            "fontend"
          ],
          "draft": true
        },
        "prevItem": {
          "title": "Api接口风格",
          "permalink": "/api-style"
        },
        "nextItem": {
          "title": "某习通小助手",
          "permalink": "/chaoxing-helper"
        }
      },
      "content": "<!-- truncate -->\n\n关于标题 我想说说自己对一些编程语言的看法，以及我为什么选择 JavaScript 开发，而不是其他主流的编程语言，在一定程度上能帮助一些犹豫选择编程语言的开发者。\n\n**声明：本文没有对任何编程语言进行鄙视，仅作为我个人学习中使用感受于见解。**\n\n像语言的生态，开发效率，运行性能并不作为我的选择因素。\n\n## 为什么是 JavaScript\n\n其实到目前为止应该说的是为什么是 Nodejs，我 js 前端编写的时间并没有 nodejs（后端）时间来的多。\n\n这里我推荐一篇博客，我也反复阅读了几遍，收获颇多，能让你对 Nodejs 有进一步的理解\n\n[Node.js 是什么？我为什么选择它？ (nodejs.red)](https://www.nodejs.red/#/nodejs/base/what-is-nodejs)\n\n其实应该是 为什么是 JavaScript，因为 Nodejs 并不是一个编程语言，只是一个 JavaScript 的运行时，可以通过 JavaScript 来实现对文件读写，等一系列系统操作，也就相当于给 JavaScript 赋予了后端开发的能力。让 JavaScript 不仅能写前端，还能写后端，实现前后端语言的统一。\n\n难道就一个前后端语言统一，就让你选择 Nodejs 开发吗？其他语言不也能搞后端，有的开发效率或性能不必 Nodejs 差，凭什么不选择其他语言。\n\n首选明确下我自身定位，我主要编写的代码都是基于 HTTP 协议进行复现（重新实现）的，俗称脱机操作，不依赖浏览器即可完成一些账号操作（如签到，下单，获取个人信息等等）。而这其中大部分都是基于网页的，也就是说通过 JavaScript 来进行发送 HTTP 请求来达到数据交互的目的。我要协议复现的话，我肯定要捕获对应的数据包，然后模拟对应的请求，来达到协议复现的目的。但这些数据包都是通过 JavaScript 代码实现的，也许这行代码动了手脚，将请求包给加密了，那么我就需要将加密的地方给复现一遍，然后在我的开发者工具（如 VScode）中测试运行。\n\n然后不同语言都有对应的实现方法，比如 JavaScript 中使用了 CryptoJs 实现了 AES 加密，那么 Python 就能直接调用相关的库，或者是直接导入 exejs，然后扣下对应的 JavaScript 代码即可实现该功能，而易语言的话同样也可以调用 V8 引擎，来运行对应的 JavaScript 代码。可本质上，不就是运行 JavaScript 代码吗？我直接使用 JavaScript 运行我自己不是更方便吗？这便是我为什么会选择 Nodejs 开发的原因之一。\n\n### JSON 数据解析\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，从名字也不难看出，就是针对 JavaScript 进行的一种数据格式，如今广泛运用在各种数据交互地方。\n\n而这正是最致命的一个地方，因为网页中有大量的数据交互，而这些数据格式基本上都是 JSON 传输，要么就是通过 JSON 对象转为 xxx-from 格式。总之 JSON\n\n而\n\n至少在我体验过 Php（ThinkPhp），Python（Flask），Go（Gin）的使用过程中，JSON 格式绝对都没有 JavaScript 自带的好用好写。\n\n什么你说 JavaScript 不好维护，这年头用 Node 写后端还用 JavaScript，要么新手，要么小项目，TypeScript 类型检查，代码维护都不是事，\n\n有的时候三天要你写一个网站出来，别说写 interface 了，快点上线才是王道，后续开发维护再写都来的及，到时候 test 都有够写的。当然，如果开发时间没那么紧的话，肯定要\n\n### 简单上手\n\n### 前后端统一\n\n### 异步\n\n### 跨平台\n\n如果一门语言只能在 window 上或是 linux，那么注定\n\n### 设计理念\n\n动态类型\n\n### 生态\n\n一门语言火不火，我认为生态是最重要的，即便这门语言你设计的再好，性能极佳，没人使用终将没人使用，\n\n而取决于开发者是否使用，则是生态，\n\nnodejs 拥有全球最大的包管理的工具—npm，你想要实现的功能，在这里基本上没有找不到的。\n\n## 语言对比\n\n实际上这篇的大部分内容我在半年前就大致写完了，但迟迟没有发布，主要是想多接触几门主流的编程语言，去了解一下之间的差异，才更有说服我去使用 JavaScript\n\n即便我说了这门多优点，但还有些我认为不够的地方\n\n对于初学者而言，JavaScript 有很多不易于理解的，比如\n\n弱类型语言，不过这个在 TypeScript 中,也是我为什么推荐是用 TypeScript\n\njs 可以说是这几年才大火起来，\n\nnodejs 发布 2009\n\nes6 语法 2015\n\nreact 2016\n\nangular 2013\n\n有太多人都认为 js 只能写前端了\n\n我举几个我接触 js 的例子\n\nTensorFlow。js 人工智能框架\n\nauto。js 一个编写手机自动化脚本的框架\n\nfrida 使用 js\n\nelectorn 编写桌面级\n\n## 国内 Nodejs 开发者\n\n相对于其他语言，国内 Nodejs 的开发者会略显少数，一度让我认为我所选择的语言到底是对是错.\n\n## 最后\n\n特别想感谢 NodeJs 的创造者，即便人家都已经不在 NodeJs 社区，而转去搞 Go 的分布式系统开发。\n\n你可以说我是 js 吹，但不可否认 js 在行业内的地位。\n\n即便标题的名义表示我是名 JavaScript 开发者，但在这个行业只专研一门语言技术是远远不够，也就是我为什么还会尝试去学习其他的编程。\n\n不断学习 才是"
    },
    {
      "id": "chaoxing-helper",
      "metadata": {
        "permalink": "/chaoxing-helper",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/project/某习通小助手.md",
        "source": "@site/blog/project/某习通小助手.md",
        "title": "某习通小助手",
        "description": "前言",
        "date": "2021-01-02T00:00:00.000Z",
        "formattedDate": "2021年1月2日",
        "tags": [
          {
            "label": "project",
            "permalink": "/tags/project"
          },
          {
            "label": "easy-language",
            "permalink": "/tags/easy-language"
          }
        ],
        "readingTime": 26.906666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "chaoxing-helper",
          "title": "某习通小助手",
          "date": "2021-01-02T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "project",
            "easy-language"
          ],
          "keywords": [
            "project",
            "easy-language"
          ],
          "image": "/img/project/chaoxing-helper.png",
          "draft": true
        },
        "prevItem": {
          "title": "为什么是JavaScript",
          "permalink": "/why-javascript"
        },
        "nextItem": {
          "title": "为什么我不用七牛云",
          "permalink": "/why-i-dont-use-qiniu-cloud"
        }
      },
      "content": "<!-- truncate -->\n\n## 前言\n\n**声明，本文与该软件仅用于学习技术交流，请勿将软件用于非法途径，本作者不承担一切法律责任，望使用者须知。若影响到贵公司正常运行，请联系本人删除。**\n\n:::info\n\n注：本文适用于有编程基础的，会 POST 请求那更好，不会也不妨碍，多了解总没错。\n\n:::\n\n## 使用语言\n\n有人会很好奇这个软件到底是怎么运行的，为啥可以实现自动完成视频，作业。借此写个完整的该软件开发过程，供各位学习，整个开发过程真不算的难，听我慢慢道来（尽可能详细），~~但你看完后，写不出来，大概率也不会想写~~。\n\n既然是写软件，那怎么能不说说编程语言，首先这个软件是基于易语言开发的，初学易语言的三个月所写的练手项目，本是写来给我自用的，不过确实好用，那为啥不分享出去呢。\n\n实际上我也考虑过开源，奈何多次审核不通过，累了，就懒得开源了。\n\n首先，说说为啥会选择易语言，有一部分原因是因为我那时候正好在学易语言，哪怕现在如果要开发一个类似于这样的软件，我也会优选易语言（在不考虑兼容与报毒情况下）。原因其实非常简单，好写，太好写了，我记得那时候的第一版超星刷课只花了一周时间，实现了自动完成视频，那还只是我没什么开发经验的前提下（借鉴了外面的一份源码）。再者也是最主要的一部分，写的软件是基于什么平台，很显然，桌面级应用 Windows 平台。那就少不了交互界面了，而正是这个交互界面，让我劝退了 javascrpit 与 python。不是说他们不行，而是写起来绝对比易语言复杂。如果你有接触过这两者相关的估计会知道，尤其还是实现自动完成任务的功能，基本上是不提供界面而言。也就让代码的可操作性少了非常多，这还不是最致命的，致命的是使用者不是人人都学程序了，即使发你一个 python 文件，但他大概率是不会听你大费周章的安装，输入，原因就是麻烦（如果这份代码好用的话当我没说过）。\n\n说这些都不如直接来一个 exe 可执行文件，让用户去点击操作，然后通过一个日志输出显示给用户，告知用户当前程序执行进度。可能有人又会问，那为啥不用 C#，VB.net，QT 等，我 tm 要是会的话，也不会用易语言来写了，易语言敲代码体验很差，如果用过其他的文本编辑器，就特别不想用易语言（反正我是这样，真的难用），毕竟易语言都是 20 年前的产物了，能活到现在就不错了。但不得不说，易语言是真的好写，好用，好上手。\n\n语言不分贵贱，能写出好的程序都是好语言，所以本文都是以本人从易语言开发角度来讲述，如果你恰好有程序开发经验，或有想接触的，本文或许能给予你一些帮助。\n\n## 找源码\n\n既然介绍完所用语言，那么就开始编写代码吧，不过在此之前先别急，这一步尤为关键，能极大的节省你所开发的效率，那就是搜索是否的相关源码或者软件。最好是与自己所开发的语言一致。\n\n这是我当时编写软件前在吾爱破解论坛上搜索到的相关源码，如下：![image-20200925173801271](https://img.kuizuo.cn/image-20200925173801271.png)\n\n看看软件源码的界面![image-20200925173832002](https://img.kuizuo.cn/image-20200925173832002.png)\n\n在比对一下我的修改了数十次的。\n\n![image-20201220072514909](https://img.kuizuo.cn/image-20201220072514909.png)\n\n没错，我就是基于这个软件改的，还是有点相似之处的。但事实上这个原作者的代码在我翻阅到时就已经不能用了，并且还有很多弊端，例如还需要输入学校名称，输入验证码，这对用户体验来说的是非常烦人的。\n\n同时在这份源码上只能说是一份临时品，几乎没有维护可言（虽然易语言写的软件多半都不好维护），不过有一个核心加密算法，也就是最终提交视频的一个核心算法，让我省去 JS 逆向分析的时间（后文会说到，不过以我那时候来看，这个 JS 自行解决也不成问题）\n\n那时候搜索到的还有其他的相关脚本，例如大多数人都了解过的油猴插件。后文有简单讲述到，因为和本文涉及到的不相关。\n\n## 执行流程\n\n找到相关源码或软件，就已经离项目完成快了一半了，接着只需要在该软件上进行修改，已达到自己的目的。当然，如果要补充一些功能还需要花费很多时间的。\n\n### 页面设计\n\n我优先做的就是修改 UI 界面，做到竟可能的不丑，且符合个人风格。而这部分就是拖拽组件，移动组件，微调组件，平行垂直等操作，没啥可言的。我所用的都是 windows 自带的组件，加上我不会自绘组件，只好借助皮肤模块来美化界面了。美化的效果如下图\n\n![image-20201226062612827](https://img.kuizuo.cn/image-20201226062612827.png)\n\n实际上，页面设计相关就到此结束了，我能做的也只是尽量不丑，毕竟不会自绘组件，用原生自带的组件就这样了。当然，后面关于怎么数据渲染到组件这些会写到的。\n\n### 登录\n\n接着就是要说实现原理，首先回想一下，我们如果手动去一个个看视频，答题，需要干嘛，那肯定是登录了，不登录学习通那边怎么知道是你，那么在浏览器中，登录只是输入下账号，密码，然后点击登录按钮就完事了。然而实际原理不只是点击按钮这么简单，实则是发送一个 http 请求给后端，后端进行效验结果比对，返回结果，我简单叙述一下，放 js 代码来看看：\n\n![image-20201226063607140](https://img.kuizuo.cn/image-20201226063607140.png)\n\n具体看图片\n\n![image-20201226064003045](https://img.kuizuo.cn/image-20201226064003045.png)\n\n完整关键代码如下：（已删除不必要代码）\n\n```js\n//手机号+密码登录\nfunction loginByPhoneAndPwd() {\n  var phone = $('#phone').val().trim()\n  var pwd = $('#pwd').val()\n  var fid = $('#fid').val()\n  var refer = $('#refer').val()\n  if (util.isEmpty(phone)) {\n    util.showMsg(true, 'phoneMsg', '请输入手机号', true)\n    return\n  }\n  if (util.isEmpty(pwd)) {\n    util.showMsg(true, 'pwdMsg', '请输入密码', true)\n    return\n  }\n  var t = $('#t').val()\n  if (t == 'true') {\n    pwd = $.base64.btoa(pwd, 'UTF-8')\n  }\n  // --------------------------------------------------------\n  $.ajax({\n    url: '/fanyalogin',\n    type: 'post',\n    dataType: 'json',\n    data: {\n      fid: fid,\n      uname: phone,\n      password: pwd,\n      refer: refer,\n      t: t,\n    },\n    success: function (data) {\n      if (data.status) {\n        var url = ''\n        if (data.tochaoxing) {\n          var path = window.location.protocol + '//' + window.location.host\n          url = path + '/towriteother?name=' + encodeURIComponent(data.name) + '&pwd=' + encodeURIComponent(data.pwd) + '&refer=' + data.url\n        } else {\n          url = decodeURIComponent(data.url)\n        }\n\n        if (top.location != self.location && $('#_blank').val() == '1') {\n          top.location = url\n        } else {\n          window.location = url\n        }\n      } else {\n        if (data.weakpwd) {\n          window.location = '/v11/updateweakpwd?uid=' + data.uid + '&oldpwd=' + encodeURIComponent($('#pwd').val()) + '&refer=' + refer\n        } else {\n          var msg = util.isEmpty(data.msg2) ? '登录失败' : data.msg2\n          msg = '密码错误' == msg || '用户名或密码错误' == msg ? '手机号或密码错误' : msg\n          util.showMsg(true, 'err-txt', msg)\n        }\n      }\n    },\n  })\n}\n```\n\n代码并不长，一个很简单的 post 登录，这里我会一一进行分析\n\n```js\nvar phone = $('#phone').val().trim()\nvar pwd = $('#pwd').val()\nvar fid = $('#fid').val()\nvar refer = $('#refer').val()\nif (util.isEmpty(phone)) {\n  util.showMsg(true, 'phoneMsg', '请输入手机号', true)\n  return\n}\nif (util.isEmpty(pwd)) {\n  util.showMsg(true, 'pwdMsg', '请输入密码', true)\n  return\n}\nvar t = $('#t').val()\nif (t == 'true') {\n  pwd = $.base64.btoa(pwd, 'UTF-8')\n}\n```\n\n在分割符的前一部分，获取我们表单中的手机号(phone)，密码(pwd)，学校 id(fid)，以及不重要的 refer，同时判断手机号，密码是否为空，并给出相应提示，同时这里的 pwd 还进行了 base64.btoa，也就是 Base64 编码处理过。这里我就模拟一下这些数据\n\n```js\nphone = '15212345678'\npwd = 'a123456'\npwd = 'YTEyMzQ1Ng==' // Base64编码后的结果\nfid = '12345' // 也可以不指定学校 填-1\nrefer = 'http://passport2.chaoxing.com'\n```\n\n然后再看剩余的一部分,主要就关注这些:\n\n```js\n$.ajax({\n  url: '/fanyalogin',\n  type: 'post',\n  dataType: 'json',\n  data: {\n    fid: fid,\n    uname: phone,\n    password: pwd,\n    refer: refer,\n    t: t,\n  },\n  success: function (data) {\n    //....\n  }\n}\n```\n\n也正是因为这几行代码，将我们的数据发送给了学习通的服务端，并将数据返回给我们，这里我抓个数据包看看数据是怎么样的\n\n```http\nPOST /fanyalogin HTTP/1.1\nConnection: Keep-Alive\nContent-Type: application/x-www-form-urlencoded; Charset=UTF-8\nAccept: */*\nReferer: https://passport2.chaoxing.com/login?&newversion=true\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\nOrigin: https://passport2.chaoxing.com\nx-requested-with: XMLHttpRequest\nHost: passport2.chaoxing.com\nContent-Length: 94\n\nfid=12345&uname=15212345678&password=YTEyMzQ1Ng==&refer=http://passport2.chaoxing.com&t=true\n```\n\n认真看上面最后一行，有没有发现这些数据不就是我们刚刚上面模拟的数据。再来看返回数据\n\n```http\nHTTP/1.1 200 OK\nServer: Tengine\nDate: Fri, 25 Sep 2020 11:50:30 GMT\nContent-Type: text/html;charset=utf-8\nConnection: keep-alive\nSet-Cookie: JSESSIONID=625EBEBB8C9A307910975B8A6306EE13; Path=/; HttpOnly\nSet-Cookie: lv=3; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/\nSet-Cookie: uf=b2d2c93beefa90dcc0dd308bdb4e3ac7c15d612bf3f08318fdb57793f3e0b0e8e06d6354b86e5f8c6733e63a87a57410913b662843f1f4ad6d92e371d7fdf644cb407fe2f4a1b7e3102289339c6dea121471850d8bf7e34cbde8ab62ef4efbfc29d661c57520821b; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/\nSet-Cookie: _d=1601034630583; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/\nSet-Cookie: vc=D117659BD1295E4489AED8ED14E8A8D8; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/; HttpOnly\nSet-Cookie: vc2=5B73047EF8C636D19D282B878FC42D4A; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/; HttpOnly\nSet-Cookie: vc3=Lptknj6gO2EVnnAWOW0A1O0d0RGWzgO1jVDtKiGtxlqX7dH5uAz84KoWDf2Y9v%2Biw2V3RyKd2gNXf%2BMVKt2HKmJzYK1vt%2BBHu%2B%2BXwG3NtJAWvXygxxcRYlSwCt%2BDv0r8JkrhqgJxJQV2VkMVMon8PABIuJdJKudVTQR%2FP6u2pfY%3D2dd5ab18abc4e7b47fdeb363a13a7c64; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/; HttpOnly\nSet-Cookie: xxtenc=0fd26095d768e519a53edd2f4ba4c9e9; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/\nSet-Cookie: DSSTASH_LOG=C_38-UN_9502-US_42736002-T_1601034630584; Domain=.chaoxing.com; Expires=Sun, 25-Oct-2020 11:50:30 GMT; Path=/\nSet-Cookie: route=1b37a788fe3a8c39de935217be0d9f7a;Path=/\nContent-Length: 56\n\n{\"url\":\"http%3A%2F%2Fi.mooc.chaoxing.com\",\"status\":true}\n```\n\n**现在只要注意最后一行**，这是登录成功的返回结果，那如果密码错误呢，返回的结果如下\n\n```json\n{ \"msg2\": \"用户名或密码错误\", \"status\": false }\n```\n\n那么既然简单了明白了一下基本的登录实现原理，能不能模拟一下这样的请求，替换一下其他人的账号密码，然后发送给服务端，当然可以，看看用易语言代码是怎么实现的这样的登录功能。\n\n![](https://img.kuizuo.cn/image-20201226070501146.png)\n\n注意我划线的两个部分，实际上在 POST 请求中，要做的也就是替换一系列的数据，已达到模拟请求，并接受服务端接收的数据。\n\n不过这里我还得小提一句，看到上面的返回响应中，有好几个 Set-Cookie，这里 Cookie 是服务端返回的，并且加密处理了，而正是这个 Cookie，保存了我们的登录凭证，使得下次我们请求的时候会将这些 Cookie 携带上去，这样服务端才能知道哪个请求是谁发送的。这样才能获取到哪个学生的信息，如课程信息，作业信息等等。\n\n凭什么我发送一个请求给服务端，然后就能登录成功，就可以不用借用浏览器，来实现登录账号？或者说本质上，浏览器数据交互也是通过 HTTP 协议，而 HTTP 协议就是这样，至于实现原理，这里我不涉及太多相关的，你只需要知道可以就行，但有时候并不像上面这么简单（请接着看下文例子）。\n\n从上面的例子中，~~也许~~你已经能知道，只要发送一个请求的事情，就可以登录，就能获取对应的信息，实际上，你只要知道下面这一句话：\n\n**浏览器本质的操作，就是向服务器发送请求，而软件所做的就是模拟请求，已达到获取数据。**\n\n而操作流程，先抓包获取到发送的数据，然后再模拟数据发送给服务端，就可以达到相对应的操作后文都将以这样的操作为例，以至于实现原理，就涉及到相关专业的知识了，同时模拟请求，能绕过浏览器自身的限制（JS 的限制）.\n\n### 获取课程列表\n\n这里我就以获取课程列表数据，并通过 DOM 解析，并将其显示在软件上来演示。\n\n现在已经登录成功了，那么我现在就向服务器发送获取课程信息的请求，在这里我封装成一个易语言的函数，如下几个部分：\n\n```\nurl ＝ “http://mooc1-1.chaoxing.com/visit/courses/study?isAjax=true&debug=false”\nhttp.Open (“GET”, url)\nhttp.Send ()\nresponse ＝ http.GetResponseTextU2A ()\n```\n\n此时 response 为 html 文件文本，像这样的\n\n```html\n<ul class=\"clearfix\">\n\n \t<li style=\"position:relative;\" class=\"courseItem curFile\">\n\t\t<input type=\"hidden\" name=\"courseId\" value=\"215497310\" />\n\t\t<input type=\"hidden\" name=\"classId\" value=\"34423626\" />\n\n\t\t<div class=\"Mcon1img httpsClass\" >\n\t\t\t<a     href='/visit/stucoursemiddle?courseid=215497310&clazzid=34423626&vc=1&cpi=166457817'  target=\"_blank\"   >\n\t\t\t\t<img src= https://p.ananas.chaoxing.com/star3/270_160c/56d94e43e4b0dfadae7a3437.jpg    onerror=\"nofind(event)\" imagedata='https://p.ananas.chaoxing.com/star3/270_160/56d94e43e4b0dfadae7a3437.jpg' width=\"270\" height=\"169\" />\n\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<a href=\"javascript:void(0)\" class=\"move\"  style=\"right: 0px;\"  title=\"移动到\">\n\t\t\t\t移动到\t\t\t</a>\n\t\t</div>\n\t\t<div class=\"Mconright httpsClass\">\n\t\t\t \t\t\t<h3 class=\"clearfix\" >\n\t\t\t\t<a class=\"courseName\"  href='/visit/stucoursemiddle?courseid=215497310&clazzid=34423626&vc=1&cpi=166457817' target=\"_blank\" title=\"创业基础\">创业基础</a>\n\t\t\t<i> </i>\n\t\t\t</h3>\n\t\t\t\t\t\t\t\t\t\t<p title=\"王艳茹\">王艳茹  </p>\n\t\t\t\t<p title=\"中国青年政治学院\">中国青年政治学院  </p>\n\t\t\t\t<p title=\"默认班级\">默认班级</p>\n\t\t\t\t\t    \t\t   <p class=\"\">课程时间：2020年11月12日-2021年01月10日</p>\n\t\t\t\t\t\t\t\t\t<p class=\"Mconrightp3\" style=\"display:none;\">\n\t\t\t</p>\n\t\t</div>\n\t</li>\n   <li class=\"addLi\">\n\t<div class=\"\">\n\t\t<a href=http://www.fanya.chaoxing.com/schoolcourse/zixuan2?fid=11231   target=\"_top\"  class=\"Mdelc2dt\" style=\"height: 202px;padding-top: 76px;\" title=\"添加课程\"><span></span></a>\n\t</div>\n </li>\n </ul>\n```\n\n可以看到课程信息以及相关链接，接下来要做的就是根据 DOM 对象，提取这些课程数据，下为我那时候解析的代码：\n\n![image-20210102035545981](https://img.kuizuo.cn/image-20210102035545981.png)\n\n根据 CSS 类名 courseItem，获取课程单元块以及课程数，然后通过遍历 courseItemList，同时通过 CSS 选择器选择到对应的 HTML 标签，获取到我们想要的数据，通过一个自定义数据类型（这里非对象），将其存在课程列表数组内，最后将这些数据通过超级列表框设置到页面上。也就是如下图这样\n\n![image-20210102035927028](https://img.kuizuo.cn/image-20210102035927028.png)\n\n同样的获取章节列表，作业列表，考试列表，甚至是一些评论列表，也都是通过 DOM 解析，获取其数据，存储到数组内，然后根据章节名或者 id 来获取数组成员，已达到指定课程完成任务。\n\n### 开始刷课（重点）\n\n如果只是获取数据那怎么能够，而刷课才是软件的主要目的，首先要刷课，就必须要指定课程，这里指定课程也就是 列表框中选中即可，此时点击开始刷课便能开始任务，这里来看看刷课的代码\n\n![image-20210102040540378](https://img.kuizuo.cn/image-20210102040540378.png)\n\n就是判断用户有无登录，有无任务在执行，有无选课，然后将配置写入到配置文件，方便下次打开还是上次配置，同时设置模式，是要完成那一部分任务，最后将按钮设置为禁止，不可点击（所以为啥我不一开始就直接禁止开始刷课为假呢），最后启动一个线程来执行，在主线程执行会导致窗口卡顿等现象。然后下面才是正在的执行逻辑了。\n\n#### 获取章节列表\n\n![image-20210102041501299](https://img.kuizuo.cn/image-20210102041501299.png)\n\n添加了注释，就懒得在打字一个个说明了，执行逻辑并不难，也就是判断，然后执行，接着要到刷视频和题这个方法，因为最主要还是这个代码在干什么。（后面也会将写上代码注释，方便大家理解）\n\n#### 开始刷视频和题\n\n![image-20210102044334946](https://img.kuizuo.cn/image-20210102044334946.png)\n\n开始循环访问选择夹，接下来代码有点多，执行流程也就是循环，判断，我简化了很多，认真看\n\n![image-20210102050722756](https://img.kuizuo.cn/image-20210102050722756.png)\n\n这里我要提一下，上面的 mArg 数据是什么，是一段 JSON 数据文本，长下面这样\n\n```json\n{\n  \"attachments\": [\n    {\n      \"headOffset\": 663000,\n      \"jobid\": \"1596706035431101\",\n      \"otherInfo\": \"nodeId_349140314-cpi_159793445\",\n      \"isPassed\": true,\n      \"property\": {\n        \"jobid\": \"1596706035431101\",\n        \"switchwindow\": \"true\",\n        \"size\": 443706433,\n        \"fastforward\": \"true\",\n        \"hsize\": \"423.15 MB\",\n        \"module\": \"insertvideo\",\n        \"name\": \"12.13.mp4\",\n        \"mid\": \"8562913227181596706035139\",\n        \"type\": \".mp4\",\n        \"doublespeed\": 1,\n        \"objectid\": \"902ca19c673c7fa256702b6211c9df07\",\n        \"_jobid\": \"1596706035431101\"\n      },\n      \"mid\": \"8562913227181596706035139\",\n      \"playTime\": 663000,\n      \"type\": \"video\",\n      \"aid\": 600168224,\n      \"objectId\": \"902ca19c673c7fa256702b6211c9df07\"\n    }\n  ],\n  \"defaults\": {\n    \"fid\": \"1617\",\n    \"ktoken\": \"ac0308fc1f7a84019740f1bebfd0b733\",\n    \"mtEnc\": \"a70ce1e7dac8d0d2e6082e2a95d002a3\",\n    \"isFiled\": 0,\n    \"ignoreVideoCtrl\": 0,\n    \"reportUrl\": \"https://mooc1-2.chaoxing.com/multimedia/log/a/159793445\",\n    \"chapterCapture\": 0,\n    \"userid\": \"157041903\",\n    \"reportTimeInterval\": 60,\n    \"initdataUrl\": \"https://mooc1-2.chaoxing.com/richvideo/initdatawithviewer\",\n    \"knowledgeid\": 349140314,\n    \"schooldoublespeed\": 0,\n    \"qnenc\": \"b2a727eed024085321062c005680e1ef\",\n    \"defenc\": \"bca5e389669154f0fd1fb0208b2ad655\",\n    \"clazzId\": 34189060,\n    \"cardid\": 311180449,\n    \"imageUrl\": \"https://p.ananas.chaoxing.com/star3/270_169c/f01bc30632e023f83b3e8879cdeea2c7.jpg\",\n    \"lastmodifytime\": 1609462354000,\n    \"state\": 0,\n    \"courseid\": 215403857,\n    \"cpi\": 159793445,\n    \"subtitleUrl\": \"https://mooc1-2.chaoxing.com/richvideo/subtitle\"\n  },\n  \"control\": true\n}\n```\n\n通过 JSON 解析工具，可以获取到章节下的课件内容信息。比如视频时长，视频通过状态，视频 id，等等\n\n![image-20210102074018606](https://img.kuizuo.cn/image-20210102074018606.png)\n\n取到我们想要的数据，并存为变量即可，接着才是关键所在，获取到了课件信息，同时判断课件类型为视频，并且视频的通过状态为 false，那么接下来就是要提交视频了。相关代码如下\n\n#### 提交视频\n\n![image-20210102052457877](https://img.kuizuo.cn/image-20210102052457877.png)\n\n其中这里提交视频就一个请求，也就是这个请求，服务端才知道你视频看了多少，并且将你的观看时长记录到数据库中，最终拼接的 url 比如这样的 `https://mooc1-2.chaoxing.com/multimedia/log/a/159793445/66ee5f706ccc9e58ab0ea383a83e665c?clazzId=34189060&playingTime=935&duration=935&clipTime=0_935&objectId=34ad66ae9778a00c6bfde810f12431ac&otherInfo=nodeId_349140316-cpi_159793445&jobid=1595816983931186&userid=257041903&isdrag=4&view=pc&enc=f26c618c0e0af1147fe2f4ce7b5e8f95&rt=0.9&dtype=Video&_t=160954150532`\n\n当然这个请求没这么好伪装出来，你在上面这几行就可以看到这些参数的复杂了，并且还有相关的加密，如果你随便发送一个请求，服务器鸟都不会鸟你的。伪装还算简单，照葫芦画瓢就完事了，而加密你就需要了解对应的加密算法和 JS 逆向了。这里如果我改掉其中一个必要的请求，那么将会出现如下界面\n\n```jsx live\n<!doctype html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n<title>403</title>\n<style>\n.main{height:255px;margin:0 auto;margin-top:15%;font-size:14px;color:#999; width: 350px;}\n.font_top{padding-top:45px;display:inline;}\n</style>\n</head>\n<body>\n<div class=\"main\">\n<p class=\"font_top\">>_< 很抱歉，您没有权限访问这个页面！  (403)</p>\n<p style=\"font-size: 12px; color: #ddd;\">112.48.28.255<br/>mooc-2166199849-8f1c1</p>\n</div>\n</body>\n</html>\n```\n\n所以，POST 请求最主要的之一，就是拼接参数，去模拟请求，在说到这里的加密 enc，先看看原文本长啥样\n\n```\n[34189060][157041903][1595816983931186][34ad66ae9778a00c6bfde810f12431ac][935000][d_yHJ!$pdA~5][935000][0_935]\n\n将上面这段数据通过MD5加密即可获取enc为\nf26c618c0e0af1147fe2f4ce7b5e8f95\n\n通过易语言拼接如下\nweb参.enc ＝ 取数据摘要 (到字节集 (“[” ＋ web参.classId ＋ “]” ＋ “[” ＋ web参.userid ＋ “]” ＋ “[” ＋ web参.jobid ＋ “]” ＋ “[” ＋ web参.objectId ＋ “]” ＋ “[” ＋ 到文本 (web参.playingTime × 1000) ＋ “]” ＋ “[d_yHJ!$pdA~5]” ＋ “[” ＋ web参.duration ＋ “000]” ＋ “[0_” ＋ web参.duration ＋ “]”))\n```\n\n至于我怎么知道加密点的，就涉及到 JS 逆向，就需要看网页内的 JS 文件，这里就不在赘述了。\n\n然后我们每提交一次视频的请求，只要将 playingTime 播放时长，改为视频时长，就能实现秒刷，原理就是通过协议发送请求。但也有问题所在，我提交一次，服务端记录一次，并且间隔为 1 分钟，我 1 分钟内在提交一次视频完成的请求都将不会记录时长，所以这里的秒刷也只是将视频章节内的视频秒刷了，实际上要挂时长，还得每隔一分钟提交一次才行。（学习通是这样的）\n\n顺便抓个提交测验的请求的包，看看模拟请求有多烦躁。\n\n```\n// url (请求地址)\nhttps://mooc1-2.chaoxing.com/work/addStudentWorkNewWeb?_classId=34189060&courseid=215403857&token=5219a574b7571639ea6b9770bbc23da2&totalQuestionNum=cd8c29480d9c16f5a675e8c2c459245c&ua=pc&formType=post&saveStatus=1&pos=841bf6c56a6d8179e801f5743b&rd=0.5328632906746906&value=(285|546)&wid=11020928&_edt=1609545107317285&version=1\n\n// post的data数据(拼接题号,选项,课程id,班级id,测验id等等......)\npyFlag=&courseId=215403857&classId=34189060&api=1&workAnswerId=50407707&totalQuestionNum=cd8c29480d9c16f5a675e8c2c459245c&fullScore=100.0&knowledgeid=349140316&oldSchoolId=&oldWorkId=62df20e345ff464d9bbe4ea021025cc5&jobid=work-62df20e345ff464d9bbe4ea021025cc5&workRelationId=11020928&enc=&enc_work=5219a574b7571639ea6b9770bbc23da2&userId=157041903&answercheck209790637=A&answercheck209790637=B&answer209790637=AB&answertype209790637=1&answer209790638=false&answertype209790638=3&answer209790639=true&answertype209790639=3&answerwqbid=209790637%2C209790638%2C209790639%2C\n\n// 最后提交请求的响应文本(根据status 是否为true来判断是否提交成功,msg为返回结果文本)\n{\"msg\":\"success!\",\"stuStatus\":4,\"backUrl\":\"\",\"url\":\"/api/work?courseid=215403857&workId=ca62b882b279427b9d24876daba4e2ba&clazzId=34189060&knowledgeid=349140316&ut=s&type=&submit=true&jobid=work-62df20e345ff464d9bbe4ea021025cc5&enc=061df255135b657c3aef35c5afc711c4&ktoken=c09603936670a079289c0d1488ab0f63\",\"status\":true}\n```\n\n想这样的自动完成任务软件（协议），要做的就是抓包（截包），分析数据，模拟数据，然后在通过代码方式生成出来，最终提交给服务器。\n\n通过这样的流程，就能实现自动刷视频，类似的章节测验与考试无非也就是判断，然后执行发送请求。对这个软件而言，就封装了好几个方法了\n\n![image-20210102073628331](https://img.kuizuo.cn/image-20210102073628331.png)\n\n而这还只是超星提交的操作，软件界面相关的我就不多演示了。总之，整体执行的流程就是像上面那样，软件怎么编写，就看开发人员了。\n\n## 关于协议与脚本\n\n上面说了一大堆，相信还是有大多数人迷迷糊糊的，正常，不过听不听得懂无所谓，了解即可，这里我需要说一下，协议与脚本的一些区别，实际上，简单比较下也能很明显的感受到两者的区别，甚至可以说，这两者的本质毫不相干。\n\n- 脚本\n\n需要依托在宿主上（浏览器），不然也无法执行代码（js 或填表），来实现点击提交操作。脚本要做的，也就是将人手动操作的，通过自动化方式来操作。\n\n- 协议\n\n则是基于 HTTP，只需要发送请求，就可以做到脱机（浏览器），以达到高效执行，而这是脚本做不到的，同时编写难度也是高于脚本。\n\n发送完成视频的请求，就能绕过浏览器内置的拖拽视频进度条，倍数等限制，而浏览器本身也是基于协议来实现的，也就是将这些提交请求的代码（JS）放在浏览器客户端，然后判断执行。而你的所有操作最终都将通过 HTTP 请求来发送，来达到数据交互的目的。\n\n实际上协议能做的远非如此，我这里简单举几个例子吧，例如抢购，机器人，等等，而这些用脚本都是执行不了，要么执行效率贼差。\n\n实际上在一开始写这款软件时（学易语言和 JS 三个月左右），我是知道脚本与协议的区别，并且一开始想使用脚本来写，奈何，那时候的技术，只停留在使用按键精灵或大漠插件，来实现 PC 端操作，而要操作浏览器内置 DOM 元素，则需要网页填表以及一些前端基础，也正是因为不会这些相关的，但又想写个练手项目，于是就选择使用协议去完成，并且最终成功写成。\n\n现在想想，也正应该感谢这款软件的开发经历，对我技术提升以及后续的学习兴趣至关重要。可以说没有这个软件给我带来的成就感，也许就不会有这篇文章了。（貌似有点提早感慨了)\n\n## 关于风险\n\n这也是很多人可能会担心的，毕竟软件自动执行嘛，我咋知道安全不安全，会不会导致我账号异常等等。不过这实际上要看情况的。\n\n就先这么说，你在 10 秒内，同时请求了 20 条视频，而后端是知道你请求了 20 条视频，因为你获取了后端的资源，然后后端一看，这丫的不对劲啊，手速这么快，有可能吗？后端不会觉得你手速快，而只会觉得，你像上面代码那样来短时间内批量提交视频的。所以就会给记录异常\n\n而且这也要看平台的\n\n- 学习通\n\n学习通目前提交过快，就会出现验证码，并未有使账号异常冻结等操作。\n\n- 职教云\n\n视频提交间隔要在 5 秒以上（我目前测试情况下是这样），课件等无限制。\n\n- 其他平台（没具体了解过，目前手头就写了这两个）\n\n那如果是正常速度提交，尽可能的模拟人为的操作呢，那也未必就没风险，只要他们后端想，修改一下接口，就能知道你操作是否异常了，比如我更改了加密算法，导致了你提交请求中和服务端效验失败，那我就可以认为你是通过外来手段篡改了请求数据，也就非法操作，就认为你不是非人为（非浏览器）操作。\n\n然而这种情况很少，一般来说，网站部署运行了，除非特别大的改动，基本上是不会频繁的更换源码，需要不断测试。基本上也就是看平台了\n\n我一开始只写了刷视频的，后面对接了题库，就开始写刷题的，然后有验证码就开始过验证码，最终还为软件添加一个网络验证，这每一步的过程都是深夜在电脑前，望着别人完全看不懂的代码，想，改，不过我庆幸我学了这些技术，因为它确实让我目前能写很多能用的项目。从这个超星学习通助手还学到的其他技术，下面一一列举\n\n## 一些相关技术\n\n### 完美验证系统\n\n这个是用于验证码识别的，我当初为了解决超星的登录与提交题目时出现的验证码，就必须要识别出该验证码，于是我找到了完美验证码系统，我先放一张图\n\n首先说下识别的实现原理：获取到验证码的图片，比如下面这张\n\n![ABCWF](https://img.kuizuo.cn/ABCWF.jpg)\n\n那么我先把干扰线去掉，并且二值化处理一下，变成下面这样\n\n![image-20200924232042428](https://img.kuizuo.cn/image-20200924232042428.png)\n\n然后这时候开始抠图，抠出 A，B，C，W，F 字符，比如抠出 A 字符\n\n![image-20200924232357263](https://img.kuizuo.cn/image-20200924232357263.png)\n\n接着，做几百张这样的抠图图片，如\n\n![demo4](https://img.kuizuo.cn/demo4.gif)\n\n然后交给系统识别就行了，他会比对你做的字模，然后进行图片相似度比对，最终将识别结果返回给你，看似很简单，的确也很简单，但是我扣这些图，扣了一周，最终识别效果也就只有百分之 50 这样，真的吐了。但是没办法，那时候学的浅，哪里还知道深度学习和 ocr 的识别，就这样坚持硬着头皮扣了一周，然后将这些字模全部导出置识别库用于调用。最终整体识别效果,如下图\n\n![image-20200924233820001](https://img.kuizuo.cn/image-20200924233820001.png)\n\n甚至还看了一个图象识别的教程手写一个类似这样的识别系统，最终效果如下图。\n\n![demo5](https://img.kuizuo.cn/demo5.gif)\n\n我要是当时会深度识别和调用 OCR，我用的着这么麻烦吗，这个是真的浪费我太多没用的时间。\n\n### 自写网络验证\n\n作为软件开发商，肯定不希望自己的辛辛苦苦写的软件，给别人一破解，修改了版权，并借此牟利，于是就不得不对软件进行一个操作，一般来说外面都有专门的对软件进行保护的厂商，但要钱的嘛，与其如此不如自己写一个，虽然防御上面可能没别人好，但至少一些破解小白肯定没那么轻松搞定。\n\n一般的网络验证，你会看到如下界面\n\n![image-20200926161606528](https://img.kuizuo.cn/image-20200926161606528.png)\n\n你需要注册一个账号使用，如果时间到期了就需要充值卡密使用，但你如果不注册的话，你就无法使用这个软件，能有效的防止破解者，提高破解门槛（该破解都能破解，就看想不想了），这是一个客户端，对应的肯定有服务端\n\n![image-20200926161958435](https://img.kuizuo.cn/image-20200926161958435.png)\n\n这里只记录了一些用的上的，实际上可以记录更多，只是我懒得再记录了，通过这个网络验证，可以有效的防止软件被篡改，同时也能利用这个来获取用户引流等等，至于网络验证相关代码就不提及了。\n\n实际上我防破解意识很浅，原因也很简单，这个软件都不收费，别人闲着没事破解啥，原本是加了网络验证，但是由于太麻烦，我就懒得加了。\n\n实际上超星这个软件从头到尾就没主动收取用户费用。那时候也是本着写来自用，并未想过去接单，帮别人啥的，对我来说没必要。软件写来不就是分享给更多的用户吗，话说的绝对，并不是所有开发者都有时间和精力去免费维护一个软件，我之所以能免费分享，主要还是我学校正好就是超星学习通的，加上也是我的练手项目，于是不分享白不分享，到时候一些其他相关软件的合作者也能找我（已经在合作了），所以这个软件对我来说有必要收费吗，反正我是没打算过。但后续平台发展了，就不得不停了该软件，没办法，为了平台而着想。\n\n### 浏览器插件\n\n我在搜索的超星刷课源码的同时也搜索到一个浏览器插件，油猴插件。相信学校是超星的肯定被同学安利过这样的一款插件，在这个插件你能看到很多脚本，其中你一搜就能搜到有关超星学习通和其他的，并且免费使用，也就是这个原因，我就没打算在我自写的超星学习通助手上进行收费。但实际上它们只是脚本，我当初准备写超星刷课的时候一开始是想写网页自动操作脚本的，但是随便一搜就有了相关的，并且别人的还有一些打码收费什么的，于是就放弃用脚本，而是通过 POST 请求（其实就是我那时候压根就不会浏览器的脚本，搜了一些网页填表的没学明白，而 js 那时候只会分析算法，ES6 语法都不会，于是就选择了协议），然后就有了上面的超星学习通助手，在疫情期间深入学习 web 方面就接触到了两个浏览器脚本，一个是 Puppeteer 与 selenium，另一个是 Chrome 插件开发，而这里的油猴插件就是基于 Chrome 插件开发出来的。\n\n但我没学过油猴插件，而是直接学了 Chrome 插件开发，有关 Chrome 插件开发可以看我写过一篇 Chrome 插件开发的文章，这里的话我就放一个网络上开源的插件 [超星慕课小工具](https://cx.icodef.com/) 毕竟我的调用题库接口还是基于这个插件的。（现转储为我自己的服务器）\n\n## 总结\n\n作为作者，能看到更多的人使用自己所写的软件，非常欣慰，估计认识我的一部分也是因为这个软件原因，由于要搞平台，所以就要停滞该项目了。\n\n在一开始编写时，都未曾想到能写的出来，并且优化成这样，在经历了这段编写过程，让我感受的编程的强大，也正是如此，让我会去尝试新鲜的技术，去编写新鲜的项目。不过还要说一些相关的问题\n\n### 说说这软件一些问题\n\n- 报毒 ：易语言的自身的原因\n- 无法做到适配：有的 win7 系统是获取不到课程，别问，问就是易语言。\n- 无法热更新：每次更新都需要在对应的下载链接下载，到现在我还不会热更新，哭了哭了。\n- 题库不全：有概率是搜不到题目的，所以提供了随机选项。\n\n从写这个软件开始，我能感受到易语言带来的便携，但也看到了易语言的不足之处。以至于我曾最喜欢的编程语言，也渐渐的开始放弃。（补: 我已不再从事易语言开发）\n\n### 不断更新，维护\n\n没有软件一上来就是完美无瑕的，都是经过多次的修改，更新，最终展现给用户，这个也不例外，从我 去年 10 月 10 号开始一直到现在，中间陆陆续续修改了几十遍，从 1.0 版本更新到 4.1.0（最终版，已不再更新）\n\n### 感慨\n\n因为这款软件，因为易语言让我感觉到编程是多么无敌的感觉，算是我目前为止还能拿的出手的软件之一，真的完全可以说，没有易语言，我也写不出来这样软件，更别说接下来的学习了。成就感与自信心油然而生，随后的学习更是得心应手。\n\n网络上也很少有类似这种文章，道理想必都懂，最后还是要说下\n\n**本文仅作为技术交流，希望更多的人利用技术去方便自己，而不是利用技术从事违规行为**\n\n**请勿利用本文相关技术与软件从事违法行为，否则后果自负！**"
    },
    {
      "id": "why-i-dont-use-qiniu-cloud",
      "metadata": {
        "permalink": "/why-i-dont-use-qiniu-cloud",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/advice/为什么我不用七牛云.md",
        "source": "@site/blog/advice/为什么我不用七牛云.md",
        "title": "为什么我不用七牛云",
        "description": "七牛云是国内鲜有的免费提供对象存储服务的一个云服务商，和腾讯云，阿里云一样，但这两者收费，而七牛云不收费，当然也不是绝对免费，对象存储免费空间 10g，每个月还有 10g 的 cdn 加速服务（多数人基本用不完），超出部分额外收费，此外 https 收费。",
        "date": "2020-12-23T00:00:00.000Z",
        "formattedDate": "2020年12月23日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "cloud-service",
            "permalink": "/tags/cloud-service"
          }
        ],
        "readingTime": 4.04,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "why-i-dont-use-qiniu-cloud",
          "title": "为什么我不用七牛云",
          "date": "2020-12-23T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "cloud-service"
          ],
          "keywords": [
            "随笔",
            "cloud-service"
          ]
        },
        "prevItem": {
          "title": "某习通小助手",
          "permalink": "/chaoxing-helper"
        },
        "nextItem": {
          "title": "腾讯云之CDN与SSL配置",
          "permalink": "/tencent-cloud-cdn-and-ssl"
        }
      },
      "content": "七牛云是国内鲜有的免费提供对象存储服务的一个云服务商，和腾讯云，阿里云一样，但这两者收费，而七牛云不收费，当然也不是绝对免费，对象存储免费空间 10g，每个月还有 10g 的 cdn 加速服务（多数人基本用不完），超出部分额外收费，此外 https 收费。\n\n<!-- truncate -->\n\n我**之前**使用七牛云的主要原因，就是业内太多人推荐了，免费还带加速，存储博客图片好的不行，然而发生了如下的事情：\n\n## 事情经过\n\n让我不用七牛云的罪魁祸首其实是 Chrome 浏览器，先看一张图片。\n\n![image-20201214211848873](https://img.kuizuo.cn/image-20201214211848873.png)\n\nWhat？图片呢？第一时间毫不犹豫打开控制台查看问题所在，有这样几行报错\n\n![image-20201214212056058](https://img.kuizuo.cn/image-20201214212056058.png)\n\n关注第一行\n\n```\nMixed Content: The page at '<URL>' was loaded over HTTPS, but requested an insecure element '<URL>'. This request was automatically upgraded to HTTPS, For more information see <URL>\n```\n\n翻译过来就是：网页混合内容:页面是通过 HTTPS 加载，但却请求一个不安全元素 HTTP。该请求被自动升级为 HTTPS，更多信息请参见。\n\n管他啥意思，先百度，然后才了解到，在 Chrome 浏览器高版本中（具体多少忘了），如果当前站点是 https，那么会自动将页面请求的 http 升级为 https，也就是说，我当前站点是 https 协议，访问不了 http 的资源，然而这可坑惨我了，我的图片全都放在七牛云上，然而七牛云的 HTTPS 是收费的，那时候我也抱着白嫖的心态，去嫖了七牛云的对象存储来做图床，现在我将http://kzcode.cn 升级为https://kzcode.cn 的时候，就意味这我不能白嫖了？也就是出现了如上画面，然后又去相关了一些百度相关的知道，看看有没有解决办法，如下\n\n- 使用其他浏览器\n\n这个问题只有 Chrome 浏览器内才有，在 https 站点会将 http 请求自动升级为 https，在其他浏览器不会，上面的图片也会正常显示。\n\n- 要么都用 HTTP，要么都用 HTTPS\n\nhttp 站点去请求 https 资源会不安全，而 https 站点去请求 http 会自动升级为 https，而这没有很好的有效方法去让两者兼容。\n\n## 选择\n\n既然搜到解决办法后，我心想，这网站怎么能不上 HTTPS，怎么能让左上角的锁不安全呢。用了 HTTPS 是不可能回去的了，同时怎么能保证别人用的浏览器不是 Chrome 浏览器呢，于是毅然决然的将所有将图片升级为 HTTPS 了，然而在对比后各家的对象存储服务，我选择了腾讯云，先放一张比对图：\n\n| 运营商 | 价格(元/GB)                                      | 活动                                                                   |\n| ------ | ------------------------------------------------ | ---------------------------------------------------------------------- |\n| 阿里云 | HTTP 0.24<br/>HTTPS 需要额外加一点请求费         | 无                                                                     |\n| 腾讯云 | HTTP 和 HTTPS **统一 0.21**                      | 前 6 个月每个月送 20GB 国内流量                                        |\n| 七牛云 | HTTP **0.24** (超出免费 10GB)<br/>HTTPS **0.28** | 每个月送 **10GB HTTP 流量** (国内外均可使用) 以及 5 万次动态加速请求数 |\n\n可以看到如果你每个月的请求流量都在 10GB 以内，且不用 HTTPS，七牛云肯定是最好的选择，然而我目前的站点是需要 HTTPS 的，并且七牛的 HTTPS 费用高出其他两家，甚至可以说，用了 HTTPS，就没必要选择七牛云！一没优势，速度优化不到哪里去，二是你完全可以相信大厂，三是服务费用还比两者贵。同时我云服务器也是腾讯云的，肯定优先选择腾讯，于是把对象存储换为了腾讯云，早知道就一开始就直接用腾讯的对象存储服务，果然还是花钱实在，白嫖太麻烦了。\n\n> 参考链接 [阿里云、腾讯云、七牛云 CDN 对比](https://blog.txzhou.com/website/compare-cdn.html)\n\n## 最后\n\n本文的标题并不是说七牛云不好，而是我所遇到的情形让我放弃了使用七牛云，相信你看完了上面所说的，能对你的网站有个存储有个明确的配置，你在哪买服务器了，还是在哪去买其他相关的业务，没必要花费时间去折腾，说到底还是花钱实在。并且价格实际上对一个小网站来说，已经是可以非常低了（当然还是有些人会想着白嫖）\n\n总结下来其实就是，如果你的网站不准备挂 SSL 证书，也就是通过 http 请求访问，那么白嫖七牛云，没问题，好用，但如果你的网站一旦挂了 SSL 证书，我的建议是直接删了七牛云的对象存储。"
    },
    {
      "id": "tencent-cloud-cdn-and-ssl",
      "metadata": {
        "permalink": "/tencent-cloud-cdn-and-ssl",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/腾讯云之CDN与SSL配置.md",
        "source": "@site/blog/develop/腾讯云之CDN与SSL配置.md",
        "title": "腾讯云之CDN与SSL配置",
        "description": "如题，本人所购买的服务器，以及对象存储，CDN，和 SSL 都是腾讯云的。",
        "date": "2020-12-15T00:00:00.000Z",
        "formattedDate": "2020年12月15日",
        "tags": [
          {
            "label": "cloud-services",
            "permalink": "/tags/cloud-services"
          }
        ],
        "readingTime": 5.27,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "tencent-cloud-cdn-and-ssl",
          "title": "腾讯云之CDN与SSL配置",
          "date": "2020-12-15T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "cloud-services"
          ],
          "keywords": [
            "cloud-services"
          ]
        },
        "prevItem": {
          "title": "为什么我不用七牛云",
          "permalink": "/why-i-dont-use-qiniu-cloud"
        },
        "nextItem": {
          "title": "HTTP请求之Content-Type",
          "permalink": "/content-type-of-http-request"
        }
      },
      "content": "如题，本人所购买的服务器，以及对象存储，CDN，和 SSL 都是腾讯云的。\n\n在这篇文章我会简单明细的讲一下我花了一个整个晚上都在腾讯云-控制台做了些什么，也助于自己到时候忘记腾讯云服务器相关操作做个笔记。\n\n<!-- truncate -->\n\n## 云服务器\n\n先看看我的云服务器配置\n\n![image-20201215004521965](https://img.kuizuo.cn/image-20201215004521965.png)\n\n腾讯云那时候做活动，花了 298 块买了 3 年 1 核 2g 内存 1m 带宽，够了，这里我要提一点，如果了解过云服务器的话，可能还会看到轻量应用服务器，而且这个轻量应用服务器竟然配置和云服务器差不多，并且价格还便宜，我先放两张图看看\n\n![image-20201215005635518](https://img.kuizuo.cn/image-20201215005635518.png)\n\n![image-20201215005553889](https://img.kuizuo.cn/image-20201215005553889.png)\n\n可以看到云服务器可以安装 Window，Linux 系统，而轻量应用服务器则是这些的分支，就这么说的，如果我的服务端只涉及到 nodejs 相关的，那么我大可购买轻量应用服务器，然而多数都是去买云服务器，毕竟可拓展高。两者价格在不是新用户的情况下，云服务器 1g1h1m 一年 662 元，而轻量应用服务器才 408 元。没错，不是新用户服务器就是这么贵。。。\n\n说了这么多题外话，说下云服务器有一个重要的地方就是安全组![image-20201215011238478](https://img.kuizuo.cn/image-20201215011238478.png)\n\n这里在宝塔面板中，设置了放行端口，此外腾讯云安全组也要设置，不过这里我是入站和出站都设置一键放通，主要方便，也懒得设置了。\n\n此外云服务器大致就如此，基本上宝塔安装后，就没腾讯云的云服务器面板什么事情了，有关云服务器与域名备案我在另一篇文章也写到过 [云服务器与域名备案](/server-and-domain-beian)\n\n## CDN\n\n关于 CDN 的介绍，本人不敢多言，怕讲不好。简单来说，挂了 CDN，你的网站就能加速，然而实际原理没这么简单，就不过多叙述这些了，外面也有很多关于 CDN 的相关资料，可以自行翻阅。\n\n首先，你需要开通 CDN，进入内容分发网络页面会有提示开启。此外到腾讯云有个优惠，新用户 6 个月每个月免费送 20g 回溯流量，此外付费的流量包中，一年也才 19 块，不说，先买了。\n\n在腾讯云-控制台中，主要关注两个点\n\n![image-20201215013943201](https://img.kuizuo.cn/image-20201215013943201.png)\n\n一个是要加速网站的域名，还有一个就是网站的 SSL 证书，这在下文会说到。\n\n在这里可以添加一个域名，比如`test.kzcode.cn`（后文也会以这个二级域名为例）\n\n![image-20201215014206851](https://img.kuizuo.cn/image-20201215014206851.png)\n\n根据相应的业务需求来填写，点击下方的确认提交即可。\n\n![image-20201215014459988](https://img.kuizuo.cn/image-20201215014459988.png)\n\n接着点击 DNS 解析页面，将 CNAME 的值复制到对应的 DNS 解析，如\n\n![image-20201215014619557](https://img.kuizuo.cn/image-20201215014619557.png)\n\n点击保存，然后回到 CDN 页面（内容分发网络），可以看到此时的状态已变为已启动。这时候你的网站就成功加速了，而不是用那 1m 的带宽去从服务器内拉去大的一笔的静态资源。\n\n## SSL 证书\n\n现在你的网站能访问速度得到了提升，但是出现了下面的这样警告（原谅我实在不想用 test.kzcode.cn 来测试）\n\n![image-20201215012031362](https://img.kuizuo.cn/image-20201215012031362.png)\n\n如果你不希望你的网站出现像这样的不安全警告，那么就很有必要设置 SSL 证书，请求的时候就是 https 而不是 http，好在 SSL 证书不算太难，并且上面 CDN 加速你也弄了，这里我把腾讯云的 SSL 证书简单复刻一遍。\n\n在 SSL 证书，点击申请免费证书\n\n![image-20201215012211483](https://img.kuizuo.cn/image-20201215012211483.png)\n\n点击确定，输入要绑定的域名，如`test.kzcode.cn`，和正常注册一样，默认下一步，下一步，接着稍等片刻，等待免费证书签发。SSL 证书有效期一年，一年后就需要重新部署了。然后返回到我的证书，看到成功添加了一条证书\n\n![image-20201215013035429](https://img.kuizuo.cn/image-20201215013035429.png)\n\n**先点击下载，下载到桌面，后面会用到的**，不然待会还要回来下载。然后点击右边的部署。\n\n![image-20210808150559353](https://img.kuizuo.cn/image-20210808150559353.png)\n\n部署类型选择内容分发网络（CDN），点击确定\n随后会跳转到证书配置页面，刚刚设置的域名 test.kzcode.cn 还有申请的免费 SSL 证书 test，选择腾讯云托管证书，向下图这样提交\n\n![image-20201215015319153](https://img.kuizuo.cn/image-20201215015319153.png)\n\n提示配置成功，这时候打开宝塔面板。添加一个站点\n\n![image-20201215015549597](https://img.kuizuo.cn/image-20201215015549597.png)\n\n点击设置，在左侧侧边栏中的 SSL 中的选其他证书，上面叫你下载的证书下了吧，好的，打开它，其中一个文件为 Nginx，将里面的两个文件通过文本来打开（**是通过文本，而不是双击直接打开**），将.key 文件的内容放到密钥上，将.crt 文件的内容放到证书上，然后点击保存，顺便把右上角强制 HTTPS 勾选上\n\n![image-20201215020231348](https://img.kuizuo.cn/image-20201215020231348.png)\n\n打开网页，现在你访问[test.kzcode.cn](https://test.kzcode.cn)，就能得到如下结果\n\n![image-20201215020429502](https://img.kuizuo.cn/image-20201215020429502.png)\n\n连接是安全的，证书有效，恭喜，站点创建成功！\n\n---\n\n至此，一个二级域名 test.kzcode.cn，并带有 SSL 证书与 CDN 加速的站点便成功部署！\n\n## 总结\n\n整个过程写下来，其实给我的感受就是写给未来某一时刻去重新折腾腾讯云的一篇文章，从头到尾，我也只是把这些操作重新复刻一遍，然后写成这篇文章。\n\n在折腾了一晚上的云服务器，腾讯云给我的一大特点就是好用，并且文档详细。果然这就是大厂的资本吗，爱了爱了。并且新用户所涉及的金额并不多，甚至我都没感觉到我到底有没有花钱在网站部署上（等到时候网站人流量来的，估计就要花大价钱了）。并且执行了上面的操作，我的网站确实有所提高速度，不过还没完，云服务中还有一个挺重要的一部分还没讲到，也就是对象存储，留个小坑，有时间在写。"
    },
    {
      "id": "content-type-of-http-request",
      "metadata": {
        "permalink": "/content-type-of-http-request",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/HTTP请求之Content-Type.md",
        "source": "@site/blog/develop/HTTP请求之Content-Type.md",
        "title": "HTTP请求之Content-Type",
        "description": "Content-type",
        "date": "2020-12-12T00:00:00.000Z",
        "formattedDate": "2020年12月12日",
        "tags": [
          {
            "label": "http",
            "permalink": "/tags/http"
          }
        ],
        "readingTime": 2.3933333333333335,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "content-type-of-http-request",
          "title": "HTTP请求之Content-Type",
          "date": "2020-12-12T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "http"
          ],
          "keywords": [
            "http"
          ]
        },
        "prevItem": {
          "title": "腾讯云之CDN与SSL配置",
          "permalink": "/tencent-cloud-cdn-and-ssl"
        },
        "nextItem": {
          "title": "node与浏览器中的cookie",
          "permalink": "/cookie-of-node-and-browser"
        }
      },
      "content": "<!-- truncate -->\n\n## Content-type\n\n先看一条 HTTP 请求\n\n```http\nPOST https://xxx.kuizuo.cn/v2/login HTTP/1.1\nHost: xxx.kuizuo.cn\nConnection: keep-alive\nContent-Length: 121\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\n// Content-Type: application/json;charset=UTF-8\nAccept: application/json, text/plain, */*\n\n{\"username\":\"kuizuo\",\"password\":\"a12345678\"}\n```\n\n上面那个请求发送到我的服务器，服务器却接收到的是这样一串值\n\n```json\n{ \"{\\\"username\\\":\\\"kuizuo\\\",\\\"password\\\":\\\"a12345678\\\"}\": \"\" }\n```\n\n很显然，它把 json 格式解析成了 x-www-form-urlencoded。\n\n一个很简单的登录请求，注意一个协议头`Content-Type`，它决定了你的数据发送到服务端上会是什么格式。\n\n```\n类型格式：type/subtype(;parameter)?\ntype 主类型，任意的字符串，如text，如果是*号代表所有；\nsubtype 子类型，任意的字符串，如html，如果是*号代表所有；\nparameter 可选，一些参数，如Accept请求头的q参数， Content-Type的charset参数。\n```\n\n常见的媒体格式类型如下：\n\n- text/html ： HTML 格式\n\n- text/plain ：纯文本格式\n\n- text/xml ： XML 格式\n\n- image/gif ：gif 图片格式\n\n- image/jpeg ：jpg 图片格式\n\n- image/png：png 图片格式\n\n  以 application 开头的媒体格式类型：\n\n- application/xhtml+xml ：XHTML 格式\n\n- application/xml ： XML 数据格式\n\n- application/atom+xml ：Atom XML 聚合格式\n\n- application/json ： JSON 数据格式\n\n- application/pdf ：pdf 格式\n\n- application/msword ： Word 文档格式\n\n- application/octet-stream ： 二进制流数据（如常见的文件下载）\n\n- application/x-www-form-urlencoded ： form 表单数据被编码为 key/value 格式（通过=与&拼接）发送到服务器（表单默认的提交数据的格式）格式如: username=kuizuo&password=a12345678\n\n  另外一种常见的媒体格式是上传文件之时使用的：\n\n- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n实际上遇到最多的也就是 text/html，text/plain，application/json，application/x-www-form-urlencoded 这几个。\n\n> 参考资料 [Http 请求中 Content-Type](https://www.cnblogs.com/klb561/p/10090540.html)\n\n### 说说我那时候的情况\n\n这是在我帮别人分析登录算法的时候，由于协议头中少添加了一个`Content-Type`，导致我发送的数据，服务端解析不了，收到了这样的响应\n\n```json\n{ \"code\": 500001, \"message\": \"亲，我们的系统目前忙碌中或无法回应，请将此问题回报给我们的客服人员。 错误代碼(68523)\", \"data\": null }\n```\n\n然而实际响应应该是这样的\n\n```json\n{ \"code\": 400020, \"message\": \"密码错误\", \"data\": \"验证码错误\" }\n```\n\n原因就是因为协议头没有添加`Content-Type: application/json;charset=UTF-8`所导致的。因为这个，坑了我近一个小时，还一直以为是数据错误，没想到仅仅只是少加了一些协议头导致的请求数据格式错误。\n\n一个印象很深刻的教训，模拟 HTTP 请求的时候，一定不要吝啬补全协议头，不然坑的就是自己了。我已经给坑过两次了，所以在特意想借此记录一下，免得下次又是一番折腾。写个注意，醒目一点。\n\n:::danger\n\n发送的是 JSON 格式数据，切记一定要添加上协议头`Content-Type: application/json;charset=UTF-8`！！！\n\n:::"
    },
    {
      "id": "cookie-of-node-and-browser",
      "metadata": {
        "permalink": "/cookie-of-node-and-browser",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/axios中的cookie.md",
        "source": "@site/blog/develop/axios中的cookie.md",
        "title": "node与浏览器中的cookie",
        "description": "前言",
        "date": "2020-12-10T00:00:00.000Z",
        "formattedDate": "2020年12月10日",
        "tags": [
          {
            "label": "node",
            "permalink": "/tags/node"
          },
          {
            "label": "axios",
            "permalink": "/tags/axios"
          },
          {
            "label": "cookie",
            "permalink": "/tags/cookie"
          }
        ],
        "readingTime": 8.256666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "cookie-of-node-and-browser",
          "title": "node与浏览器中的cookie",
          "date": "2020-12-10T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "node",
            "axios",
            "cookie"
          ],
          "keywords": [
            "node",
            "axios",
            "cookie"
          ]
        },
        "prevItem": {
          "title": "HTTP请求之Content-Type",
          "permalink": "/content-type-of-http-request"
        },
        "nextItem": {
          "title": "服务器与域名备案",
          "permalink": "/server-and-domain-beian"
        }
      },
      "content": "<!-- truncate -->\n\n## 前言\n\n记录一下自己在 nodejs 中使用 http 请求库 axios 中的一些坑（针对 Cookie 操作）\n\n不敢说和别人封装的 axios 相比有多好，但绝对是你能收获到 axios 的一些知识，话不多说，开始\n\n## 封装\n\n一般而言，很少有裸装使用 axios 的，就我涉及的项目来说，我都会将 axios 的 request 封装成一个函数使用，接着在 api 目录下，引用该文件。项目结构一般是这样的：\n\n```\n|-- src\n\t|-- api\n\t\t|-- user.js\n\t\t|-- goods.js\n\t|-- utils\n\t\t|-- request.js\n```\n\n#### request.js\n\n```js\nimport axios from 'axios'\n\nvar instance = axios.create({\n  baseURL: process.env.API, // node环境变量获取的Api地址\n  withCredentials: true, // 跨域携带Cookies\n  timeout: 5000,\n})\n// 设置请求拦截器\ninstance.interceptors.request.use(\n  (config) => {\n    // 在config可以添加自定义协议头 例如token\n    config.headers['x-token'] = 'xxxxxxxx'\n\n    return config\n  },\n  (error) => {\n    Promise.error(error)\n  },\n)\n\ninstance.interceptors.response.use(\n  (response) => {\n    const res = response.data\n    // 根据对应的业务代码 对返回数据进行处理\n\n    return res\n  },\n  (error) => {\n    const { response } = error\n    // 状态码为4或5开头则会报错\n    // 根据根据对应的错误,反馈给前端显示\n    if (response) {\n      if (response.status == 404) {\n        console.log('请求资源路径不存在')\n      }\n      return Promise.reject(response)\n    } else {\n      // 断网......\n    }\n  },\n)\n\nexport default instance\n```\n\n实际上，上面那样的封装就够了，相对于的业务代码就不补充了，如果你的宿主环境是浏览器的话，很多东西你就没必要在折腾的，甚至下面的文章都没必要看（不过还是推荐你看看，会有帮助的）。不过没完，再看看 api 里怎么使用的\n\n#### api/user.js\n\n```js\nimport request from '@/utils/request'\n\nexport function login(data) {\n  return request({\n    url: '/user/login',\n    method: 'post',\n    data,\n  })\n}\n\nexport function info() {\n  return request({\n    url: '/user/info',\n    method: 'get',\n  })\n}\n\nexport function logout() {\n  return request({\n    url: '/user/logout',\n    method: 'post',\n  })\n}\n```\n\n看来很简单，没错，就是这么简单，由于是运行在浏览器内的，所以像 cookies，headers 等等都没必要设置，浏览器会自行携带该有的设置，其实想设置也设置不了，主要就是浏览器内置跨域问题。[XMLHttpRequest](https://fetch.spec.whatwg.org/#concept-header-name)\n\n就这？感觉你写的跟别人没什么区别啊\n\n别急，下面才是重头戏。也是我为啥标题只写 axios，而不写 vue-axios 或者 axios 封装的原因。\n\n## 踩坑 Cookies 获取与设置\n\n### 浏览器\n\n运行环境在浏览器中，axios 是无法设置与获取 cookie，获取不到 set-cookies 这个协议头的（即使服务器设置了也没用），先看代码与输出\n\n```js\ninstance.interceptors.request.use((config) => {\n  config.headers['cookie'] = 'cookie=this_is_cookies;username=kuizuo;'\n  console.log('config.headers', config.headers)\n  return config\n})\n\ninstance.interceptors.response.use((response) => {\n  console.log('response.headers', response.headers)\n  return res\n})\n```\n\n控制台结果：\n\n![image-20201210060704240](https://img.kuizuo.cn/image-20201210060704240.png)\n\n首先，就是圈的这个，浏览器是不许允许设置一些不安全的协议头，例如 Cookie，Orgin，Referer 等等，即便你看到控制台 config.headers 确实有刚刚设置 cookie，但我们输出的也只是 headers 对象，在 Network 中找到这个请求，也同样看不到 Cookie 设置的（这就不放图了）。\n\n同样的，通过响应拦截器中输出的 headers 中也没有 set-cookies 这个字样。网络上很多都是说，添加这么一行代码 `withCredentials: true`，确实，但是没说到重点，都没讲述到怎么获取 cookies 的，因为在**浏览器环境中 axios 压根就获取不到 set-cookies 这个协议头**，实际上 axios 就没必要，因为浏览器会自行帮你获取服务器返回的 Cookies，并将其写入在 Storage 里的 Cookies 中，再下次请求的时候根据同源策略携带上对应的 Cookie。\n\n![image-20201210061627824](https://img.kuizuo.cn/image-20201210061627824.png)\n\n要获取也很简单，vue 中通过`js-cookie`模块即可，而在 electron 中通过`const { session } = require('electron').remote` （electron 可以设置允许跨域，好用）有关更多可以自行查看文档。\n\n那我就是想要设置 Cookies，来跳过登录等等咋办，我的建议是别用浏览器来伪装 http 请求。跨域是浏览器内不可少的一部分，并且要允许跨域过于麻烦。有关跨域，我推一篇文章[10 种跨域解决方案（附终极大招）](https://juejin.cn/post/6844904126246027278)\n\n#### 完整封装代码\n\n::: details 查看代码\n\n```js\nimport axios from 'axios'\nimport { MessageBox, Message } from 'element-ui'\nimport store from '@/store'\nimport { getToken } from '@/utils/auth'\n\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API,\n  withCredentials: true,\n  timeout: 5000,\n})\n\nservice.interceptors.request.use(\n  (config) => {\n    if (store.getters.token) {\n      config.headers['x-token'] = getToken()\n    }\n\n    return config\n  },\n  (error) => {\n    Message.error(error)\n    return Promise.reject(error)\n  },\n)\n\nservice.interceptors.response.use(\n  (response) => {\n    const res = response.data\n    if (res.code !== 200) {\n      Message.error(res.msg || 'Error')\n\n      return Promise.reject(new Error(res.msg || '未知错误'))\n    } else {\n      return res\n    }\n  },\n  (error) => {\n    if (error.response) {\n      let res = error.response\n      switch (res.status) {\n        case 400:\n          Message.error(res.msg || '非法请求')\n          break\n        case 401:\n          MessageBox.alert('当前登录已过期，请重新登录', '提示', {\n            confirmButtonText: '重新登录',\n            type: 'warning',\n          }).then(() => {\n            store.dispatch('user/logout').then(() => {\n              location.reload()\n            })\n          })\n        case 403:\n          Message.error(res.msg || '非法请求')\n          router.push('/401')\n        case 404:\n          Message.error(res.msg || '请求资源不存在')\n          break\n        case 500:\n          Message.error(res.msg || '服务器开小差啦')\n          break\n        default:\n          Message.error(res.msg || res.statusText)\n      }\n    } else {\n      Message.error(res.msg || '请检查网络连接状态')\n    }\n\n    return Promise.reject(error)\n  },\n)\n\nexport default service\n```\n\n:::\n\n### Nodejs\n\n作为 nodejs 的主流 http 框架怎么能只用在浏览器上，nodejs 自然而然可以，不过 nodejs 需要配置的可就多了，在 nodejs 环境中，自然没有浏览器的同源策略，像上面设置不了的 Cookie，现在随便设置，先看看我是怎么封装的：\n\n```js\nimport axios from 'axios'\nimport * as http from 'http'\nimport * as https from 'https'\n\nexport async function request(opt) {\n  let { url, method = 'get', headers = {}, cookies, data = null } = opt\n\n  headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'\n  headers['Referer'] = url\n\n  if (typeof cookies === 'object') {\n    headers['Cookie'] = Object.keys(cookies)\n      .map((k) => encodeURIComponent(k) + '=' + encodeURIComponent(cookies[k]))\n      .join('; ')\n  } else if (typeof cookies === 'string') {\n    headers['Cookie'] = cookies\n  }\n\n  let options = {\n    url: url,\n    method: method,\n    headers: headers,\n    data: queryString.stringify(data),\n    httpAgent: new http.Agent({ keepAlive: true }),\n    httpsAgent: new https.Agent({\n      keepAlive: true,\n      rejectUnauthorized: false,\n    }),\n    timeout: 5000,\n  }\n\n  try {\n    let res = await this.axios.request(options)\n\n    return res\n  } catch (e) {\n    console.log(e)\n    return e.message\n  }\n}\n```\n\n```js\n// test.js\nconst request = require('./request');\n\nfunction test() {\n  let url = 'https://passport2.chaoxing.com/fanyalogin';\n  let data = {\n    fid: '-1',\n    uname: '15212345678',\n    password: 'a12345678',\n    refer: 'http%253A%252F%252Fi.mooc.chaoxing.com',\n    t: 'true',\n  };\n  let headers = {};\n  let cookies = 'username=kuizuo;uid=123;';\n  let res = await request({\n    url: url,\n    data,\n    headers,\n    cookies,\n  });\n  console.log('test -> res.headers', res.headers);\n  return res.data;\n}\n\ntest();\n```\n\n测试一下，顺便抓一下包，看看请求包\n\n```http\nGET /fanyalogin HTTP/1.1\nAccept: application/json, text/plain, */*\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\nReferer: https://passport2.chaoxing.com/fanyalogin\nCookie: username=kuizuo;uid=123;\nHost: passport2.chaoxing.com\nConnection: keep-alive\nContent-Length: 100\n\n....\n```\n\n有我们自定义的 Cookie，在看看响应的协议头\n\n```js\ntest -> res.headers {\n  server: 'Tengine',\n  date: 'Thu, 10 Dec 2020 00:24:15 GMT',\n  'content-type': 'text/html',\n  'content-length': '1852',\n  connection: 'keep-alive',\n  vary: 'Accept-Encoding',\n  'set-cookie': [\n    'JSESSIONID=4365A6B9FD8E0CBADDBDD7E7DA468F7E; Path=/; HttpOnly',\n    'route=b2eda164bddd148142a54809ef404926;Path=/'\n  ],\n  'accept-ranges': 'bytes',\n  etag: 'W/\"1852-1606444212000\"',\n}\n```\n\n同样能获取到 set-cookie，设置与获取都是这么 so easy ，不同于上面浏览器的配置。\n\n这里我要说明一些东西，在封装代码中有个 httpAgent 与 httpsAgent，你可以字面翻译就是 http 代理，设置它用来干嘛呢，其中有这么个属性 `keepAlive: true` ，如果设置了协议头中的将会有 `Connection: keep-alive`，而不设置则 `Connection: close`，这里也不想过多说明 http 相关知识，如果只是请求一次,那么两者没有太大区别\n\n然而如果我请求一次,过一会(几秒内)又要请求了,那么 keep-alive 一次连接就可以处理多个请求，而 close 则是一次请求后就断开，下次就需要再次连接。说白了就是快一点，而 close 需要不断连接，断开，自然而然就慢。一般来说设置 keep-alive 就对了。\n\n其中在 httpsAgent 中，还有一个属性`rejectUnauthorized: false`，说简单点，就是不抛出验证错误，在抓 nodejs 包的时候，如果不通过设置代理服务器（Fiddler，Charles），而是通过网卡（HTTP Analyzer，Wireshark）就会抛出异常，一般就会出现这种错误。\n\n```\nError: unable to verify the first certificate\n```\n\n然而问题就来了，服务端的返回的 set-cookie 该怎么保存。如果只是涉及客户端层面的，想写一个模拟 http 请求的，直接将获取到的 cookies 与原有的 cookie 合并即可。我那时候的代码就是这样：\n\n```js\nlet newCookie = res.header['set-cookie']\n  ? res.header['set-cookie']\n      .map((a) => {\n        return a.split(';')[0]\n      })\n      .join('; ')\n  : ''\n\n// mergeCookie 就是将两者cookie 拼接而成\nlet newCookies = mergeCookie(cookies, newCookie)\n\nres[cookie] = newCookies\nreturn res\n```\n\n然后返回响应中携带 res.cookies 即可，下次请求的时候再将其在带上。\n\n如果只是，利用 nodejs 来实现类似爬虫，模拟登录，然后利用登录后的 cookie，来获取用户信息。如果不希望手动处理 cookies 的话，我其实还是推荐一个 http 模块，superagent，做一些小爬虫和模拟请求挺好用的，就不做过多介绍了。不过由于 nestjs 中自带 axios 模块，加上需要转发 http 请求，于是我就自行封装了一个 axios。\n\n## 总结\n\n实际上，axios 会根据当前环境，来创建 xhr 对象（浏览器）还是 http 对象（nodejs），在我那时候都以为 axios 是两个共用的，初学 electron 的时候，一直卡在 http 请求的配置\n\n```\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // Return a promise and supply a valid response (see lib/adapters/README.md).\n  adapter: function (config) {\n    /* ... */\n  },\n```\n\n在 axios 中也有这么一段配置，翻看了 lib/adapters 下目录我才瞬间醒悟过来，两者环境是不同的。\n\n![image-20201210214055696](https://img.kuizuo.cn/image-20201210214055696.png)\n\n就我使用而言，在浏览器环境下 axios 处理的特别好，允许设置拦截器处理请求与响应，但在 nodejs 下在处理模拟请求确实不如 Python 的 request 模块，奈何 axios 最大的便携就是能直接在浏览器中，尤大推荐的 http 请求库也是 axios。\n\n实际上还涉及到了 nodejs 中转发请求的，再给自己留一个坑。\n\n在写这篇文章的时候，我其实都没读过 axios 的源码，说实话，那时候遇到问题，就不应该愚昧的去搜索，去不断尝试，有时候直接通过翻看底层代码，可以一目了然自己所面临问题的解决方式。"
    },
    {
      "id": "server-and-domain-beian",
      "metadata": {
        "permalink": "/server-and-domain-beian",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/服务器与域名备案.md",
        "source": "@site/blog/develop/服务器与域名备案.md",
        "title": "服务器与域名备案",
        "description": "云服务器",
        "date": "2020-11-17T00:00:00.000Z",
        "formattedDate": "2020年11月17日",
        "tags": [
          {
            "label": "server",
            "permalink": "/tags/server"
          },
          {
            "label": "cloud",
            "permalink": "/tags/cloud"
          }
        ],
        "readingTime": 9.636666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "server-and-domain-beian",
          "title": "服务器与域名备案",
          "date": "2020-11-17T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "server",
            "cloud"
          ],
          "keywords": [
            "develop",
            "cloud"
          ]
        },
        "prevItem": {
          "title": "node与浏览器中的cookie",
          "permalink": "/cookie-of-node-and-browser"
        },
        "nextItem": {
          "title": "易语言",
          "permalink": "/easy-language"
        }
      },
      "content": "<!-- truncate -->\n## 云服务器\n\n服务器说白就是全天 24 小时不停歇的运行一台电脑，同时分配一个公网 IP 给这个电脑，你只需要把你要的资源放置到这台电脑上，别人通过访问该 IP 就能访问到这台电脑的资源，比如你放一个网页部署在这台服务器上，别人访问 这个IP就能访问到网页的内容。\n\n你可以根据需求来安装服务器的系统，这些在云服务厂商中都是可以选择的。\n\n### 服务器的配置\n\n一般来说，一些提供云服务器的厂商都会给新用户一个新用户价，差不多也就是 100 左右一年的云服务器,配置一般都是 2g 内存,1 核,1m 带宽,50g 硬盘说实话对于没有特殊需求的服务器够用了。而不是新用户的价格，这样的配置一个月差不多 70 元，算一下一年打折后 700 元，这还算便宜的了，服务器贵这很正常，全天不间断运行，电费，网费和一些服务费用，其实就已经非常值了。\n\n其他几个配置没什么可说的，如果要说服务器哪个配置最贵的话，无疑就是带宽了。1M 的带宽理论上传速度为 128kB/s，也就是我从服务器中下载一个 10m 的软件，需要 80 秒，这还只是理论速度，我实测过平均速度不到 100kB/s。如果搭建网站的话 1m 有些慢，虽说一个页面一般都不会超过 100kb，但背后加载的图片 css js资源可就不只是kb大小了，用户访问网页就需要花费一定时间等待加载，体验非常不好。个人建议带宽5m起步，否则就不建议购买。\n\n### 云服务器和轻量应用服务\n\n关于服务器的选择很多人不知道云服务器和轻量应用服务的区别，这里两种服务器我都买过，且目前都在役。主要区别和优势请参考下表（腾讯云文档）\n\n![](https://img.kuizuo.cn/image_CO_V_ghsyo.png)\n\n更具体的可以查看对应云服务商的介绍\n\n[阿里云ECS云服务器和轻量应用服务有什么区别及选择方法-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1023850?spm=5176.21213303.J_6704733920.7.432353c9DbykNf\\&scm=20140722.S_community@@文章@@1023850._.ID_community@@文章@@1023850-RL_阿里云ecs云服务器和轻量应用服务有什么区别及选择方法-LOC_main-OR_ser-V_2-P0_0 \"阿里云ECS云服务器和轻量应用服务有什么区别及选择方法-阿里云开发者社区 (aliyun.com)\")\n\n[轻量应用服务器 与云服务器 CVM 对比-产品简介-文档中心-腾讯云 (tencent.com)](https://cloud.tencent.com/document/product/1207/49819 \"轻量应用服务器 与云服务器 CVM 对比-产品简介-文档中心-腾讯云 (tencent.com)\")\n\n**总结：买轻量应用服务器是最实惠的**\n\n### github学生认证送服务器\n\n如果你不想花钱买一个服务器的话，可以考试github学生认证，会送你一个服务器。具体可到官方中查看 [https://education.github.com/experiences/virtual\\_event\\_kit](https://education.github.com/experiences/virtual_event_kit \"https://education.github.com/experiences/virtual_event_kit\")\n\n![](https://img.kuizuo.cn/image_Rsh8Y_TBfe.png)\n\n### windows 和 Linus 服务器的区别\n\n这里可能会说的不对，毕竟我接触服务器相关等配置也没太多时间，但是我觉得有必要说一下，我那时候用 windows 服务器的时候，只要通过 windows**专业版**（一定要专业版才能远程连接别人的电脑）自带的远程桌面（cmd 中输入`mstsc`即可），然后输入 ip 地址，接着在输入相应的账号密码即可，但有可能无法连接，原因是防火墙和 ip 白名单没有配置好，服务器不允许连接。\n\n而对于 Linux，用的最多的就是宝塔面板了，但是连接不是通过 windows 远程桌面，而是通过像终端那样连接登录，我一般是用 Xshell 来连接。但是连接完就开始输入命令安装宝塔面板，然后会有对应的面板地址和登录宝塔面板的账号密码，只要访问给定的面板地址加上用户密码即可登录。像对应的界面如下\n\n![image-20200918141519472](https://img.kuizuo.cn/image-20200918141519472.png \"image-20200918141519472\")\n\n## 选择哪家云服务器厂商\n\n目前市场上主要有阿里云和腾讯云的服务器，这两者的服务器质量和操作体验上都属于大厂级别。不分上下，都可以选择购买，不过最好有个原则，你域名在哪购买，服务器就买哪一家的，因为到时候备案是需要服务器才能备案的。\n\n# 域名\n\n正常来说你访问你一个网站肯定不是访问一个ip地址，而是一个域名，比方说访问kuizuo.cn，baidu.com。但其实访问域名就相当于访问这个ip，过程如下：首先访问域名会经过DNS解析，DNS（域名系统）会找到你要访问的域名所解析的ip，然后访问这个ip。\n\n但有遗憾的地方就是很多时候想要注册自己想要的域名非常难，因为已经被别人现行注册了。比如我的现在的kuizuo.cn这个域名是从他人手里购买而来的。所以域名这东西请优先准备好，备案解析啥的完全不急，一年也就是几十块钱，但是你不先买就很有可能给别人先注册，到时候想买都没得买，要不然就要花大价格购买，因此也有很多人去做域名买卖的生意。\n\n一般一个域名够用了，需要的话在域名解析中去添加域名的子域名（二级，三级等等），比如我的一些个人项目就是使用二级域名来访问的，这里我也就不在列举了。\n\n### 为啥要备案\n\n首先备案要提交负责人的身份信息（身份证正反，手持，人脸，手机号，住址等），记录你这个域名内的网站的负责人和单位，主要为了防止在网上从事非法的网站经营活动，打击不良互联网信息的传播，能给予警告和封禁。（网站备案只针对国内服务器）\n\n总之不要去搞违规违法行为，天网恢恢疏而不漏，网警要找总归有方法。\n\n### ICP 备案\n\n9 月 3 号购买的腾讯云与域名，然后进行初步的服务器简单部署配置，第二天开始域名实名认证，接着实名后需要 3 天时间才可以进行开始域名备案，等了 3 天开始域名备案提交网站的用途信息等等，然后拍身份证，人脸，手持，接着到 9 月 9 日腾讯云服务器的客服打电话给我要我修改一些信息，比如网站详情写的不行，资料不全，过不了备案等等，然后修改重新提交一次，最终等待收到腾讯云助手的通知，直到 9 月 18 号，如下结果\n\n![image-20200918113449612](https://img.kuizuo.cn/image-20200918113449612.png \"image-20200918113449612\")\n\n至此 ICP 备案就搞定了，ICP 还算轻松，身份信息真实，来访电话及时接听，等就行了。\n\n只要ICP 备案，就可以通过域名 [kuizuo.cn](https://kuizuo.cn \"kuizuo.cn\") 访问到我的个人博客。(当然前提需要到域名管理中的DNS解析添加)\n\n![](https://img.kuizuo.cn/image_nuVA2RTh_b.png)\n\n### 公安备案\n\n但还有一个公安备案，虽说不是强制的，但一般都是建议去公安备案一下。我之前的域名kzcode.cn就有公安备案，但现在的kuizuo.cn 并没有。主要原因还是太过于繁琐，比ICP备案复杂多了。\n\n首先需要登录 [http://www.beian.gov.cn](http://www.beian.gov.cn \"http://www.beian.gov.cn\") 注册并且登录填写的信息也比上面的多，如下图\n\n![image-20201119191204222](https://img.kuizuo.cn/image-20201119191204222.png \"image-20201119191204222\")\n\n填写资料折腾了半小时左右的时间，才提交上去，而且过了快两周后，我收到了如下的短信\n\n> 【公安网站服务平台】尊敬的用户:您开办的网站(互联网技术文章分享:kzcode.cn)审核未通过，原因：网站信息检查有误，审核不通过，请尽快登录www\\.beian.gov.cn网站，在草稿中修改并重新提交网站备案申请，如有疑问可在工作日（上午8:30-11:30、下午14:00-17:00）联系网警，联系电话：059xxxxxxxx，谢谢您的配合。\n\n工作人员电话和我联系是说我户籍转了，需要在我转入地去申请，于是又重新提交改数据，反正就是照着腾讯云的帮助文档填写自己的个人信息，中途有几次就这么磨着磨着到了 11 月 17 号，短信收到了这一条\n\n> 【公安网站服务平台】尊敬的用户:您的开办主体已经审核通过，如果存在自动关联的待备案或待认领网站，请尽快核对归属，进行新网站备案以及已备案网站认领的申请。如有疑问可在工作时间（周一至周五上午 9:00-12:00、下午 14:00-17:00）联系网警，联系电话：059xxxxxxxx，谢谢您的配合。\n\n然而，我登录了网站却没有看到已备案的网站，于是联系工作人员 ，然后叫我重新提交一次，这次不到半小时就搞定，最终短信结果如下\n\n> 【公安网站服务平台】尊敬的用户:您开办的网站(互联网技术文章分享:kzcode.cn)已经审核通过，请尽快登录www\\.beian.gov.cn网站,下载备案号码，附在网站底部，如有疑问可在工作日（上午9:00-12:00、下午14:00-17:00）联系网警，联系电话：059xxxxxxxx，谢谢您的配合。\n\n然后登录公安备案网站，查看备案结果如下图，帅的不谈！\n\n![image-20201117152619474](https://img.kuizuo.cn/image-20201117152619474.png \"image-20201117152619474\")\n\n### 悬挂备案号\n\n如果上面都已经弄好了也别太高兴，要在网页源代码将公安联网备案信息放置在网页底部。简单的说完成两项备案后都需要在网站页面底部显示备案号，并指明转到链接。在我的个人博客页面最下方，就会看到如下图这样。\n\n![image-20201117153209037](https://img.kuizuo.cn/image-20201117153209037.png \"image-20201117153209037\")\n\n[工信部原文](http://www.gov.cn/gongbao/content/2005/content_93018.htm \"工信部原文\") 第十三条和第二十五条\n\n> **第十三条** 非经营性互联网信息服务提供者应当在其网站开通时在主页底部的中央位置标明其备案编号，并在备案编号下方按要求链接信息产业部备案管理系统网址，供公众查询核对。\n\n> **第二十五条** 违反本办法第十三条的规定，未在其备案编号下方链接信息产业部备案管理系统网址的，或未将备案电子验证标识放置在其网站指定目录下的，由住所所在地省通信管理局责令改正，并处5千元以上1万元以下罚款。\n\n当然也有很多网站并没有这么做，具体还是需要看网站的性质，是否经营性网站。像个人博客这种，只需要悬挂一个ICP备案号即可，但对于绝大多数的国内网站是肯定悬挂公安备案，并且除了备案信息外，还有一堆相关证件，如营业执照，许可证，资格证等等，国内的网站监管非常严格的。"
    },
    {
      "id": "easy-language",
      "metadata": {
        "permalink": "/easy-language",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/易语言.md",
        "source": "@site/blog/program/易语言.md",
        "title": "易语言",
        "description": "好歹自己学习易语言也快有一年了，也用易语言写了一些软件，特此记录一下以及对易语言的个人看法。",
        "date": "2020-10-08T00:00:00.000Z",
        "formattedDate": "2020年10月8日",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/tags/随笔"
          },
          {
            "label": "easy-language",
            "permalink": "/tags/easy-language"
          }
        ],
        "readingTime": 13.346666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "easy-language",
          "title": "易语言",
          "date": "2020-10-08T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "随笔",
            "easy-language"
          ],
          "keywords": [
            "随笔",
            "easy-language"
          ]
        },
        "prevItem": {
          "title": "服务器与域名备案",
          "permalink": "/server-and-domain-beian"
        },
        "nextItem": {
          "title": "2019.7-2020.7编程年记",
          "permalink": "/2019.7-2020.7-log"
        }
      },
      "content": "好歹自己学习易语言也快有一年了，也用易语言写了一些软件，特此记录一下以及对易语言的个人看法。\n\n该文章有可能过于啰嗦，可吐槽的点太多了，也正有感悟才能写的这么多。\n\n补: 2021 年 3 月，也就是我最后一次编写易语言项目，因为我已经好久不写 exe 项目了。\n\n<!-- truncate -->\n\n## 易语言介绍\n\n还是简单介绍一些易语言吧，毕竟肯定有很多即使学过编程也没听过易语言的，易语言是一门以**中文**作为程序代码编程语言，简称 E 语言，创始人吴涛，2000 年一个人独立开发。有关易语言的特点如下：\n\n### 易语言不开源\n\n不像主流的编程语言 C，Java，Python 等是开源的，易语言是一款纯正的商业编程软件，易语言正版加密狗 618 元，不过有破解版，不然多数人都不会去接触易语言了。但不开源就已经注定了易语言的在整个生态就不行，并且易语言已不在维护了，也就是很久很久没更新过，或者说不会再更新了，作者也已不再管易语言了，目前也就一些易友去开发一些相关的插件模块库这些。\n\n### 全中文界面，可视化 UI，填表式的声明\n\n我这里放几张图展示一下\n\n![image-20200914010759872](https://img.kuizuo.cn/image-20200914010759872.png)\n\n![image-20200914011112087](https://img.kuizuo.cn/image-20200914011112087.png)\n\n首先要吐槽一下，2000 年的页面与 2020 年的页面可以说是完全一模一样的。开发界面是真的丑，但有一点是，页面的语言命令都是全中文的，比如`if`所对应的的就是`如果`，`MessageBox`所对的就是`信息框`，很多命令都中文化就再举例了，并且每个函数都是以表格似的填写，也就是代码的格式都定死死的了，如果你学过其他的编程语言在来和易语言比对，你多半会学的够呛，很难理解为啥要这样。不过也正是填表式声明，导致易语言过于简单，后文也会提及。\n\n在比对一些 C#的开发界面\n\n![image-20200924125428023](https://img.kuizuo.cn/20200924135324.png)\n\n![image-20200924125907216](https://img.kuizuo.cn/20200924135325.png)\n\n可以看到页面肯定比易语言好看 100 倍，但是随之而来的就是难度的提升，先不说好写与不好写，你让一个没学过编程的看，多半看的云里雾里，这时候就会劝退很多人瞬间不想学了，相信很多学编程的都有这样的经历。\n\n#### 上手容易，可以做到极速开发\n\n接着再来说一下上手学习，正是由于有上面那个前提，易语言可以做到上手特别快，可以说会用电脑，有逻辑，会识中文，易语言好学的一批，基本上学个几天自行写个软件完全没问题。对于国人一点编程基础都没有的新手，并且英语还不好的话来说，易语言可能是真的好上手，我当初学易就有一部分就是给英文劝退了。\n\n首先我要提的是可视化界面设计，你只需要将旁边的组件拖拽至窗口页面上即可，相对于的属性，例如内容，宽高，颜色在旁边显而易见，要修改只需要点击修改对应的数值即可，而对于其他的 IDE 来说，如果英文不咋好，并且还是第一次用，找可能都要找几分钟。而正是这个可视化界面，让我当初有信心学下去易语言，如果你学过 C 或者其他编程语言，一开始都是在那黑不溜秋的控制台显示，我就只是想写个软件用用，你给我讲那么多理论知识，甚至我还听不懂的那种有个嘚用。\n\n同时还可以直接打包成 exe 文件，直接在 windows 上运行，发给别人也能运行，哇，瞬间感觉到写软件的牛逼之处了，直接小有成就一波。这里我放几张我当初学易语言写的一些界面吧：\n\n例如写一个骗骗小学生的 2020 年最新刷 Q 币软件（用到了浏览器的填表功能改了 q 币的值）\n\n![demo](https://img.kuizuo.cn/20200924135326.gif)\n\n在比如做一个音乐播放器（是有声音的，只是我录制的是 gif）\n\n![demo1](https://img.kuizuo.cn/20200927031909.gif)\n\n在比如一些自动添加好友的\n\n![image-20200924191526221](https://img.kuizuo.cn/20200927031910.png)\n\n在比如写一个注册机模板\n\n![image-20200924192403210](https://img.kuizuo.cn/20200927031911.png)\n\n网络验证\n\n![image-20210819233054879](https://img.kuizuo.cn/image-20210819233054879.png)\n\n![image-20210819232928124](https://img.kuizuo.cn/image-20210819232928124.png)\n\n还有特别特别多的例子我就不举例了，这些用其他的编程语言肯定能写，但是与之对应的就是学习成本，很多人学其他编程语言，甚至还没学到界面设计就开始放弃了，原因很简单，没兴趣学呗，易语言界面好设计，但是基本都是原生 windows 组件，对于新手来说这完全足够设计出自己的软件了。\n\n**要是没能在最想学习的时候，满足自我的成就感，那很有可能就会学不下去**。\n\n我当初学易语言也是这样的，暑假学了两个月，其中第一个月学基础到还没什么，也就开始学习易语言的基本语法和编写一些程序来玩玩，但这些说实话没什么可看的，或者说没什么可用的，就想上面那个骗骗小学生的刷 q 币软件有用吗，没用呗。初学的一个月就都开始写这些可以说毫无软用的东西，直到我照着视频一个字一个字的模仿着敲一遍扫雷一键秒杀的代码，没错，就是这个激起了我对编程，让我感受到编程的魅力。放上一张 gif 图片。\n\n![demo2](https://img.kuizuo.cn/20200927031912.gif)\n\n当初照着视频一步一步来最终完成了该软件，但那时候的我其实根本不知道为什么可以这样，直到后续了解到汇编与游戏内存相关的知识，我才算真正懂的当初扫雷外挂的原理。\n\n也正是因这个扫雷的外挂，让我接下来的几个天疯狂的学习，去写其他的游戏外挂，比如连连看的一键秒杀，消消乐，植物大战僵尸等等。这里我也放一张图吧（还特意去下载 qq 游戏）\n\n![demo3](https://img.kuizuo.cn/20200927031913.gif)\n\n不过后面就没怎么学习游戏外挂相关的，一是所看的教程是 11 年的，中途没更新了，二是目前热门游戏以我目前能力写不出来，只要加上了检测，就过不了，并且容易封号（注：我 QQ 可不是开外挂给搞封了，就算开外挂最多也只是封游戏账号），最近接触的也就是 CF 越南服的外挂，有教程于是就学了点皮毛，不过教程又教到一半，就没深入去学习。这里提醒一句，写游戏外挂并销售是可是会给抓的。\n\n不过有点扯远了，就凭这一手界面设计，易语言其实就足以容易上手写出个软件出来。在叙述几点易语言容易上手的地方，自带提示，全中文文档，比如下图\n\n![image-20200924220413124](https://img.kuizuo.cn/20200927031914.png)\n\n只要你鼠标选到对应的函数上，按下 F1 或者点击提示，就有对应的函数提示，对应其他语言也有，但是纯英文的，门槛就高一个档次。\n\n#### 精易模块\n\n如果没有这个模块也就易语言跟其他语言的区别可能就是一个是中文一个是英文了。我就举我用的最多的一个命令`文本_取出中间文本`\n\n![image-20200924220908502](https://img.kuizuo.cn/20200927031915.png)\n\n而对于其他的编程语言，这类语言还需要自行编写一个函数来调用，而精易模块则是直接封装好好的供你使用。你都没必要去了解底层的函数，直接把门槛降了一个大档次。\n\n至于相关的程序编写我也不多概述，下面就是易语言的缺点。\n\n### 易语言的缺点\n\n我说说我用易语言的缺点，也是我最不推荐别人学易语言的了\n\n我上面也说到过 2000 年的页面与 2020 年的页面可以说是完全一模一样的。虽然有易友开发了仿 VS 界面的，但启动起来影响运行速度，我就没安装了。虽说我不是强迫症，但用多了 vscode 与其他的 IDE 相比，看到易语言就能想到是几年前的软件了。\n\n#### 占用空间与运行\n\n易语言毕竟还是一种封装过的语言，带来的方便，同时也牺牲了性能空间，与原生的桌面级开发相比易语言是无法比的。就比如用 C#开发的所占用空间肯定比易语言少，相关的性能优化更好，这里我就不放图了。\n\n#### 软件报毒，即使没毒也会给杀毒软件报\n\n这里我有必要说说关于易语言的一段故事，这里我放几个链接，可以去了解一番 [刷枪改图强登游戏 CF 外挂](https://www.bilibili.com/video/BV1WE411E7mQ/?spm_id_from=333.788.videocard.0)\n\n[为什么多数外挂都用易语言？](https://www.zhihu.com/question/20690643?sort=created)\n\n如果你在 2010 年左右接触过网络游戏，你肯定遇到过各种各样的外挂，而这类外挂多数都是出自易语言之手，甚至你现在在外面遇到的很多游戏脚本外挂，易语言也能占据多数。你随便百度一些易语言，相关的评论都是有关外挂这些。但事实上你只会易语言是根本不够写外挂的，我学过相关外挂制作，虽然学的浅，但至少学过。是需要汇编这类基础，但又为什么会很多外挂是用易语言写,，而且都是些水平不是特别高的人，原因很简单，因为那些写挂的很多都不会真正写挂，只是调用别人封装好了的库，甚至就连易语言自身都带了外挂库这些。让他们写一款新游戏的外挂，他们多半是写不出来了，原因就是他们不懂汇编这些，但是调用写好的库就 6 的飞起。当然这其中还是有些利益相关的方面，我也不多提了。\n\n如我上面所的我一个初中同学，要不是我接触了编写外挂这些，我还真信了他当初能写的，实际上都是修改外面的源码，或者是直接调用写好的库，直接偷源码用。\n\n因为外挂行业的崛起，导致一些厂商不得不进行一定的处理。总之，目前易语言写过的项目，多数是会报毒的，即便没毒，也已经给杀毒软件的厂商给拉入黑名单了，所以可以说没公司要易语言的程序员，即使软件没毒，但是还是报毒，你是信杀毒软件还是易语言？\n\n#### 说说我用到的一些坑\n\n我在做一些网页数据获取的时候，竟然连个 DOM 对象都没有提供，当时没接触前端，不知道有 DOM 对象，还是用正则去匹配，那时候是真的 nc。接触了前端，发现易语言竟然没提供 DOM 对象操作，我还是用别人封装的 DOM 类，并且还有可能出现匹配不到情况。\n\n其次是调试的时候，对于变量值长度过长竟然无法直接查看，还需要保存为文本才能查看，并且我调试的时候常常崩溃，导致我每次找一个 bug 的时候都需要重启易语言好几遍才行。\n\n由于是类似表格式的填写变量，参数与类型，也就导致了无法在其他编辑器上进行编写易语言代码比如我复制一个函数，给我的结果是\n\n```\n.版本 2\n\n.子程序 子程序1, 整数型\n.参数 参数1, 文本型\n.局部变量 变量1, 整数型\n\n变量1 ＝ 到整数 (参数1)\n返回 (变量1)\n```\n\n而在易语言所对的是\n\n![image-20200924222319462](https://img.kuizuo.cn/20200927031916.png)\n\n在易语言中的引号`\"\"`，只能通过常量`#引号`，或者通过常量表，就比如下面这个 jsoin 字符串 `{\"a\"=\"123\",\"b\"=\"321\"}`，而易语言的写法就是，`\"{”+#引号+“a”+#引号+“=”+#引号+“123”+#引号+“,”+#引号+“b”+#引号+“=”+#引号+“321”+#引号+“}\"`，一个个通过字符串来拼接，巨麻烦，也是我最想吐槽易语言的，不过也可以通过常量表来替换，但依旧很麻烦。\n\n还有易语言自身是不支持 utf-8 编码显示，原因很简单，当初只是为了给国人用，gbk 显然是更好的选择。但有时需要 utf-8 的，这时候就莫得办法。\n\n#### 没公司要易语言程序员\n\n几乎没有公司招聘易语言程序员，实际上上面所说的就足以证明易语言不行了。并且很多人都不看好易语言，黑易语言，至于为什么黑，百度或者知乎想必会有更好的答案，这里我也就不再赘述了。\n\n### 小总结\n\n写到这，我其实有点想把介绍易语言的一部分给删了， 我不推荐新手去学易语言，因为易语言相比于其他语言，它还是太弱了。但如果没有这半年的易语言学习，让我天真的以为编程的简单，又怎么鼓舞真正入坑，让我去学习更多更深奥的知识。\n\n不过就目前而已，我已经很少用易语言写东西了，但如果要写桌面级软件，我还是会首选易语言（因为只会易语言），毕竟写了也有半年了，开发效率也高。如果有机会的话，会深入学一下 C#还有 Qt，不过也不知道是什么时候才会有机会。\n\n关于英语方面的话，我是挺惧怕英语的，我高中英语就没怎么及格过，甚至我大学英语还挂科了，但易语言给我带来了编程希望。就我目前学习来说，编程还真的不怎么吃英语，看不懂英语文档，翻译成中文文档不就完事，而且学多了就会发现太多都是死代码，需要的时候翻阅文档直接 Ctrl C V 使用即可。英语对编程来说只是为辅，英语好并不能提高编程的上限，同时也决定不了下限，就这么说吧，你让一个学英语专业的人来看一份几百行的代码，基本注释写得在详细，他没学过编程，能看的懂吗？但有很多开源的项目都是英文的，会英文固然是好，但不会就不行了吗，看不懂英文文档，我翻译还不行吗？说这些，就是希望别用自己的短处来阻劝自己的目标，很多时候都是学了才知道这个有没有用，没学有锤子用！\n\n易语言是我接触过的第一款编程语言。那时候曾是我最喜欢的编程语言，也是最能让我感到成就感的编程语言，不过在这行学多了，还是不得不放弃易语言开发，原因就是因为易语言不够强大，但也莫得办法，如今易语言的生态就是如此。\n\n**如果易语言不是我的第一门编程语言，那么其他编程语言就是最后一门。**"
    },
    {
      "id": "2019.7-2020.7-log",
      "metadata": {
        "permalink": "/2019.7-2020.7-log",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/reference/2019.7-2020.7编程年记.md",
        "source": "@site/blog/reference/2019.7-2020.7编程年记.md",
        "title": "2019.7-2020.7编程年记",
        "description": "前言",
        "date": "2020-10-08T00:00:00.000Z",
        "formattedDate": "2020年10月8日",
        "tags": [
          {
            "label": "年终总结",
            "permalink": "/tags/年终总结"
          },
          {
            "label": "summary",
            "permalink": "/tags/summary"
          }
        ],
        "readingTime": 37.59,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "2019.7-2020.7-log",
          "title": "2019.7-2020.7编程年记",
          "date": "2020-10-08T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "年终总结",
            "summary"
          ],
          "keywords": [
            "年终总结",
            "summary"
          ]
        },
        "prevItem": {
          "title": "易语言",
          "permalink": "/easy-language"
        },
        "nextItem": {
          "title": "浅谈HTTP",
          "permalink": "/brief-talk-http"
        }
      },
      "content": "<!-- truncate -->\n\n## 前言\n\n写篇年记，记录一下自己这一年的所学。\n\n能有幸在这个行业有两点关键因素\n\n1. QQ 永久冻结\n\n2. 易语言\n\n### QQ 永久冻结\n\n有些认识我的人可能会知道我的 QQ804493238 给永久冻结了，可以说这个号码是不可能再搞回来的。一个幸幸苦苦养了十年的 QQ ，说没就没的那种，与之相对应的就是游戏账号没了，没了游戏能干嘛，当然不能干嘛，生活还是得过的，但又要有个东西来打发时间，没错就是编程。于是高中毕业后的暑假，就开始了学习编程。不过这里要先介绍一下易语言，作为我的第一门编程语言。\n\n### 初识易语言\n\n初识易语言的时候还是在初中，那时候有个同学给我讲诉了他用易语言刷 CF 永久枪，用易语言写游戏外挂的故事，也是那时候我也才刚接触网络游戏，一把永久枪 888 还免费刷，别说有多牛逼了好吧。可以说从那时候开始，下了个目标，以后有时间一定要学易语言！（不过那时候没条件学或者说是给游戏耽搁了）果不其然，在高中毕业后，就开始了易语言的学习（最主要的原因就是号没了，完全没有心思再玩游戏）。\n\n有关易语言的详细介绍我划分在另一篇文章 [易语言](/easy-language)\n\n### HTTP 请求\n\n这里我需要简单说一下这门技术，就是因为这门技术才能让我能写上软件，并且是有实质性用处的。有关这个介绍可以点击文章 [浅谈 HTTP](/brief-talk-http/)\n\n在开学军训一个月期间，也没有放弃学习易语言，不过那一个月应该不算学易语言这个语言，而是在学一个网络协议 HTTP，在这行的术语应该叫 POST 与 JS 逆向（基于易语言），这里我需要放一个我当时学习的链接 [零基础易语言 POST 入门到精通](https://www.zygx8.com/thread-7162-1-6.html)，导师教的非常好，是真心推荐，我从他的课程学到了非常多的知识，就凭我听了他的这一期课，就能自行写出超星刷课软件，我觉得这就足够我去报他的班。\n\n### qq 机器人  \n\n非常可惜之前写了一段时间的 qq 机器人代码无法使用了，相关文章 [纪念 QQ 机器人业黑暗的一天](https://www.bilibili.com/read/mobile/7009209?share_medium=iphone&share_plat=ios&share_source=QQ&share_tag=s_i&timestamp=1596387202&unique_k=vdFqN2)\n\n我用的是酷 Q 框架，用易语言写的代码，花了也有半个月的时间去写![image-20200926164358137](https://img.kuizuo.cn/image-20200926164358137.png)\n\n那时候封装了好几个功能，最终就因为腾讯的封杀，导致自己辛辛苦苦写了半个月的代码灰飞烟灭。这时候的心情与当初 QQ 被永久冻结一样，不过现在也看淡了，就算回来说实话也高兴不到哪里去，也就在以前群在多吹吹牛逼罢了。（泽宇是我之前玩网的一个艺名）\n\n这个 qq 机器人算是我手机端和电脑端一个变通的交互方式，以下是一些相关的菜单图，有些功能不方便展示，仅作为个人使用。\n\n![image-20220517010245349](https://img.kuizuo.cn/image-20220517010245349.png)\n\n1. 对接网络验证服务端，购买卡密，实现购买卡密\n\n![image-20200928204705890](https://img.kuizuo.cn/image-20200928204705890.png)\n\n2. 实现一些注册，例如一些软件注册给新用户多少时间使用，就不必在通过电脑，而是直接通过机器人发送命令来注册即可。\n3. 群监控，监控群里的一些不良信息进行撤回，监控刷屏进行禁言操作。\n\n只要你想，然后给上对应的代码就行了，那时候也是沉迷于 qq 机器人花了很多时间写这些接口。这里的话我说说那时候我用机器人来写一个学校的用手机进行超星线下考试。\n\n事情是这样的，这个考试是**用手机考试**的，但只能带一部手机，同时老师提供了题库，**允许带资料**，差不多就是开卷考。而且用于考试的软件（超星学习通）是**不允许切换的后台**来进行搜题的（或者说切换到后台会扣分），有些手机是无法分屏的（但是有悬浮窗）。这时候该怎么办，难不成真的去把题库打印一遍？还真有，十几张来着，先不说好不好，找一题都要找半天，有没有更有效的办法，有，我那时候就是通过机器人。\n\n首先，将老师发的题库，存入文件（那时候的我还不会数据库，就只好读文件），然后通过则匹配，将对应的题目，将答案全部都记录到数组里面去。接着在通过给机器人发送对应的命令如 查题+关键词即可搜到相关的题目。这里就放一个我当初录制的一个视频，（其他人操作也就是通过悬浮窗来）\n\n![demo6](https://img.kuizuo.cn/demo6.gif)\n\n即便眼睛再也好，也比不过可靠的搜索，搜索可靠也不及关键词筛选，当初考试就是通过这样方式来通过这场用手机的考试，但是也有缺点，只能说当初写软意识不好，没考虑周全，像这个搜题我还要再打一遍【查题】这个关键词，很傻，而不是发送【搜题模式】，然后直接发送题目获取就行，再发送【退出搜题】（那时候花了一天时间去写）。并且对于这样的搜题还要切换特别麻烦，好一点的办法，有，自写安卓悬浮窗，不过现在也没这样的考试了，也是我后面学了点安卓后随手写的，悬浮窗大致如下。\n\n![搜题悬浮窗](https://img.kuizuo.cn/floating.png)\n\nqq 机器人算是我特别想写的一个东西，但很可惜腾讯封杀外面大部分 qq 机器人框架，我使用的同样框架无疑避免，同时腾讯自己的机器人又不给开发者提供合适的开发接口，这就是腾讯吗，这本来就是腾讯的作风。\n\n至于后续如果有时间，或者要发展 qq 群的话，肯定会重新再写一份 qq 机器人，到时候想要实现功能可就多了。\n\n## 疫情期间，也是进步最快的时候\n\n上一阶段学习期间，从 7 月到下半年 1 个月，这一阶段主要就是易语言与脚本开发，相关也就是上述了，而下一阶段，也就是从 1 月中旬到开学（5 月 23 号），也就是差不多这期间，开始了逆向初步学习和 Web 开发方面，而这段时间，可以说除了编程，就只有编程了。\n\n先说下生物钟，晚上 6 点左右起来，然后早上 9 点左右睡觉，没错，这 4 个月基本上是这么熬过来的。（其中期间调整了两次作息习惯），因为疫情的因素，开不了学，又不方便出去，加上我本来也不喜欢出去，所以这阶段对我来说无疑是最好不过的，而这一阶段，也是我学习最多的时候，见识最多的时候，让我再一次感觉到编程的魅力，但同时让我感受到真正的编程和难。下面则会按时间顺序简单介绍下我学了什么。\n\n### 资源共享吧\n\n首先要提一个这个学习论坛，因为我在这个论坛上找到的很多教程，可以说没有这个论坛，我视频教程都不好找，先放个论坛链接 [资源共享吧](https://www.zygx8.com/forum.php)，首先这个论坛从名字上应该可以知道是资源共享的，是关于编程相关技术方面的资源，可不是那啥，我先放一张图片，看看到底都有啥资源。\n\n![image-20201005025855844](https://img.kuizuo.cn/image-20201005025855844.png)\n\n别说，基本上有关编程的你在这都能看到，当然肯定不是免费了，是需要交 VIP 的，但只要 199 元，终身高级 VIP 会员，别提有多值了，你知道外面一套培训有多贵吗，这我就不提了，自己搜一搜就知道了，我在写超星刷课不是提过一个讲师，我报了它的班，4000 安卓 VIP+3000 网页逆向 VIP 来着，而这里你只需要 199 元，并且在该论坛你也能看到他的一些相关课程。当然，和培训相比还是有一定的区别，但在这里的教程真不差。\n\n关于付费学习，可能有些人不解，为啥要收费，没为啥，就是你听付费的课程，能比别人学的快，能少走点坑路，很多免费课程要么就是为了推荐他的付费课程，要么就是为了推荐他写的书，总之，免费之中必有付费，单纯的免费课程能学，但想要走个捷径，付费应该是最快捷的方法。\n\n是真心推荐这个论坛，一点广告费都没收，因为在这个论坛上我下载了特别多有关编程相关的知识，奈何时间不允许，不然我真的都学了。正是因为我在这个论坛上学习到特别多的知识，这就是我推荐的理由之一。\n\n下面的大多数学习都是基于这个论坛上的视频教程。\n\n### 安卓逆向\n\n这上半年，我也只会网页端的数据分析与 JS 逆向，很多时候并没有网页版的，只有安卓应用，这时候想要偷其中的 api 接口，找到对应的加密点，该咋办，学呗。就必须要会安卓逆向，并且这个不比网页端简单。\n\n在我开始提笔写的时候，已经有半年没怎么碰过安卓方面的了，我都快忘记了我安卓逆向的好多知识，而且当初还没有写笔记的习惯，就连我一开始怎么入门的都没什么印象了，总之就是看了教程，然后一步步照抄，视频教程怎做就怎么仿，就完事了。\n\n同时也正是因为安卓，花了 10 天左右用 2.5 倍速度把毕向东的 java25 天速成教程看完了，而 java 才算是我真正第一门主流的编程语言，之前的 javascript 我是连 ES6 语法都不会的，甚至很多基本的语法我都不知道。但学完了 Java 的基础语法，但对于安卓逆向或者开发来说还是差太多了，虽说对于当时的我看的明白，但实际上整个安卓的项目结构我依旧不明白，不会点开发去搞逆向是真的折腾。\n\n合理来说我安卓逆向压根就没学完，或者说我只学到了 java 层的源码分析（java 是真的好反编译了），我还没什么能拿的出手的东西，没有破解过安卓软件，只是分析了跟网页端差不多的 HTTP 请求，差不多的加密算法，在这方面我还真的不知道该说写什么，即使说了，很多没了解过安卓逆向人也不懂，后续的话会再学安卓这方面，从开发到逆向，到时候会这方面的知识在进行一个分类总结。（主要是我真的忘了太多了）\n\n### Auto.js\n\n我先简单介绍一下这个是什么，这个也就是专门针对安卓端的无 root 脚本操作，看到后缀名你应该能想到 js，正是用 JavaScript 作为脚本语言。可以说用这个开发工具也能开发些安卓软件，但主要还是针对脚本操作，比如做一个 qq 自动点赞的， 贴吧签到脚本，抖音自动刷视频，双十一用过淘宝叠过猫猫吧，用 Auto.js 也能写个自动浏览商品，刷金币的，此外有太多例子了。\n\n在之前的脚本操作，我也只会电脑端的，而对手机端无奈只好投屏到电脑，通过电脑的鼠标操作来实现脚本，而现在有了这个软件，则就不用在连接电脑，直接将写好的脚本打包成安装包安装，点击运行即可。但对比原生安卓开发，这个开发工具还是略显下风，不过对于安卓的自动化操作已经足够了，我也只说说我用这个写了个什么软件。\n\n#### 钉钉签到脚本\n\n像抖音自动刷视频和贴吧签到这些我就不多举例，主要还是这个软件，听名字就知道是钉钉签到的，有些在疫情期间，学校老师又要求同学使用钉钉，并且签到，但是有的同学就是会忘记签到或者没起来（说的是我），怎么办，记旷课？这不写个脚挂在那边时间到了自动签到呗。\n\n![ddqd1](https://img.kuizuo.cn/ddqd1.png)\n\n这是我当时写的页面，只需要填写对应的课程名和开始的时间即可，时间一到，手机自动亮屏，开始签到。主要的代码就下面这一个函数\n\n```js\nfunction ddSign(courseName) {\n  launchApp('钉钉')\n  waitForActivity('android.widget.FrameLayout')\n\n  let course = text(courseName).findOne()\n  if (course.parent() != null) {\n    course.parent().parent().click()\n  }\n\n  let sign = text('群签到').findOne()\n  if (sign.parent() != null) {\n    sign.parent().parent().click()\n  }\n  sleep(3000)\n\n  if (desc('群签到')) {\n    sleep(3000)\n    let btn_sign = className('android.view.View').desc('签到').findOne()\n    let result = btn_sign.click()\n    Log('签到结果' + result)\n  } else {\n    toastLog('不在群签到页面')\n  }\n}\n```\n\n启动钉钉，等待钉钉启动完毕，找到对应的课程名，点击课程名，找到群签到按钮，点击群签到按钮，进入群签到找签到按钮，点击签到，签到成功。就这么完事了，脚本就是这样的。\n\n不过最终有个缺点，对于一些没有 root 的手机，需要每次运行就要不断的打开无障碍服务，特别繁琐，但没办法，这是安卓的机制问题。\n\n这里要提及的一句是为啥不用 HTTP 发送请求要来签到，而是要这种脚本方式，对比一下你就会发现，用脚本写基本无压力，就是简单判断一些字或者图在哪，然后点击对应的坐标，而通过 HTTP 请求的话，一是要过钉钉登录，二是要处理各种加密算法。不过钉钉登录算法难不难我就不知道了，我也懒得分析，加上正好学了 Auto.js，索性就写一个这样的签到脚本得了。但说实话签到就不应该这样用这种定时脚本，而是应该选择协议更好。\n\n### 深度学习之图像识别\n\n可以去了解一些深度学习，颠覆我对机器的认知，至少让我又觉得编程的强大，重拾学下去的信心。首先，先看张图片\n\n![QQ图片20201004030419](https://img.kuizuo.cn/QQ%E5%9B%BE%E7%89%8720201004030419.png)\n\n看图也能看明白，这个就是识别一个缺口的图片软件，可能对没接触过这行业的人觉得这并没有什么软用，这个滑块的意义主要还是防止人为操作和机器操作。对于人而已，自然而然知道缺口的位置，但是对于机器而言要怎么知道这个缺口的位置，就针对上面这类图片，可以通过图片颜色深度来定位到缺口的地方，同时也可以使用深度学习，简单来说深度学习就是 AI，不过这里的 AI 是用来让它识别这个缺口，至于怎么让它识别和对应的算法我就没过多了解了，我接触这个主要还是用现成的模型来训练识别的。说一下我是怎么让机器训练的。\n\n这个过程其实就跟教小孩一样，现在有一个小孩，他不知道这个缺口的位置，这时候我告诉它缺口的位置在那，对应的操作也就是标注，如下\n\n![image-20201004031417625](https://img.kuizuo.cn/image-20201004031417625.png)\n\n我把缺口的地方标注一下，并记录对应的坐标，然后告诉这个小孩，缺口是我标注的地方，你下次遇到的时候记得是缺口这样的，但是小孩毕竟是小孩，这是我换一张类似的图片，这时候他可能就蒙了，所以就需要不断的给他标注好的缺口图片，让这个小孩一直看，一直记，直到下一次看到一张陌生的图片，但是它已经把之前训练的给记住了，很快他就能找到缺口的位置，这整个过程其实就是告诉小孩，然后让小孩一直训练，这就达到了我们想要的目的，这个小孩也会知道缺口的位置了。现在把这个小孩换成机器，那么这就是深度学习，并且机器是机器，可以封装的“记忆”远比人类可比，人是会感到疲惫的，而机器不会。再比如下面这张图片\n\n![image-20201004033445666](https://img.kuizuo.cn/image-20201004033445666.png)\n\n对于我们来说显示屏，键盘等等这些在常见不过了，深度学习就可以做到识别图片对应的物体分别是什么，不过这要的训练量就比上面那个滑块大多了。我这里简单说说主要的通途，现在我想拍一张人脸照，还有风景照，但是时间旧了，我想找可能就要一定的时间，这时候就可以通过识别图片，进行分类，例如头像照，风景照，食物照等等，现在大多数相册都有上述图片分类的功能，不止如此，通过训练还可以识别文字，快递单号，车牌号，识别人脸等等，总之想训练的东西，都能训练，不过就是吃训练量和显卡，一般来说都是用现成的模型直接用就完事了。对我目前而言，我深度学习学的是非常浅了，也只会用用模型，跑个显卡训练训练。\n\n此外，既然图片训练是这样的，能不能训练其他的，当然，语音识别，模拟一些明星的声音，游戏 AI，甚至让机器自己去学习怎么打游戏，游戏内的人机也就如此，通过训练满分作文，实现写一篇条理清晰的作文等等，太多例子都能看到人工智能。\n\n关于这方面我也不敢做过多讲述，毕竟也还没开始从事这方面的真正学习。但确实，惊艳到我了，也让我想去学习这方面的知识。想自己写一个属于自己的语音 AI 助手，训练出一个能自己玩小游戏的模型，总之想学的太多了。\n\n### Chrome 扩展开发\n\n关于这个的话可以查看我写过的一篇文章 [Chrome 插件开发](/chrome-plugin-development)，我总结了一下我那时候学习的插件，和自写的一些模板，不在这做过多赘述了。\n\n疫情这期间说句闭关学习应该不成问题，不过学的东西远不止于此，主要其他的没写出啥玩意，而且学的很浅很浅，比如汇编基础（不过应该已经忘得差不多了），又深入学习了编写游戏外挂，TCP 协议（和 HTTP 一样），还有就是一些开发工具的使用。期间也写过一些东西，例如疫情填表，网课签到等等，不过都是临时写来自用的，也懒得放图了，原理基本和超星刷课一样，有时间再整理一下。\n\n## Web 开发\n\n在进入了这个阶段，我就很久没再用易语言开发新的软件了。到目前为止也真的快半年没怎么动易语言的代码了（也快半年没怎么写项目了），就那个超星刷课而言，没想到半年后还能用。而这一阶段主要接触的也就是 Web 开发方面。\n\n实际上，我在接触易语言就已经接触了一些 Web 方面，因为要针对网页的一些操作就不得不接触这些，比如 HTTP 协议，DOM 解析，CSS 选择器，JS。不过那时候这对真正的 Web 开发远远不够。当然要说一下为什么会想学习 Web，在学 Web 之前，实际上还接触了一些 js 高端操作，例如 AST 语法树（混淆 js 代码），WebSocket，但发现有点没学明白，用都有点没用明白，然后就是想搞明白这些操作，于是进阶学习 js。\n\n其实决定性的也就是一门编程语言——JavaScript，那时候感觉到易语言的不足，恰好手头在学的一门编程也就是 JavaScript，于是就开始了 JavaScript 的学习，可以说不是 JavaScript，Web 想都没带想的。js 作为我目前的主力语言，就目前而言，基本屏幕上，必有 vscode 的痕迹，而且还是 js。js 吸引我的一个地方就是其他语言都能调用，加上语法清晰，不过要我硬说 js 哪里好，我也说不清楚，可能这就是对一件事物的热爱吧。\n\n于是改变了当初原有的想法——搞安卓开发与深度学习，转行到 Web 开发去了，和学习其他技术一样，找教程，跟教程做一遍，自己在举一反三一波才不多就明了。\n\nWeb 学习确实比逆向轻松，并且学完 Web 能写的东西也算比较多。也算可以自己动手设计出一个界面或者功能出来，上手特别容易。这里我就不献丑了，之前前端写的那些代码真没脸丢出来。就连当初的笔记我都不敢看，写的是什么玩意，竟然还是在 js 文件上用注释来记录笔记。\n\n就这样学习了几周，然后收到了开学通知，没错是开学通知，疫情的时候，开学一个月，于是就停滞了学习近一个月了，前面也说到，生物钟的问题，开学了就不得不强行调整生物钟，把我学习节奏给打乱了。其次突然开学，心态是真崩了，开学各种繁琐的事情搞得压根学不进去。原本不出意外在保持这样的学习状态一直学下去，暑假结束前就能把 Web 大部分知识都能搞完，然而却拖到现在。\n\n不过也不能说开学不好，从 1 月 10 号放假，到 5 月 23 号开学，在家好像也就出门了 2 次，要是再这样拖到暑假估计身体可真要出问题。停滞了学习，但保住了身体，是赚是亏，对我来说血亏吧。\n\n然而暑假由于学车的因素，加上外出玩了一波，整个暑假并没有像去年那样全身心投入去学习，不过业余时间会去摄取有关这行的知识与科普，也就是刷刷知乎，公众号，博客文章等等。而也就是在这段了解到了 Nodejs 与 Vue，暑假开始学习。\n\n### Nodejs\n\n不过学前端，Nodejs 基本是必接触，基本可以说只要是个前端开发者，就肯定会 Nodejs，关于 Nodejs 不做过多介绍，我能推荐的也只是一些 npm 包，总之在这期间 也就是只学了点 Nodejs 的基本使用，还有 npm (Node 包管理器)。\n\n主要接触两个 Web 框架 Puppeteer 与 Express，关于这两个我在 Node 的那个目录内有简单说明到，这里也就不放链接了。这里简单说说 Express\n\n### Express\n\n学 node 大多数就是为了搞服务端，那么肯定也有对应的服务端框架，Express 就是其中之一。\n\n在此之前，我是写过点后端的，也就是一个网络验证的系统，不过那时候是基于易语言和 HP-Socket 的库，但有一个很大缺陷，就是我这个后端服务器编译出来的是 exe 文件，也就是只能在 windows 上运行，这对 Linux 系统服务器很不友好，于是乎就想搞一个基于 Express 的网络验证服务端。\n\n而这期间才算学会用 Mysql，之前易语言写的网络验证时连 Sql 语句都不会，还都是用易语言自带命令帮我封装好来进行增删改查。也简单的将易语言写的网络验证接口全都搬运至 Express 中，然而有个问题来了，我要怎么查看数据？难不成直接打开数据库查，怎么可能，而这就开始了 vue-element-admin 开发，后文会说到，因为这里要涉及到一个新的技能——Vue。\n\n### Vue\n\n可以说没有 Vue，我多半不会去继续学习前端（怎么感觉这句话好像说过了），和大多数人学 Web 一样，都是从基本的 HTML CSS JS 这前端三件套开始学起，然而在学到一半的时候，想写一写 Web 小项目的时候，就需要在一个 HTML 上写上大量代码，并且页面还不好设计，并且在用了 Express 一段时间后，发现如果要做动态网站的时候，就需要将数据渲染到对应的模板语言上（如 ejs），于是想知道有没有啥能解决这上述问题，于是便开始搜索有关前端的一些相关知识扩展，果不其然，困惑了我一段时间是否继续学习前端，因 Vue 而解惑。\n\n如果要我评价一句 Vue，我只能说后悔学 Vue，后悔学晚了。我花了挺多时间在原生的前端开发，在了解到 Vue 时，还在用着 Jquery。Vue 让我继续学前端并不是数据交互方面，而是模块化，在我接触原生前端开发的时候，这个问题尤为困扰我，每次写一个页面都需要重复大量相同代码，即便是复制粘贴也觉得烦躁，而 Vue 组件化就不一样。例如我当前的博客页面，你会看到导航栏，侧边栏，与正文，评论系统，乃至打赏按钮都是一个个组件拼接而成，只需要在单个 Vue 文件中，引入对应的组件，然后想 html 标签那样直接写在视图层上即可显示，当然，相关代码也展示了，有关 Vue 的我也都放在 Vue 这个目录下。\n\n然后就是基于 Vue 而开发的组件库，在 Web 开发难免不了页面设计，然而并非所有程序员又兼设计师，想要设计出一个好看的按钮或其他组件并非容易的事情，而组件库便提供了一个好看的组件供开发者使用，例如通过引入 element 的样式与组件库\n\n```html\n<!-- 引入样式 -->\n<link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\" />\n<!-- 引入组件库 -->\n<script src=\"https://unpkg.com/element-ui/lib/index.js\"></script>\n```\n\n然后在官网中找到需要的组件，如下按钮\n\n<el-button type=\"primary\" plain>主要按钮</el-button>\n\n而对于的代码也就是\n\n```html\n<el-button type=\"primary\" plain>主要按钮</el-button>\n```\n\n只需要简单修改一下参数就能生成相应的组件。哪里还需要花费大量时间去写 css，不断改参数，上手即用，快速成型。\n\nVue 模板语法也是，显示后端传递的数据也简单，比如下面这行\n\n```html\n<h1>标题: {{ title }}</h1>\n```\n\n只要接收到后端发送来的标题，即可渲染在`{{title}}`内，此外还有数据的双向绑定，关于这些等等不在这细说了，需要的话可以自行翻阅 Vue 文档。\n\n而且就这么说吧，前端框架如果不学 Vue 和 React 其中之一，面试都不给你面试的。甚至可以说，Vue 和 React 是前端开发必学之一，不学就跟不学前端没两样。\n\n同时 Vue 还是国人尤大大（尤雨溪）开发的，在国内生态好，社区活跃高。基本上目前国内的大部分 Web 项目都有 Vue 的身影，同时 Vue 不止于前端，小程序的开发等等也有它的身影，如 uniapp 就是使用 Vue.js 所开发的。\n\nVue 能做的太多了，如果你恰好准备学 Web 方面，尤其是前端，毫不犹豫，直接学 Vue，Vue 在 github 上排名第三，star 高达 175k，凭这，就足以去学习一番。\n\n### Vuepress\n\nVuepress 一个 Vue 驱动的静态网站生成器，可以用 Vuepress 来写文档，写博客，而我目前这个博客便是通过 Vuepress 实现而成。关于这个博客搭建过程就不在这花费口舌了。我有一篇文章专门讲述这个博客的搭建过程。\n\n### 对 Web 开发做个小总结\n\n可以说没有前半年易语言学习所接触到的 Web 知识，就别说 Web 开发了，JS 估计都不会了解到，也因 JS，误打误撞闯进了 Web 开发的坑，让我领略到更多知识。\n\n我算是作为 JS 语言的粉丝，听说过一句名言：凡是能用 JS 实现的最终都将用 JS 实现。即便不理解这句话的意思，但依旧这句话很喜欢，也许这就是对 JS 语言的一种爱吧。\n\n![javascript](https://img.kuizuo.cn/javascript.jpg)\n\n写到这，其实 Web 开发真就要告一段落了，实在是不想在折腾 Web 了，主要就两点\n\n- 不会设计，不知道该设计什么，实现什么功能\n- 后端数据接口写的非常痛苦，Express 折磨了我一个月\n\n在页面设计方面，有组件库很方便，但是不知道要写什么好，就那个网络验证而言，我已经绞尽脑汁想添加写功能，但是奈何后端写的折磨，很多我都写不下去，就比如用户-角色-权限 这三者关系，我只写了用户-角色 还有权限没写，还有积分，与 nodejs 模拟数据这些写的都特别鸡肋，实在是写不动了（甚至说实在不想写了）。想转型写点其他的，后续有时间才把这个在做过多优化。\n\n目前把博客和网络验证基本搭建好，现在脑子只想好好写写博客，把这一年要学过的东西好好巩固一番，尤其是这一段 Vue 的学习，收获到太多知识，都有点来不及消化。后续会将这些都部署在该博客上（不妨点个收藏收藏个书签呗）\n\n不过我目前的 Web 开发还有很多没学到，而关于 Web 后续的学习的话，以目前的话应该是不会在花费大量时间去学了，学了也有半年了，自我感觉 Web 这方面还是不适合我，但确实这半年的 Web 学习挺充实的，不会接着深入学习,会用已学过的知识去写一些东西出来。（主要还是太想学习其他技术了）\n\n## 总结这一年学习经历\n\n这一年学的确实多，相比于刚接触这行一年的人来说的话，我挺知足这一年能花费大量心思在这上面，同时还能坚持学下去，并爱上编程，于是乎从数学系转到了计算机系，但学还是自己学自己的，在我看来学校老师能教的，不如我课下自己学习的，况且编程单靠别人教是教不出什么玩意的，还真没听说过什么大神是另一个大神教出来了。\n\n不过正是因为这种心态，也导致如今我连学校的课基本也都不会去上，能旷的课尽可能旷，旷课补觉，或者是宅在宿舍，坐在电脑前，盯着这赏心悦目的代码，和平时分相比它不香吗。既然旷课，那怎么能不挂科，虽然都是公共课，不过挺无所谓了。说件好玩事情，我大学英语挂了，没错，我英语说实在话就是不行，甚至我都没打算过四级考试，但这影响编写代码吗？不言而喻。\n\n专业课的话，有的老师一般会认可我的能力，允许不去上课只考试就行，或者是不去也不会记名字，甚至和老师说一声不去就完事了。至少在我看来有时间在学校拿个文凭，不如直接用自己写过的项目去面试，至于看学历还是看能力，面试官一般都不看，因为只看简历呗。目前的话除了有关编程的事啥也不想干，估摸着在学一段时间就说不定真就辍学了呗，不，说不准还是给学校开除。\n\n### 身体状态\n\n早已习惯了凌晨晚睡晚起，早上的课基本也都是旷了的那种，就已经习惯了旷课。再看看下午的课，不出意外的话，一般就是坐在电脑前到，到点了吃个饭，接着到凌晨 3,4 点，每天反复这样。我都不敢说我在这方面有天赋，我只觉得我每天花费在这方面的时间是别人的几倍罢了。\n\n**哪有什么天生，一切不过是摧残出来罢了。**\n\n说实在话，挺享受整天在电脑前办公的生活（相比于躺在床上玩游戏而言），不过熬夜，久坐，与长时间盯着屏幕，甚至是掉发，身体难免有些遭不住，并且我是能感受到，身体一天不如一天了。但它改变了我原有枯燥的生活，成天的游戏与娱乐，迷茫到不知所措， 如果没有 QQ 冻结，还有易语言，JS 这些，说真的，我现在极有可能还在某个床角玩着游戏，还对着屏幕傻笑（现在就特别想笑）。即使都是宅在家的生活，但编程能成为我养家糊口的资本，而游戏，它不行！甚至还可能成为我颓废的资本。\n\n### 事实告诉我，我还有很多要学\n\n就在 9 月初，参加了一场网络安防（CTF）的比赛，真的是小巫见大巫，瞬间觉得自己还有很多要学的，虽然其他选手都很强，但也印衬了自己在这方面就是技不如人。说白就是自己菜，就是学的不够多，要是能在多学一点，说不定就多解一道题，多拿一点分，说不准就苟一波，吃个烂分。而事实是这是场没拿奖的比赛，而我是这场比赛的失败者。\n\n不过有参与必有收获，确实让我学到了 Web 的一些渗透知识与一些工具的使用，也让我更加觉得外面的大佬是真的多，自己离他们还需要更加努力一把，这场比赛值了。\n\n### 给别人的一些建议\n\n我也仅能给别人一些我学习上的建议，也仅仅是当前，毕竟我接触这样也才一年多。我其实都不推荐去学编程这玩意，但我常常和别人说多花点时间在这上面，能写出些东西来。话是这么说，但真正肯去学的又有几个，即便学了坚持下去的又有几个，即便花费口舌去和他们介绍，但多数觉得难，但你说这个东西难吗，很难，但你说学不进去吗，也不至于，如今网络上生态这么好，学习编程的人越来越多，相互帮助的人也多，只要肯学，肯下功夫，随便一百度就有的结果，怎么可能学不会。\n\n#### 多搜索，少问人\n\n我这一年学习中，基本上就是看视频跟着视频教程一步一步照做，我一开始学习的时候也会在群里问过别人，也私下问过别人，但是有用吗？压根就没用，基本就没什么人会去鸟你的。百度它解决不了吗，如今强大搜索引擎会是你解决问题的最好选择（甚至我帮别人解决问题还是我将百度结果链接给别人）。有两句话，百度 5 分钟，问人 2 小时。百度能解决你百分之 99 的问题，但问人并不一定解决其中的百分之 1。\n\n![006ARE9vgy1fwntelg0mlj30b40b4gm1](https://img.kuizuo.cn/006ARE9vgy1fwntelg0mlj30b40b4gm1.jpg)\n\n**没点自行解决问题的能力真心劝别碰这行。**\n\n我现在都有点反感那些没自行尝试，就直接问人的那种，有什么好问的，要么你学的不够多看不懂呗，要么就是你那里少做了什么步骤，大不了重新卸载安装重启来一遍嘛。主要没点自行解决问题的能力，到时候项目一来，出了一个 bug，或者开发环境与生产环境有问题，你问谁去？问了会回复你吗？能不能先自行看看是不是哪里少改的，或者版本的问题。说太多就是想强调一点，自行解决很重要，决定你适不适合干这行。\n\n话也不能说的这么绝对，有时候搜索引擎确实不能有效的给到你想要的答案，比如我所用过的一个博客主题，是有交流群的，但有时候我百度了半天就是得不到我想要的结果，然后一问群，**可能**会一些**热心伙伴**会给你**正确**的答案，但往往是在你**实在解决不了**的情况问。毕竟，问了不一定答，但是不问一定不答。\n\n#### 复制粘贴也是一门技术\n\n别觉得偷别人代码有什么丢脸了，有的人甚至连偷都不会偷，而你早早就把项目给搞定了，别人会认可你的过程还是认可你的结果，必定是结果好吧，而且干这行的，基本上你见不到一个程序员是真的每一行每一行开始写起，而用的最多的三个键 Ctrl C V，不会真有程序员一行一行的敲吧，不会吧，不会吧。\n\n![7280a4701a0daf98](https://img.kuizuo.cn/7280a4701a0daf98.jpg)\n\n当然，上面也只是说笑了，只是现在都是模块化编程，什么意思呢，就比如我要实现一个自动发送邮件的功能，怎么办，直接搜索，比如 nodejs 中实现发送邮箱，于是就搜索到了 nodemailer 这个模块，二话不说，直接运行官方的 demo 案例，发现可以运行，能达到我想要的目的，接着就是自己简单的封装一下，直接给项目来使用，这不就成了吗？\n\n然而要从 0 开始写一个发送邮件的服务端，别有这种想法，大概率不会想写的。就我目前而言吧，除了一开始学习新的技术外，会跟着敲一遍磨磨手感，到后面基本上都是从网络上偷各种源码，然后自己看一遍主要的地方是怎么实现的，然后对源码进行修改来达到我需要的目的。如今网络环境这么好，想要的功能随便一搜就有了，如果你能做到改别人的代码，那么别人这份代码你肯定也学进去了不少。为啥还要自己造轮子，尽可能利用别人已经写好的代码，而不是自己在手动写一份类似功能。\n\n## 定一下明年的目标\n\n到目前为止，我还有好多想写的东西没写，好多好多都写了一半由于一些某某原因没继续写下去。同时还有好多想学的技术，好多都是之前学到一半卡着就没接着学下去了。至于能学多少，尽力而为吧，希望明年的这个时候，在回头看看自己所写的一些代码，都能感到一些惬意。\n\n### 进阶 Web 开发\n\nVue 才学了点皮毛，很多 HTML5 特性都没玩明白，CSS 也只会基本样式，就别说设计网页特效啥的，能看的过去就不错了，如果有时间的话一定会去接触写 React，毕竟和 Vue 一样，都属于人气爆棚的前端框架，很多大厂都使用 React 作为前端框架使用。\n\n像 Webpack，Eslint 等等前端工具库，再如 JavaScript 的超集 Typescript，这些肯定都会去学习一番。\n\n### 进阶 Python\n\n学过点 Python，但并非精通，有特别多的库都还没用过。主要说说为什么想学 Python，最主要的就是深度学习这方面，在前面我也写过，深度识别之图象识别，其次就是模拟数据请求这些，如果知道 Python，说到爬虫自然不陌生，不过爬虫对我来说并不敢兴趣，主要是 Python 好做模拟请求，http 协议这些，在易语言这些操作都是乱写，基本没啥难度，当然，http 协议难得不是模拟数据请求，而是在逆向分析数据加密，风控算法，所以网页逆向的基本功还是要有的。\n\n当然，如果有可能还会接触一些 Python 的后端框架 Djongo 和 Flask，看看会不会符合自己的编程风格，再考虑是否要重写一些后端接口，当然最主要的还是想学习 tensorflow，我本地环境都搭建好了，然而却没有花大量时间去在这方面学习！\n\n### 安卓逆向与安卓开发\n\n干这行前，我就是个重度手机使用者，或者说是玩机者。对于手机特别感兴趣，刷过机，拆修过手机，手头目前就有 5 台手机，对于电子设备可以说是又爱又恨了。用过的 APP 多，然而有些 APP 并不能达到我想要的目的，或者说有限制，于是就想尝试利用逆向技术去修改，奈何那时学了皮毛的安装逆向，根本不够用，也感到困难，于是就没继续学习，一开始的本心还是想搞安卓这方面。\n\n如果可以的话，我更希望的是当一个安卓开发人员或者逆向分析工程师，而不是一个 Web 开发人员或者网络安全工程师。至于最后能如何，谁又能说的准呢。\n\n### github\n\n就目前而言，git 还有很多没玩明白，主要手头也没啥好开源的玩意，明年，一定多刷 github，当然最想的还是搞一个开源项目，还能在 github 上小有知名，那干这行真就无悔了。有点小野心，但以目前能力估计是够呛，想想就好，到时候技术上来的指不定就真成了呢。\n\n这不才学了一年，才 20 出头，留给我的时间还多着很，在学个十年不成问题吧。但话是这么说，自己心里很清楚，已经有点学不进去了，就我写 Web 项目的这段时间，写着写着就去搞其他东西去了，实在是写的憋屈。总之已经没有一开始那么想学，那么有想法与灵感，那么肯于去学习新的技术，估摸着在学几年也许就会停滞于学习。\n\n本以为年轻有的是精力，还曾妄想把好几门技术都学进去，但事实告诉我，能精通一个就不错了，学那么多意义又在哪，只是为了满足当初高中不认真学习的而又渴望学习的心吧。\n\n总之，能学就尽量学，明年，理应更强。\n\n## 感谢\n\n最后还是要感谢互联网的前辈们，与当下互联网的环境，不然的话我还可能在迷茫中四处摸索人生的真正意图，耗费着年轻所带来的资本。往着曾经写过的代码，眼角不禁也会湿润起来（绝不是熬夜太困），感叹当初为啥会去学这东西呢，也许这就是编程所带来的魅力吧。\n\n<p align=\"right\">写于2020年11月18日    By 愧怍</p>"
    },
    {
      "id": "brief-talk-http",
      "metadata": {
        "permalink": "/brief-talk-http",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/develop/浅谈HTTP.md",
        "source": "@site/blog/develop/浅谈HTTP.md",
        "title": "浅谈HTTP",
        "description": "记录 git 操作失误导致代码丢失与找回的过程",
        "date": "2020-09-29T00:00:00.000Z",
        "formattedDate": "2020年9月29日",
        "tags": [
          {
            "label": "http",
            "permalink": "/tags/http"
          }
        ],
        "readingTime": 7.166666666666667,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "brief-talk-http",
          "title": "浅谈HTTP",
          "date": "2020-09-29T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "http"
          ],
          "keywords": [
            "http"
          ],
          "description": "记录 git 操作失误导致代码丢失与找回的过程"
        },
        "prevItem": {
          "title": "2019.7-2020.7编程年记",
          "permalink": "/2019.7-2020.7-log"
        },
        "nextItem": {
          "title": "Chrome插件开发",
          "permalink": "/chrome-plugin-development"
        }
      },
      "content": "<!-- truncate -->\n\n关于 HTTP 我不讲理论，只讲一下具体的用途。\n\n## GET 请求之发送验证码\n\n首先我举一个例子，收过短信验证码吧，一般来说在你注册账号的时候就会用到，会有一个点击发送验证码的按钮，这里以 网址 [114 预约挂号](https://www.114yygh.com/) 为例\n\n![image-20200928234944932](https://img.kuizuo.cn/image-20200928234944932.png)\n\n输入完手机号，点击获取验证码就能收到验证码，但这背后的原理又是啥，服务器那边怎么知道我要验证码，并且我输入正确的验证码就进入，错误的就不行。而这正是网络协议 HTTP（关于 HTTP 相关的这里不做过多讲述，希望读者能自行百度了解），我先说下点击了获取验证码发生了什么，通过抓包工具可以获取到如下请求\n\n```http\nGET https://www.114yygh.com/web/common/verify-code/get?_time=1601308153790&mobile=15212345678&smsKey=LOGIN HTTP/1.1\nHost: www.114yygh.com\nConnection: keep-alive\nAccept: application/json, text/plain, */*\nRequest-Source: PC\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3775.400 QQBrowser/10.6.4208.400\nContent-Type: application/json;charset=UTF-8\nReferer: https://www.114yygh.com/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\n```\n\n首先我们向服务器发送了一个如上的请求，这是一个 GET 请求，同时请求的链接（url）为`https://www.114yygh.com/web/common/verify-code/get?_time=1601308153790&mobile=15212345678&smsKey=LOGIN`\n\n如果你会点英文的话，可能会理解其中的含义，主要就这几个参数`verify-code`验证码，`_time=1601308153790`时间戳（时间戳是一个记录时间的东西，用当前时间减去`1970-01-01 08:00:00`即可得到，你可以通过这个工具[时间戳在线转化](https://tool.lu/timestamp/)，这里的`1601308153790`所对应的时间为`2020-09-28 23:58:06`）还有一个`mobile=15212345678`，这个`15212345678`是我刚刚输入的手机号。这是向服务器请求的数据，那在来看看服务器返回给我们的是什么\n\n```http\nHTTP/1.1 200\nDate: Mon, 28 Sep 2020 15:49:15 GMT\nContent-Type: application/json;charset=UTF-8\nContent-Length: 57\nConnection: keep-alive\nSet-Cookie: hyde_session=Kd10cra3X4yNBePaaQTKUkuYgX9J6Hfx_5337693\nSet-Cookie: hyde_session_tm=1601308154470; Domain=.114yygh.com; Path=/; HttpOnly\nContent-Security-Policy: : default-src *.114yygh.com *.qq.com *.baidu.com; font-src * data:\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\nX-Frame-Options: SAMEORIGIN\nX-Via-JSL: d8c5e31,-\nX-Cache: bypass\n\n{\"resCode\":0,\"msg\":null,\"data\":{\"endMilliseconds\":59997}}\n```\n\n只需要关注最后一行即可，其中 resCode 为 0，同时手机号`15212345678`也收到了验证码，貌似 resCode 为 0 就决定了服务器是否有给手机号发送短信，事实上也是的，那么说了这么多，有什么用呢，用处可大了。\n\n既然这样，我知道了发送上面的那个请求服务器就能给对应的手机号发送验证码，那么我能不能将上面那个请求的手机号给改一下，改成`15287654321`，事实上是完全没问题的，这里我就放一张 HTTP 测试工具的截图。\n\n![image-20200929001306474](https://img.kuizuo.cn/image-20200929001306474.png)\n\n那么是不是我多请求这样像服务器请求，我就能源源不断的收到验证码，现实很美好，人家服务器也不傻，我再一次向服务器发送请求，服务器给我的结果是\n\n```\n{\"resCode\":10000,\"msg\":\"请58秒后重试\",\"data\":null}\n```\n\n没错，就需要等，而且这里的 resCode 也不为 0，那么既然要等一分钟的话，我能不能写个定时脚本，每隔一分钟发送一次，人家服务器也不傻，一般来说，一个手机号最多也就收 5 次验证码，多了就会提示明天再重试，或者今天收到的验证码过多等等。而外面的炸则是通过收集几百个这样的请求，然后将手机号替换成要轰炸的，即可实现多平台验证码轰炸一个手机号。\n\n现在你可能已经知道了初步了解 HTTP 请求，但一般的网站都不会像这个这么简单的，明文标码，通常都会进行效验，例如图片验证码，滑块，点字，点图等等，并且还会进行加密操作处理，而这才算真正的难点。\n\n## POST 请求之登录\n\n既然发验证码是这样，那如果是登录呢，下面就用网站 [万创帮](https://m.wcbchina.com/) 为例，首先进入登录界面\n\n![image-20200929003119277](https://img.kuizuo.cn/image-20200929003119277.png)\n\n输入手机号和密码，点击登录，同样的我们可以通过抓包工具获取到对应的 HTTP 请求，如下\n\n```http\nPOST https://m.wcbchina.com/api/login/login?rnd=0.6463111465399551 HTTP/1.1\nHost: m.wcbchina.com\nConnection: keep-alive\nContent-Length: 149\nPragma: no-cache\nCache-Control: no-cache\nAccept: application/json, text/javascript, */*; q=0.01\nOrigin: https://m.wcbchina.com\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Mobile Safari/537.36\nContent-Type: application/json\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\n\n{\"auth\":{\"timestamp\":1601312429287,\"sign\":\"777473FB2A1838DBD64BA7A11C98911B\"},\"username\":\"15212345678\",\"password\":\"E9BC0E13A8A16CBB07B175D92A113126\"}\n```\n\n貌似比上面那个发验证码的复杂，确实，这是一个 POST 请求，你在链接上看不出什么有效信息，在最后一行才是关键。这里的`timestamp`也就是时间戳，记录时间的，username 是我们输入的手机号（账号）没什么问题，这里的 sign 和 password 的内容又是啥？这就是加密，让你不能简单单纯的通过替换文本来实现登录，这就来分析一下他到底怎么加密的。\n\n通过在浏览器按下 F12 键，打开控制台面板，接着点击 Network，这里会将我们发送的请求记录下来\n\n![image-20200929004247182](https://img.kuizuo.cn/image-20200929004247182.png)\n\n同时鼠标停在 Initiator 上有如下结果\n\n![image-20200929004449660](https://img.kuizuo.cn/image-20200929004449660.png)\n\n不管三七二十一，点击跳转到对应的代码先，然后在左边下一个断点\n\n![image-20200929004628978](https://img.kuizuo.cn/image-20200929004628978.png)\n\n这时候我们在点击登录按钮看看\n\n![image-20200929004713733](https://img.kuizuo.cn/image-20200929004713733.png)\n\n没错，浏览器这时候停了下来，停在了我下断点的地方，通过函数名也可以猜到这个是发送的，对应的肯定在上面，通过右边的 Call Stack 函数调用栈即可追随上一函数\n\n![image-20200929004943674](https://img.kuizuo.cn/image-20200929004943674.png)\n\n在这里我看到了原文的信息，这是通过 Jquery 通过 id 获取元素的值，也就是这里的手机号和密码，在这里还都是原文，点到下一个函数则变成了密文，那么肯定是上一个函数做了手脚。\n\n认真观察，N 这个是我们的密码，但对 N 进行了一个操作也就是 `a.hex_md5(N)`，没错，这就是 md5 加密。有关加密的可以看看我写过的 [浅谈加密算法](./docs/brief-talk-encryption-algorithm)\n\n那么通过加密工具将 md5 加密是否能得到我们要的加密结果，如下\n\n![image-20200929005711500](https://img.kuizuo.cn/image-20200929005711500.png)\n\n`E9BC0E13A8A16CBB07B175D92A113126`在看看 Password 的值，一模一样，看来已经解决了一个参数，那么还有一个`sign`呢。貌似右边的函数调用栈都不好使，我试试搜索字符串 sign 看看\n\n![image-20200929005911119](https://img.kuizuo.cn/image-20200929005911119.png)\n\n好家伙，直接定位到了，那么同样的在这里下一个断点，查看一下到底发生了什么（实际上 js 静态分析就完事了，这个网站太简单了）\n\n这里的 N 看来就决定了 sign，而 N 也是通过 md5 加密的，不过原文我还不知道，让代码执行到这一行看看结果\n\n![image-20200929010417525](https://img.kuizuo.cn/image-20200929010417525.png)\n\n这里的 c 就是时间戳，而 token 和 password 都是未定义，那么就好办了。这里明文也就是 c `1601312429287`，那么用加密工具即可得到`777473FB2A1838DBD64BA7A11C98911B`，那么参数都搞定好了， 只需要替换一下账号，然后将正确的密码通过加密算法（这里为 md5）生成，同时对 sign 也生成出来，然后提交给服务器就能收到我们登录的请求，就认定为我们登录了，记录为在线用户。\n\n如果我用的加密算法错了，或者我分析错了，提交给服务器会是怎么样的\n\n![image-20200929011055451](https://img.kuizuo.cn/image-20200929011055451.png)\n\n例如我这里的 sign 算法是错了（将结尾的 B 改成了 A），发送给服务器，服务器返回给我们则是失败的结果，原因很简单，就是为了防止别人恶意登录所添加的效验，提交的数据伪成败，就决定了服务器给我们结果是成败。\n\n## 总结\n\n通过上面的一些例子，只要能伪造请求，发送给服务器，就能获取我们想要的结果或者目的，事实上也是如此，但伪造数据的难易则要由所对应的网站而定，有的网站压根就没没什么难度，而有的你搞一天都未必能搞的出来。如今的网站在这方面也都下足了功夫，想要轻松的伪造请求可不是件容易的事情了。\n\n也正是因为我学了 HTTP 请求与 JS 逆向分析，我能做的也就更多，而正是基于 HTTP 协议下，其中一个就是有关于超星刷课软件的例子，如果我没有学过这些，我就不可能写出来。\n\n后续会有关 HTTP 请求这方面都会放在逆向这个分类下，比如一些网站的加密算法和常见的坑等等。"
    },
    {
      "id": "chrome-plugin-development",
      "metadata": {
        "permalink": "/chrome-plugin-development",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/Chrome插件开发.md",
        "source": "@site/blog/program/Chrome插件开发.md",
        "title": "Chrome插件开发",
        "description": "前言",
        "date": "2020-09-28T00:00:00.000Z",
        "formattedDate": "2020年9月28日",
        "tags": [
          {
            "label": "chrome",
            "permalink": "/tags/chrome"
          },
          {
            "label": "plugin",
            "permalink": "/tags/plugin"
          },
          {
            "label": "develop",
            "permalink": "/tags/develop"
          }
        ],
        "readingTime": 12.26,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "chrome-plugin-development",
          "title": "Chrome插件开发",
          "date": "2020-09-28T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "chrome",
            "plugin",
            "develop"
          ],
          "keywords": [
            "chrome",
            "plugin",
            "develop"
          ]
        },
        "prevItem": {
          "title": "浅谈HTTP",
          "permalink": "/brief-talk-http"
        },
        "nextItem": {
          "title": "第一个博客搭建之Vuepress",
          "permalink": "/first-blog-is-vuepress"
        }
      },
      "content": "<!-- truncate -->\n\n## 前言\n\n相关文章 [谷歌官方文档](https://developer.chrome.com/extensions/manifest) (需翻墙)\n\n[Chrome 插件开发全攻略](http://blog.haoji.me/chrome-plugin-develop.html) （强烈推荐看这一篇！）\n\n你只需要看完上面那篇文章和掌握一些前端开发基础，就足以自行编写一个 Chrome 插件。本文也是基于上面文章加上自己之前写的插件所记。\n\n### 什么是 Chrome 插件\n\n如果你用过 Chrome 浏览器的话，也许会用到过一些插件，其中比较知名的就是油猴插件，通过这些插件能够帮你例如自动完成一些功能，屏蔽广告，相当于一个浏览器内置的脚本。应该来说这是 Chrome 扩展开发，不过说 Chrome 插件更顺口，后文也会说成 Chrome 插件。\n\n### 安装 Chrome 插件\n\n首先打开 Chrome，如下图即可进入插件的管理页面\n\n![image-20200922225606159](https://img.kuizuo.cn/image-20200922225606159.png)\n\n这时候记得把右上角的开发者模式给勾上，如果不勾上的话你无法直接将文件夹拖入 Chrome 进行安装，就只能安装`.crx`格式的文件。Chrome 要求插件必须从它的 Chrome 应用商店（需要翻墙）安装，其它任何网站下载的都无法直接安装，所以可以把`crx`文件解压，然后通过开发者模式直接加载。\n\n然后将写好的 Chrome 插件文件夹拖入到刚刚打开的插件管理页面即可。\n\n## Chrome 插件知识\n\n### manifest.json\n\n是`manifest.json`切记不要英文单词打错字，一定要有这个文件，且需要放在根目录上，否则就会出现未能成功加载扩展程序的错误。\n\n### background.html 和 background.js\n\n可以理解为后台，同时这个页面会一直常驻在浏览器中，而主要 background 权限非常高，几乎可以调用所有的 Chrome 扩展 API（除了 devtools），基本很多操作都是放在 background 执行，返回给 content，而且它可以**无限制跨域**，也就是可以跨域访问任何网站而无需要求对方设置`CORS`。这对我们后面要在 content 中发送跨域请求至关重要！\n\n我习惯的做法是通过`”page”：\"background.html\"`来导入`background.js`或其他 js 代码，如下\n\n```json\n// manifest.json\n \"background\": {\n    \"page\": \"background.html\",\n  },\n```\n\n```html\n<!-- background.html -->\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>背景页</title>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  </head>\n  <body>\n    <script type=\"text/javascript\" src=\"js/jquery.js\"></script>\n    <script type=\"text/javascript\" src=\"js/background.js\"></script>\n  </body>\n</html>\n```\n\n如果是 scripts 方式导入 js 文件则需要反复修改`manifest.json`文件。\n\n#### 关于乱码\n\n有时候你在编写代码中出现了中文可能会出现了如下的乱码，\n\n![image-20200923214834081](https://img.kuizuo.cn/image-20200923214834081.png)\n\n我遇到的原因是就是我原先的`background.html`代码写成如下的情况\n\n```html\n<script type=\"text/javascript\" src=\"js/jquery.js\"></script>\n<script type=\"text/javascript\" src=\"js/background.js\"></script>\n```\n\n没错，就只写了这两个行，就出现乱码（将 UTF-8 的编码变为了 windows1252），而只需要把 background.html 代码修改成正常的 HTML 结构，也就是上上面的那个代码即可解决该乱码情况。\n\n### content.js\n\n我们主要的向页面注入脚本就依靠这个文件，相当于给页面添加了一个 js 文件，但是`content`和原始页面**共享 DOM**，但是不共享 JS，如要**访问页面 JS（例如某个 JS 变量）**，只能通过`injected js`来实现（后文会提到）。并且`content`不能访问绝大部分`chrome.xxx.api`，除了下面这 4 种：\n\n- chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)\n- chrome.i18n\n- chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)\n- chrome.storage\n\n这些 API 绝大部分时候都够用了，非要调用其它 API 的话，你还可以通过通信来实现让 background 来帮你调用。\n\n### inject.js\n\n上文也说到了`content`是**无法访问页面中的 JS**，可以操作 DOM，但是 DOM 却不能调用它，也就是无法在 DOM 中通过绑定事件的方式调用`content`中的代码（包括直接写`onclick`和`addEventListener`2 种方式都不行），但是，**在页面上添加一个按钮并调用插件的扩展 API**是一个很常见的需求，那该怎么办呢？这时候就需要注入 inject.js 这个文件\n\n```js\ndocument.addEventListener('DOMContentLoaded', function () {\n  injectCustomJs()\n})\n\n// 向页面注入JS\nfunction injectCustomJs(jsPath) {\n  jsPath = jsPath || 'js/inject.js'\n  var temp = document.createElement('script')\n  temp.setAttribute('type', 'text/javascript')\n  // 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js\n  temp.src = chrome.extension.getURL(jsPath)\n  temp.onload = function () {\n    // 放在页面不好看，执行完后移除掉\n    this.parentNode.removeChild(this)\n  }\n  document.head.appendChild(temp)\n}\n```\n\n还没有完，因为注入有权限，所以需要在 manifest.json 声明一下这个文件。也就是下面的这行代码\n\n```js\n{\n\t// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的\n\t\"web_accessible_resources\": [\"js/inject.js\"],\n}\n```\n\n这样你就能调用\n\n### 关于消息通信\n\nChrome 插件主要就 4 个部分组成，injected，content，popup，background，但这 4 个部分所对应的权限，应用都有可能各自不一，这时候就需要通过消息通信，将对应的数据发送到对应的文件，主要也就如下四种通信方式：\n\n#### popup 和 background\n\npopup 可以直接调用 background 中的 JS 方法，也可以直接访问 background 的 DOM：\n\n```javascript\n// background.js\nfunction test() {\n  alert('我是background！')\n}\n\n// popup.js\nvar bg = chrome.extension.getBackgroundPage()\nbg.test() // 访问bg的函数\nalert(bg.document.body.innerHTML) // 访问bg的DOM\n```\n\n`background`访问`popup`如下（前提是`popup`已经打开）：\n\n```javascript\nvar views = chrome.extension.getViews({ type: 'popup' })\nif (views.length > 0) {\n  console.log(views[0].location.href)\n}\n```\n\n#### popup 或 bg 与 content\n\n##### popup 或 bg 向 content 发送请求\n\n```js\n//background.js或popup.js：\nfunction sendMessageToContentScript(message, callback) {\n  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n    chrome.tabs.sendMessage(tabs[0].id, message, function (response) {\n      if (callback) callback(response)\n    })\n  })\n}\n\nsendMessageToContentScript({ cmd: 'test', value: '你好，我是popup！' }, function (response) {\n  console.log('来自content的回复：' + response)\n})\n```\n\n`content.js`通过监听事件接收：\n\n```js\nchrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n  // console.log(sender.tab ?\"from a content script:\" + sender.tab.url :\"from the extension\");\n  if (request.cmd == 'test') alert(request.value)\n  sendResponse('我收到了你的消息！')\n})\n```\n\n##### content 向 popup 或 bg\n\n```js\n// content.js\nchrome.runtime.sendMessage({ greeting: '你好，我是content呀，我主动发消息给后台！' }, function (response) {\n  console.log('收到来自后台的回复：' + response)\n})\n```\n\n```js\n//background.js 或 popup.js：\n// 监听来自content的消息\nchrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n  console.log('收到来自content的消息：')\n  console.log(request, sender, sendResponse)\n  sendResponse('我是后台，我已收到你的消息：' + JSON.stringify(request))\n})\n```\n\n注意：\n\n- content_scripts 向`popup`主动发消息的前提是 popup 必须打开！否则需要利用 background 作中转；\n- 如果 background 和 popup 同时监听，那么它们都可以同时收到消息，但是只有一个可以 sendResponse，一个先发送了，那么另外一个再发送就无效；\n\n#### injected 和 content\n\n主要就是`injected`向`content`发送，`injected`无需监听。\n\n`content`和页面内的脚本（`injected`自然也属于页面内的脚本）之间唯一共享的东西就是页面的 DOM 元素，有 2 种方法可以实现二者通讯，：\n\n1. 可以通过`window.postMessage`和`window.addEventListener`来实现二者消息通讯；（推荐）\n2. 通过自定义 DOM 事件来实现（我就懒得写了，没怎么用到）；\n\n`injected`中：\n\n```js\nwindow.postMessage({ test: '你好！' }, '*')\n```\n\n`content script中`：\n\n```js\nwindow.addEventListener(\n  'message',\n  function (e) {\n    console.log(e.data)\n  },\n  false,\n)\n```\n\n#### injected 与 popup\n\n`injected`无法直接和`popup`通信，必须借助`content`作为中间人。不过一般这种都少，直接和 bg 通信即可。\n\n## 我的模板\n\n关于 Chrome 的主要内容也就这些，实际开发如果有个模板就能大大方便开发，在原文章中该作者已经分享了有对应的源代码，这里放上我自写的 Chrome 模板编写过程。\n\n![image-20210820004414785](https://img.kuizuo.cn/image-20210820004414785.png)\n\n当然，这里需要提几点地方：\n\n### 配置项与 storage\n\n首先是配置方面，有时候插件的内的选项是要记录，以便下一次在启动插件的时候还是上一次的配置。先看代码\n\n```html\n<!-- popup.js -->\n<div class=\"config-item\">\n  <input type=\"checkbox\" id=\"config1\" class=\"box configs\" />\n  <label class=\"hand\" for=\"config1\" title=\"配置1\">配置1</label>\n</div>\n<div class=\"config-item\">\n  <input type=\"checkbox\" id=\"config2\" class=\"box configs\" />\n  <label class=\"hand\" for=\"config2\" title=\"配置2\">配置2</label>\n</div>\n```\n\n```js\n// popup.js\n$(function () {\n  let configs = document.getElementsByClassName('configs')\n  for (let i = 0; i < configs.length; i++) {\n    let type = configs[i].type\n    if (type == 'checkbox') {\n      configs[i].onchange = function () {\n        chrome.storage.sync.set({\n          [this.id]: this.checked,\n        })\n      }\n      chrome.storage.sync.get(configs[i].id, function (items) {\n        configs[i].checked = items[configs[i].id] || false\n      })\n    } else if (type == 'text' || type == 'password') {\n      configs[i].onblur = function () {\n        chrome.storage.sync.set({ [this.id]: this.value })\n      }\n      chrome.storage.sync.get(configs[i].id, function (items) {\n        configs[i].value = items[configs[i].id] || ''\n      })\n    }\n  }\n})\n```\n\n可能需要多花点时间才能理解上面代码的意思，首先我在需要记录配置的地方添加了一个类`configs`，然后通过 js 代码遍历类名为`configs`，接着判断是多选框，还是输入框，input 的 id 为键名，value 为键值，来 set 或 get `chrome.storage`的值，然后进行事件绑定为修改配置后在记录一下配置。这里需要注意一下，写配置的时候`{ [this.id]: this.value }`这里的`this.id`是加了中括号的，原因就是这个 this.id 是变量，如果不加的话默认为字符串，但在这里有.所以是会报错的。\n\n强烈不建议用 localStorage，我当初第一遍学的时候没学明白，我还通过消息通信将配置信息发给`content`，然后还用 localStorage 记录一遍，现在才发现`chrome.storage`是针对插件全局的，即使你在`background`或者`popup中`保存的数据，在`content`也能获取到。\n\n当然这种读写配置的也算麻烦了，不像桌面级开发的读写配置。\n\n### 悬浮窗\n\n首先，一般对于网页端的插件，能提供的页面最好方式就是悬浮窗了，这里我也是通过 DOM 创建元素生成对象。而这个悬浮窗是针对页面的，而不是像 popup 那样。相关的页面初始化代码如下，\n\n```js\nvar view = {\n  show: true,\n  cache: {\n    count: 0,\n    type: 0,\n    mouse_x: -1,\n    mouse_y: -1,\n  },\n}\n\nfunction initView() {\n  view.float = $(`\n\t<div id=\"box\"\nstyle=\"position: fixed;border: 1px double rgb(0,0,0); width: 300px; top: 30px; right: 1%; z-index: 999999; font-size: 15px; background-color: rgb(255,255,255); color: #000000;user-select:none;\">\n<div style=\"position: relative;\">\n\t<button name=\"show\"\n\t\tstyle=\"position: absolute;top: 50%;right:1%; margin-top: 7px; line-height: 18px;overflow:hidden;border: 0px double rgb(0,0,0);cursor:pointer;font-size: 18px;background-color: rgb(255,255,255);\">－\n\t</button>\n</div>\n<div id=\"kz_title\" style=\"height: auto; margin: 5px; font-size: 16px;\">日志</div>\n\n<div id=\"kz_main\">\n\t<hr>\n\t<form>\n\t\t<div style=\"margin-top: 5px;overflow-y: auto;\">\n\t\t\t<button id=\"kz_id1\" name=\"cleanlog\"\n\t\t\t\tstyle=\"margin-left: 10px;float:left;border-radius:0em;overflow:hidden;border: 1px double rgb(0,0,0);background-color: rgb(255,255,255);\">功能按钮</button>\n\t\t\t<button id=\"kz_id2\" name=\"cleanlog\"\n\t\t\t\tstyle=\"margin-left: 10px;float:left;border-radius:0em;overflow:hidden;border: 1px double rgb(0,0,0);background-color: rgb(255,255,255);\">功能按钮</button>\n\t\t</div>\n\t</form><br>\n\t<div id=\"logList\"></div>\n</div>\n</div>\n\t`)\n  view.info = view.float.find('#info')\n  view.kz_title = view.float.find('#kz_title')\n  view.kz_main = view.float.find('#kz_main')\n  view.float.appendTo('body').delegate('button', 'click', function (e) {\n    e.stopImmediatePropagation()\n    e.stopPropagation()\n    e.preventDefault()\n    let name = $(this).attr('name')\n    if (name == 'show') {\n      $(this).html(view.show ? '＋' : '－')\n      view.show = !view.show\n      view.kz_main.slideToggle()\n    }\n  })\n  addViewMouseListener()\n  log('日志输出1')\n  log('日志输出2')\n  log('日志输出3')\n}\n\nfunction addViewMouseListener() {\n  view.float.bind('mousedown', function (event) {\n    view.cache.x = $(this).position().left\n    view.cache.y = $(this).position().top\n    view.cache.mouse_x = event.originalEvent.clientX\n    view.cache.mouse_y = event.originalEvent.clientY\n    //console.log(view.cache.mouse_x, view.cache.mouse_y, view.cache.x, view.cache.y)\n  })\n  $(document).bind('mousemove', function (event) {\n    //计算出现在的位置是多少\n    if (view.cache.mouse_x == -1) return\n    if (view.cache.mouse_y - view.cache.y > view.kz_title.height()) return\n    let new_position_left = event.originalEvent.clientX - view.cache.mouse_x + view.cache.x,\n      new_position_top = event.originalEvent.clientY - view.cache.mouse_y + view.cache.y\n    //加上边界限制\n    if (new_position_top < 0) {\n      //当上边的偏移量小于0的时候，就是上边的临界点，就让新的位置为0\n      new_position_top = 0\n    }\n    //如果向下的偏移量大于文档对象的高度减去自身的高度，就让它等于这个高度\n    if (new_position_top > $(document).height() - view.float.height() && $(document).height() - view.float.height() > 0) {\n      new_position_top = $(document).height() - view.float.height()\n    }\n    //右限制\n    if (new_position_left > $(document).width() - view.float.width()) {\n      new_position_left = $(document).width() - view.float.width()\n    }\n    if (new_position_left < 0) {\n      //左边的偏移量小于0的时候设置 左边的位置为0\n      new_position_left = 0\n    }\n    view.float.css({\n      left: new_position_left + 'px',\n      top: new_position_top + 'px',\n    })\n  })\n  $(document).bind('mouseup', function (event) {\n    view.cache.mouse_x = -1\n    view.cache.mouse_y = -1\n  })\n}\n\nfunction log(msg, color) {\n  let date = new Date()\n  let t = date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds()\n  msg = t + '  ' + msg\n  let div = $('<div class=\"log\"></div>').css({ 'border-color': 'rgba(121, 187, 255, 0.2)', 'background-color': 'rgba(121, 187, 255, 0.2)' })\n  let log = $('<p><span style=\"color: ' + (color || '#409EFF') + '\">' + msg + '</span></p>')\n\n  if ($('.log').length > 15) {\n    for (let i = 0; $('.log').length - 15; i++) {\n      $('.log')[i].remove()\n    }\n  }\n  $('#logList').append(div.append(log))\n}\n```\n\n然后在 content.js 内容的对页面 url 判断是否需要初始化悬浮窗即可\n\n```js\ndocument.addEventListener('DOMContentLoaded', function () {\n  if (location.host.indexOf('chaoxing') != -1) {\n    initView()\n  }\n})\n```\n\n如何发挥就看各位了。\n\n### 跨域请求\n\n关于跨域请求，我当初在学习 Chrome 插件的时候，就是卡在了跨域这个地方，那时候前端学的浅，对跨域都不知道处理，然后放弃学习了 Chrome 插件一段时间，后来有时间了，想在补一补之前没写完的 Chrome 扩展搞完。然而跨域请求非常简单，而我那时候之所以卡住就是因为没好好看文档，搞不定的地方就多看几遍说不准就搞定了。\n\n首先要使 Chrome 插件访问跨域资源，需要在 manifest.json 文件中声明要访问的域如下：\n\n```json\n{\n  \"permissions\": [\"http://www.google.com/\", \"http://*.google.com/\", \"https://*.google.com/\", \"http://*/\"]\n}\n```\n\n建议直接直接暴力点写上\n\n```json\n{\n  \"permissions\": [\"http://*/*\", \"https://*/*\"]\n}\n```\n\n然后封装一下对应的 ajax 请求，因为在 content 内进行 ajax 请求，是会在控制台输出跨域请求拦截，或者是 HTTPS 访问 HTTP 不安全等问题，这时候就需要通过消息通信，将 content 要发送的请求发送给 bg，让 bg 请求，然后等 bg 请求完毕，再将数据返回到 content 即可。下面是我对应的封装代码\n\n```js\n// background.js\nchrome.runtime.onMessage.addListener(function (req, sender, sendResponse) {\n  console.log(req, sender, sendResponse)\n  if (req.cmd == 'ajax') {\n    $.ajax({\n      url: req.url,\n      type: req.type,\n      data: req.data,\n      async: false,\n      success: function (res) {\n        sendResponse(res)\n      },\n    })\n  }\n})\n```\n\n```js\n// content.js\nfunction sendAjaxToBg(url, type, data, callback) {\n  chrome.runtime.sendMessage({ cmd: 'ajax', url: url, type: type, data: data }, function (response) {\n    callback(response)\n  })\n}\n```\n\n这里的话我通信发送的是 js 对象，其中 cmd 决定了我要的操作，后台通过判断 cmd 来执行对应的操作。比较不好理解的是回调函数，由于 JS 自身语言的因素与浏览器的问题，很多事件都是先挂着，后做完在回调，所以我这里就封装成这种形式，例如\n\n```js\nsendAjaxToBg(\"http://...\", \"GET\", null, function(response){\n\tconsole.log(response)\n\t...code\n})\n```\n\n这只是一个简单的 http 封装发送，如果要更复杂的话还可以添加协议头和 cookies，这里就不在补充了。\n\n### 一些自写 Chrome 插件\n\n实际上已经写过一些 Chrome 插件了，奈何写的比较烂或没搞完，也就暂时先不发，有时间会再整理一下自己所写的。\n\n一个验证码识别，有时候在登录的时候需要输入验证码是件非常痛苦的事情。于是乎我就通过调用打码 Api 接口写了个自动识别验证码并填写的。也提供了非常方便的右键识别验证码的功能。具体效果如图（实际上还是得第一次先确认要识别的图片框与输入框，下次加载的时候需要手动点击验证码才会自动生效，还是不够智能的，不过成就感十足）\n\n![image-20210820001938051](https://img.kuizuo.cn/image-20210820001938051.png)\n\n![wydm](https://img.kuizuo.cn/wydm.gif)\n\n另一个是基于某布大佬的 WebHook 工具，所更改的，不过一直停滞着，有空将其完善一下。"
    },
    {
      "id": "first-blog-is-vuepress",
      "metadata": {
        "permalink": "/first-blog-is-vuepress",
        "editUrl": "https://github.com/kuizuo/blog/edit/main/blog/program/第一个博客搭建之Vuepress.md",
        "source": "@site/blog/program/第一个博客搭建之Vuepress.md",
        "title": "第一个博客搭建之Vuepress",
        "description": "感谢 vuepress-theme-reco主题与一篇博客使用文章使用 vuepress 构建个人博客",
        "date": "2020-08-30T00:00:00.000Z",
        "formattedDate": "2020年8月30日",
        "tags": [
          {
            "label": "blog",
            "permalink": "/tags/blog"
          },
          {
            "label": "vuepress",
            "permalink": "/tags/vuepress"
          },
          {
            "label": "project",
            "permalink": "/tags/project"
          }
        ],
        "readingTime": 12.336666666666666,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "愧怍",
            "title": "全栈 typescripter / 学生",
            "url": "https://github.com/kuizuo",
            "imageURL": "/img/logo.webp",
            "key": "kuizuo"
          }
        ],
        "frontMatter": {
          "slug": "first-blog-is-vuepress",
          "title": "第一个博客搭建之Vuepress",
          "date": "2020-08-30T00:00:00.000Z",
          "authors": "kuizuo",
          "tags": [
            "blog",
            "vuepress",
            "project"
          ],
          "keywords": [
            "blog",
            "vuepress",
            "project"
          ]
        },
        "prevItem": {
          "title": "Chrome插件开发",
          "permalink": "/chrome-plugin-development"
        }
      },
      "content": "感谢 [vuepress-theme-reco](https://vuepress-theme-reco.recoluan.com/)主题与一篇博客使用文章[使用 vuepress 构建个人博客](https://lookroot.cn/views/article/vuepress.html#reco%E4%B8%BB%E9%A2%98)\n\n在写这篇文章前，本人非前端专业人士，只是一时兴起想开始搭建一个博客，在该博客上记录与分享一下自己所学的一切内容。（然后现在都在往前端这方向走了:joy:）\n\n:::info 新博客 🥳\n\n[第二个博客搭建之 Docusaurus](/second-blog-is-docusaurus)\n\n:::\n\n<!-- truncate -->\n\n## 补充\n\n不打算破坏之前所写的一些内容，将一些补充的内容写在开头，目前访问 kzcode.cn 依旧能访问到该站，不过文章都保留原有未变动，图片都是直接跟随 MD 文档下，加上服务器又比较拉，所以访问会稍带卡顿。这篇合理来说也算我的第一篇博客，所以还是有必要记录一下的。\n\n## 为什么写博客\n\n在接触软件行业的这一年里，也学到了很多很多很多的知识，也让我感受到代码的魅力与强大。在这学习过程中，百度到了各种相关学习文章，而这些正式前辈们所分享的学习经历，倘若没有这些，我可能早已停下学习的步伐。一时兴起，萌生了搭建博客的想法，然后开始搜索搭建博客的知识，于是乎就有了这篇文章。\n\n写博客是为了记录自己，记录自己学习中的过程，知识，遇到的坑，写成一篇文章，也许过了几个月后的自己脑子不好使，忘记是如何解决的，回过头来看，瞬间焕然大悟。同时也能巩固自己所学的，在如今这个时代，技术更新换代是真的快，而要求学的东西也就越来越多。有时候学过的一项技术，过了几个月真的说忘就忘，不时常记录一下当初写的笔记，翻看之前写过的代码，那真的就和重新学习没什么两样了。\n\n在此期间曾遇到许多坑，而解决最好的办法就是百度。在百度搜索过程中看到了许许多多的学习者分享自己那时候与我遇到一样的问题，说明他是如何解决的，并写文章。有时运气好可能他的解决办法同样也是我的解决办法，但往往总是不尽人意，这时需要再看下一个相关搜索或者下下个才能解决我的问题，这在学习过程中是必不可少的一个环节。而他们所分享的内容，就是一篇篇的博客。正是这一篇篇博客解惑学习者学习中的问题，让他们有自信再去学习下去！\n\n于是就萌生的一种想法，利用自己所学的 Web 知识开始搭建属于自己的个人博客，分享自己所遇到的坑，希望能解决遇到同样问题的人。\n\n### 初步搭建博客界面\n\n要展示给别人看，就必须得搞前端 UI 界面，同时为了快速开发，我又百度了相关的前端 UI 框架，其中决定用 layui，界面风格布局可以接受，于是乎在搜索用过 layui 框架搭建的个人博客，成功找到一篇博主[燕十三一个人的江湖](https://www.yanshisan.cn/)分享的模板源码，然后开始大改，最终花了几个小时修改了大致页面\n\n![image-20200901012343086](https://img.kuizuo.cn/image-20200901012343086.png)\n\n然后问题来了，前端大致界面设计好了，我最关心的文章要怎么写。。。而这份源码是没有给后端这些的（此时的我刚入前端，后端毛也不会），就一个纯前端页面，连文章模板都没有，可能是真的没什么可整理的，于是就放弃了自己手动搭建，主要还是那时候太菜了。\n\n就在想用纯静态页面，还是用动态页面，对于动态页面获取文章数据的技能并不熟练。然后发现这种想法并不行，还是得借助外界提供现有的博客系统来写，于是乎停滞了一段时间，去搜索一系列相关的博客系统（合理来说应该是静态文件生成器），如 Hexo 或 WordPress，不过为啥选择 vuepress，因为我那时候正好在学 Vue，于是乎又开始新的一番折腾。不过也好，如果以后写技术文档，vuepress 也是一个非常推荐的选择。后续的话可能会去接触一下 Hexo 的 butterfly 主题，希望学到点东西，能给自己的博客在增添几份美感。\n\n我所用的主题是[vuepress-theme-reco](https://vuepress-theme-reco.recoluan.com/) 也非常推荐用这个主题来写博客，下面会简单介绍这款主题\n\n## reco 主题\n\n> 一款简洁而优雅的 vuepress 博客 & 文档 主题。官方文档[立即前往](https://vuepress-theme-reco.recoluan.com/)\n\n![image-20200515152702435](https://img.kuizuo.cn/152702-539475.png)\n\n### **安装**\n\n```sh\n#全局安装vuepress-reco\nnpm install @vuepress-reco/theme-cli -g\n\n# 初始化 (blog改成你要的文件名)  然后填写项目标题等等\ntheme-cli init blog\n\n# 进入项目目录\ncd blog\n\n#安装依赖包\nnpm install\n\n# 运行\nnpm run dev\n\n# 编译\nnpm run build\n```\n\n执行完`npm run dev`运行后，点击控制台的对应地址 你就能看到\n\n![image-20200901191643031](https://img.kuizuo.cn/image-20200901191643031.png)\n\n当然，可能标题和一些会不一样，因为我更改了两处地方一处是`blog`下的`README.md`文件，文件结构如下\n\n```markdown\n---\nhome: true\nheroText: 愧怍的个人空间\ntagline: 我是愧怍,沉迷于代码无法自拔\n...\n```\n\n这个是决定首页的样式，具体要什么背景，内容就因人而异。\n\n另一处是`.vuepress\\config.js`里的内容，内容有点多，我依次来讲\n\n首先是开头几行的，title 决定你网站的标题，description 则是一开始出场界面的描述\n\n```js {2-3}\nmodule.exports = {\n  title: '愧怍的小站',\n  description: '如果代码都解决不了的话,那可能真的解决不了',\n}\n```\n\n随后你要关注的就是 themeConfig 下的 author，也就是作者名，改成你的名字就行\n\n```js {1,5,6}\n    \"logo\": \"/logo.png\",\n    \"search\": true,\n    \"searchMaxSuggestions\": 10,\n    \"lastUpdated\": \"Last Updated\",\n    \"author\": \"愧怍\",\n    \"authorAvatar\": \"/logo.png\",\n    \"record\": \"xxxx\",\n    \"startYear\": \"2017\"\n```\n\n其余的一些，比如`logo.png`与`avatar.png`啊，你换成你的想要的头像就行，他们都存放在.`vuepress\\public`下,然后就是修改标题栏，他们都放在`themeConfig`下的`nav`里，这里你想修改哪个导航栏，就改哪个导航栏与标题，文末我会放上我的全部代码。\n\n```js\n\"themeConfig\": {\n    \"nav\": [\n      {\n        \"text\": \"Home\",\n        \"link\": \"/\",\n        \"icon\": \"reco-home\"\n      },\n      {\n        \"text\": \"TimeLine\",\n        \"link\": \"/timeline/\",\n        \"icon\": \"reco-date\"\n      },\n      {\n        \"text\": \"Docs\",\n        \"icon\": \"reco-message\",\n        \"items\": [\n          {\n            \"text\": \"vuepress-reco\",\n            \"link\": \"/docs/theme-reco/\"\n          }\n        ]\n      },\n      {\n        \"text\": \"Contact\",\n        \"icon\": \"reco-message\",\n        \"items\": [\n          {\n            \"text\": \"GitHub\",\n            \"link\": \"https://github.com/recoluan\",\n            \"icon\": \"reco-github\"\n          }\n        ]\n      }\n    ],\n```\n\n还有一个是主题自带的导航栏配置，这里你只需要更改 text 与 location 即可，其余不建议更改，你到时候写的文章都在依靠这两个\n\n```js\n\"blogConfig\": {\n      \"category\": {\n        \"location\": 2,\n        \"text\": \"Category\"\n      },\n      \"tag\": {\n        \"location\": 3,\n        \"text\": \"Tag\"\n      }\n    },\n```\n\nzhuyi 你每次修改修改 config 的内容，就需要重新`npm run dev` vuepress 不支持热更新，也就是文件内容给修改了你需要重新编译运行，这是初学接触会遇到的坑。\n\n### 编写文章\n\n现在有了一个页面风格不错，同时还是响应式页面，就差文章了。这时候你就需要了解 vuepress 的[Markdown 拓展](https://vuepress.vuejs.org/zh/guide/markdown.html#front-matter)，我这里简单叙述一下，你该怎么写文章，下面是你要写文章的模板，你只需要关注几个内容就行了，\n\n```markdown\n---\ntitle: 笔记模板\ndate: 2020-08-21\ntags:\n  - 笔记\ncategories:\n  - 个人学习笔记\nauthor: 愧怍\nkeys:\n  - 'e9bc0e13a8a16cbb07b175d92a113126'\npublish: false\nisShowComments: false\n---\n\n::: tip\n\n这是 tip\n\n:::\n\n<!--more -->\n\n## 这是你的文章内容\n\n正文内容\n```\n\n`---` 所包裹的内容就文章简述像下面这样\n\n![image-20200901034715126](https://img.kuizuo.cn/image-20200901034715126.png)\n\n要更改标题，日期外，你还需要更改的是分类 categories 和标签 tags，举个例子，现在我想写一篇文章，标题是 ES6 语法，那么我可以这么写\n\n```yaml\ntags:\n  - ES6\n  - javascript\n  - js\ncategories:\n  - JavaScript\n```\n\n分类只写一个，可以写`JavaScript`（分类建议大写），标签写多个，然后你把你写的这篇文章，切记放在`blogs`目录下(以后写的博客都放在这里)，同时建一个文件夹名为`JavaScript`，的然后把文章放在这个目录下，文章名随意，建议和标题一样，如 ES6 语法.md。便于你以后分类，请按这样的方式归类文章。\n\n万一我不小心`- JavaScript` 写成了 `- Java`，而并没有文件夹是`Java`的，没关系，也就是你在分类上看到 Java，文章分类不取决于文件夹名，而取决于`categories` 只是文件夹名和`categories`名一致便于分类罢了。\n\n在标签页上，就能看到 ES6，javascript，与 js 的标签，方便定位相关文章\n\n接着把要写的文章内容全都在写在<!--more -->下即可，这里要注意一下，正文内容的标题，从二级标题开始，一级标题就已经是 title 了，在写也没用。\n\n其余相关的 key 和 publish 等相关参数还请读者查看 reco 主题的官方文档[立即前往](https://vuepress-theme-reco.recoluan.com/)与 vuepress 官网[立即前往](https://vuepress.vuejs.org/zh/)\n\n### 样式修改\n\n可能你会局限于 reco 主题的默认样式，这里就说下如何修改样式。如果你会点前端，这应该来说非常简单。\n\n1. 先参考这篇文章 [个人向优化](https://vuepress-theme-reco.recoluan.com/views/other/reco-optimization.html)，我这里简单说明一下，首先一定要把`node_modules`里的`vuepress-theme-reco`这个主题文件夹整个放在`.vuepress\\theme\\`下，因为有些时候我们是要修改源码来更改样式的，如果你不这样做的话，而是直接修改`node_modules`里面的文件，你`npm install`就会覆盖你修改后的，所以要这一步操作。\n2. 当然你已经觉得 reco 主题都很完美了，不需要更改源码，那么你只需要在 `.vuepress/styles/` 来创建文件`index.styl`来方便地添加额外样式（还有一个默认样式，不推荐修改），然后把你要修改的样式代码写在`index.styl`文件里即可，例如我要修改首页的字体颜色，右键检查找到对应的 css 选择器，然后在`index.styl`添加就行，如\n\n```css\n.home-blog .hero h1 {\n  color: #fff;\n}\n```\n\n### 部署到服务器上\n\n关于部署到服务器上，如果只是为了让别人能看到你搭建的博客，而不是要购买域名和服务器这些，直接参考文章[使用 vuepress 构建个人博客](https://lookroot.cn/views/article/vuepress.html#reco%E4%B8%BB%E9%A2%98)即可，如果有服务器和域名我这里简单说下怎么个部署法。\n\n```shell\nnpm run bulid\n```\n\n首先执行上一行代码，然后在目录下会生成`public`文件夹，这个文件夹就是你所有的网站静态文件，这时候你需要你的服务器开启一个 web 服务，我这里用的是腾讯云 CentOS 与宝塔面板（至于这两个怎么搞，外面教程太多了），这里我就用 Nginx。然后如下图添加站点\n\n![image-20200918194540550](https://img.kuizuo.cn/image-20200918194540550.png)\n\n因个人情况填写域名，FTP，数据库等等，然后通过 ftp 工具直接传文件至站点对应的目录下，然后访问服务器对应的 ip 地址或者个人域名解析就行了。\n\n不过这个还要手动部署特别麻烦，有没有什么命令能一键部署的，有，这里我推荐一篇文章[一键部署到服务器](https://reinness.com/views/technology-sharing/vuepress/auto_deploy.html#index-js)，解决了我当初一直用 ftp 的痛点。不过有个更简单的自动部署脚本，scp2，有兴趣可以自行查阅。\n\n## 自己搭建遇到的坑\n\n### 图片路径\n\n首先就是 markdown 图片相对路径的坑，在写文章的话，如果涉及的本地图片引入，那么默认不操作的，也就是需要配置一下，默认在当前同级文件下，在创建一个文件名相同的文件夹来存放图片，我这里就以 Typora 为例，如图\n\n![image-20200901180754412](https://img.kuizuo.cn/image-20200901180754412.png)\n\n其次，Typora 的路径是不带`./`，在 vuepress 会被编译成绝对路径。需要在前面添加上`./`，不过主题内已自带插件`markdown-it`，这个问题无需担心。\n\n但常常我们的 md 文件名是中文的，这时候相对路径带有中文，但是 vuepress 会将中文路径进行 url 编码，\n\n不会将你的这些图片编译到静态文件上，所以需要做一些操作\n\n#### 解决方法\n\n1. 安装 markdown-it-disable-url-encode\n\n```sh\nnpm i markdown-it-disable-url-encode\n```\n\n2. 在.vuepress/config.js 中配置如下\n\n```js\n  markdown: {\n    extendMarkdown: md => {\n      md.use(require(\"markdown-it-disable-url-encode\"));\n    }\n  },\n```\n\n现在你用 Typora 就引用本地图片就可以在 vuepress 中完美显示了。\n\n> 参考 [Vuepress 图片资源中文路径问题](https://segmentfault.com/a/1190000022275001) 完美解决上述问题\n\n### 引入 UI 组件库报错\n\n如果你在该主题使用其他 UI 组件库，如 element，ant design，那么你很有可能会编译失败，官方解释\n\n![image-20201223042921876](https://img.kuizuo.cn/image-20201223042921876.png)\n\n解决办法很简单，先删除 node_modules，然后**再安装 ui 组件库**依赖后，再安装其他依赖就行了。\n\n## 放一些链接\n\n放一些自己搭建这个博客过程中用到的一些链接地址，主要针对插件安装这些\n\n- [VuePress 官网](https://vuepress.vuejs.org/zh/)\n- [VuePress 社区](https://vuepress.github.io/)\n- [awesome-vuepress](https://github.com/vuepress/awesome-vuepress)\n- [reco 主题](https://vuepress-theme-reco.recoluan.com/)\n- [一个非常详细的搭建教程](https://blog.csdn.net/sudadaipeng1/article/details/102971008#%e6%b7%bb%e5%8a%a0svg-label%e6%a0%87%e7%ad%be)\n\n## 总结\n\n就此，就可以好好的编写文章，主题固然方便，快捷搭建博客同时也别光顾这美化博客，注重分享文章，这才是博客的真正意义。reco 的主题也是希望帮助更多的人花更多的时间在内容创作上，而不是博客搭建上。\n\n在使用 Vuepress 的一段时间，发现他更适合写的是文档，写博客可以，但花里胡哨的点少，比较简约，对于我这种又爱折腾的人来说，后续有可能会借鉴 Hexo 博客的一款主题 butterfly，将其源码复制到目前这个博客上，顺便巩固下自己的前端设计基础。\n\n但还是要说的，要看自己到底要不要搭建博客，记录与分享文章，别盲目跟从。同时如果搭建博客，请把重心放在创作和笔记上，反复去美化主题对技术的提升远不如一篇有技术性的文章总结。\n\n最后，希望我所分享的所有内容，正是你目前所遇到的难题，能为你排坑，便足矣。"
    }
  ]
}